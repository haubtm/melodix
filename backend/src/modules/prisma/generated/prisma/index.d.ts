
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Artist
 * 
 */
export type Artist = $Result.DefaultSelection<Prisma.$ArtistPayload>
/**
 * Model Album
 * 
 */
export type Album = $Result.DefaultSelection<Prisma.$AlbumPayload>
/**
 * Model Song
 * 
 */
export type Song = $Result.DefaultSelection<Prisma.$SongPayload>
/**
 * Model Genre
 * 
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>
/**
 * Model SongGenre
 * 
 */
export type SongGenre = $Result.DefaultSelection<Prisma.$SongGenrePayload>
/**
 * Model ArtistGenre
 * 
 */
export type ArtistGenre = $Result.DefaultSelection<Prisma.$ArtistGenrePayload>
/**
 * Model SongArtist
 * 
 */
export type SongArtist = $Result.DefaultSelection<Prisma.$SongArtistPayload>
/**
 * Model Playlist
 * 
 */
export type Playlist = $Result.DefaultSelection<Prisma.$PlaylistPayload>
/**
 * Model PlaylistSong
 * 
 */
export type PlaylistSong = $Result.DefaultSelection<Prisma.$PlaylistSongPayload>
/**
 * Model UserFollow
 * 
 */
export type UserFollow = $Result.DefaultSelection<Prisma.$UserFollowPayload>
/**
 * Model UserLibrary
 * 
 */
export type UserLibrary = $Result.DefaultSelection<Prisma.$UserLibraryPayload>
/**
 * Model ListeningHistory
 * 
 */
export type ListeningHistory = $Result.DefaultSelection<Prisma.$ListeningHistoryPayload>
/**
 * Model RecentlyPlayed
 * 
 */
export type RecentlyPlayed = $Result.DefaultSelection<Prisma.$RecentlyPlayedPayload>
/**
 * Model PlaybackQueue
 * 
 */
export type PlaybackQueue = $Result.DefaultSelection<Prisma.$PlaybackQueuePayload>
/**
 * Model PlaybackState
 * 
 */
export type PlaybackState = $Result.DefaultSelection<Prisma.$PlaybackStatePayload>
/**
 * Model UserOAuthAccount
 * 
 */
export type UserOAuthAccount = $Result.DefaultSelection<Prisma.$UserOAuthAccountPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model UserDevice
 * 
 */
export type UserDevice = $Result.DefaultSelection<Prisma.$UserDevicePayload>
/**
 * Model DeviceSyncState
 * 
 */
export type DeviceSyncState = $Result.DefaultSelection<Prisma.$DeviceSyncStatePayload>
/**
 * Model SyncLog
 * 
 */
export type SyncLog = $Result.DefaultSelection<Prisma.$SyncLogPayload>
/**
 * Model DeviceTransfer
 * 
 */
export type DeviceTransfer = $Result.DefaultSelection<Prisma.$DeviceTransferPayload>
/**
 * Model SubscriptionPlan
 * 
 */
export type SubscriptionPlan = $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>
/**
 * Model UserSubscription
 * 
 */
export type UserSubscription = $Result.DefaultSelection<Prisma.$UserSubscriptionPayload>
/**
 * Model Advertisement
 * 
 */
export type Advertisement = $Result.DefaultSelection<Prisma.$AdvertisementPayload>
/**
 * Model AdImpression
 * 
 */
export type AdImpression = $Result.DefaultSelection<Prisma.$AdImpressionPayload>
/**
 * Model UserAdSettings
 * 
 */
export type UserAdSettings = $Result.DefaultSelection<Prisma.$UserAdSettingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SubscriptionType: {
  free: 'free',
  premium: 'premium',
  family: 'family'
};

export type SubscriptionType = (typeof SubscriptionType)[keyof typeof SubscriptionType]


export const AlbumType: {
  album: 'album',
  single: 'single',
  ep: 'ep',
  compilation: 'compilation'
};

export type AlbumType = (typeof AlbumType)[keyof typeof AlbumType]


export const ArtistRole: {
  primary: 'primary',
  featured: 'featured',
  composer: 'composer',
  producer: 'producer'
};

export type ArtistRole = (typeof ArtistRole)[keyof typeof ArtistRole]


export const FollowType: {
  artist: 'artist',
  user: 'user',
  playlist: 'playlist'
};

export type FollowType = (typeof FollowType)[keyof typeof FollowType]


export const LibraryItemType: {
  song: 'song',
  album: 'album',
  playlist: 'playlist',
  artist: 'artist'
};

export type LibraryItemType = (typeof LibraryItemType)[keyof typeof LibraryItemType]


export const ContextType: {
  album: 'album',
  playlist: 'playlist',
  artist: 'artist',
  search: 'search',
  radio: 'radio'
};

export type ContextType = (typeof ContextType)[keyof typeof ContextType]


export const RepeatMode: {
  off: 'off',
  all: 'all',
  one: 'one'
};

export type RepeatMode = (typeof RepeatMode)[keyof typeof RepeatMode]


export const ShuffleMode: {
  off: 'off',
  normal: 'normal',
  smart: 'smart'
};

export type ShuffleMode = (typeof ShuffleMode)[keyof typeof ShuffleMode]


export const DeviceType: {
  web: 'web',
  ios: 'ios',
  android: 'android',
  desktop: 'desktop'
};

export type DeviceType = (typeof DeviceType)[keyof typeof DeviceType]


export const SyncType: {
  library: 'library',
  playlists: 'playlists',
  playback: 'playback',
  queue: 'queue'
};

export type SyncType = (typeof SyncType)[keyof typeof SyncType]


export const SyncAction: {
  create: 'create',
  update: 'update',
  delete: 'delete'
};

export type SyncAction = (typeof SyncAction)[keyof typeof SyncAction]


export const TransferStatus: {
  pending: 'pending',
  accepted: 'accepted',
  rejected: 'rejected',
  expired: 'expired'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const AudioQuality: {
  normal: 'normal',
  high: 'high',
  lossless: 'lossless'
};

export type AudioQuality = (typeof AudioQuality)[keyof typeof AudioQuality]


export const SubscriptionStatus: {
  active: 'active',
  cancelled: 'cancelled',
  expired: 'expired',
  paused: 'paused'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const BillingCycle: {
  monthly: 'monthly',
  yearly: 'yearly'
};

export type BillingCycle = (typeof BillingCycle)[keyof typeof BillingCycle]


export const AdType: {
  audio: 'audio',
  banner: 'banner',
  video: 'video',
  popup: 'popup'
};

export type AdType = (typeof AdType)[keyof typeof AdType]


export const ImpressionType: {
  view: 'view',
  click: 'click',
  skip: 'skip',
  complete: 'complete'
};

export type ImpressionType = (typeof ImpressionType)[keyof typeof ImpressionType]


export const AdContextType: {
  between_songs: 'between_songs',
  app_open: 'app_open',
  browse: 'browse'
};

export type AdContextType = (typeof AdContextType)[keyof typeof AdContextType]

}

export type SubscriptionType = $Enums.SubscriptionType

export const SubscriptionType: typeof $Enums.SubscriptionType

export type AlbumType = $Enums.AlbumType

export const AlbumType: typeof $Enums.AlbumType

export type ArtistRole = $Enums.ArtistRole

export const ArtistRole: typeof $Enums.ArtistRole

export type FollowType = $Enums.FollowType

export const FollowType: typeof $Enums.FollowType

export type LibraryItemType = $Enums.LibraryItemType

export const LibraryItemType: typeof $Enums.LibraryItemType

export type ContextType = $Enums.ContextType

export const ContextType: typeof $Enums.ContextType

export type RepeatMode = $Enums.RepeatMode

export const RepeatMode: typeof $Enums.RepeatMode

export type ShuffleMode = $Enums.ShuffleMode

export const ShuffleMode: typeof $Enums.ShuffleMode

export type DeviceType = $Enums.DeviceType

export const DeviceType: typeof $Enums.DeviceType

export type SyncType = $Enums.SyncType

export const SyncType: typeof $Enums.SyncType

export type SyncAction = $Enums.SyncAction

export const SyncAction: typeof $Enums.SyncAction

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type AudioQuality = $Enums.AudioQuality

export const AudioQuality: typeof $Enums.AudioQuality

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type BillingCycle = $Enums.BillingCycle

export const BillingCycle: typeof $Enums.BillingCycle

export type AdType = $Enums.AdType

export const AdType: typeof $Enums.AdType

export type ImpressionType = $Enums.ImpressionType

export const ImpressionType: typeof $Enums.ImpressionType

export type AdContextType = $Enums.AdContextType

export const AdContextType: typeof $Enums.AdContextType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artist`: Exposes CRUD operations for the **Artist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artists
    * const artists = await prisma.artist.findMany()
    * ```
    */
  get artist(): Prisma.ArtistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.album`: Exposes CRUD operations for the **Album** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Albums
    * const albums = await prisma.album.findMany()
    * ```
    */
  get album(): Prisma.AlbumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.song`: Exposes CRUD operations for the **Song** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Songs
    * const songs = await prisma.song.findMany()
    * ```
    */
  get song(): Prisma.SongDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.songGenre`: Exposes CRUD operations for the **SongGenre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SongGenres
    * const songGenres = await prisma.songGenre.findMany()
    * ```
    */
  get songGenre(): Prisma.SongGenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artistGenre`: Exposes CRUD operations for the **ArtistGenre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArtistGenres
    * const artistGenres = await prisma.artistGenre.findMany()
    * ```
    */
  get artistGenre(): Prisma.ArtistGenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.songArtist`: Exposes CRUD operations for the **SongArtist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SongArtists
    * const songArtists = await prisma.songArtist.findMany()
    * ```
    */
  get songArtist(): Prisma.SongArtistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlist`: Exposes CRUD operations for the **Playlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Playlists
    * const playlists = await prisma.playlist.findMany()
    * ```
    */
  get playlist(): Prisma.PlaylistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlistSong`: Exposes CRUD operations for the **PlaylistSong** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaylistSongs
    * const playlistSongs = await prisma.playlistSong.findMany()
    * ```
    */
  get playlistSong(): Prisma.PlaylistSongDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFollow`: Exposes CRUD operations for the **UserFollow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFollows
    * const userFollows = await prisma.userFollow.findMany()
    * ```
    */
  get userFollow(): Prisma.UserFollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLibrary`: Exposes CRUD operations for the **UserLibrary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLibraries
    * const userLibraries = await prisma.userLibrary.findMany()
    * ```
    */
  get userLibrary(): Prisma.UserLibraryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listeningHistory`: Exposes CRUD operations for the **ListeningHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListeningHistories
    * const listeningHistories = await prisma.listeningHistory.findMany()
    * ```
    */
  get listeningHistory(): Prisma.ListeningHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recentlyPlayed`: Exposes CRUD operations for the **RecentlyPlayed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecentlyPlayeds
    * const recentlyPlayeds = await prisma.recentlyPlayed.findMany()
    * ```
    */
  get recentlyPlayed(): Prisma.RecentlyPlayedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playbackQueue`: Exposes CRUD operations for the **PlaybackQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaybackQueues
    * const playbackQueues = await prisma.playbackQueue.findMany()
    * ```
    */
  get playbackQueue(): Prisma.PlaybackQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playbackState`: Exposes CRUD operations for the **PlaybackState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaybackStates
    * const playbackStates = await prisma.playbackState.findMany()
    * ```
    */
  get playbackState(): Prisma.PlaybackStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userOAuthAccount`: Exposes CRUD operations for the **UserOAuthAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOAuthAccounts
    * const userOAuthAccounts = await prisma.userOAuthAccount.findMany()
    * ```
    */
  get userOAuthAccount(): Prisma.UserOAuthAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userDevice`: Exposes CRUD operations for the **UserDevice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDevices
    * const userDevices = await prisma.userDevice.findMany()
    * ```
    */
  get userDevice(): Prisma.UserDeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceSyncState`: Exposes CRUD operations for the **DeviceSyncState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceSyncStates
    * const deviceSyncStates = await prisma.deviceSyncState.findMany()
    * ```
    */
  get deviceSyncState(): Prisma.DeviceSyncStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncLog`: Exposes CRUD operations for the **SyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncLogs
    * const syncLogs = await prisma.syncLog.findMany()
    * ```
    */
  get syncLog(): Prisma.SyncLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceTransfer`: Exposes CRUD operations for the **DeviceTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTransfers
    * const deviceTransfers = await prisma.deviceTransfer.findMany()
    * ```
    */
  get deviceTransfer(): Prisma.DeviceTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPlans
    * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
    * ```
    */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSubscription`: Exposes CRUD operations for the **UserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubscriptions
    * const userSubscriptions = await prisma.userSubscription.findMany()
    * ```
    */
  get userSubscription(): Prisma.UserSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.advertisement`: Exposes CRUD operations for the **Advertisement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advertisements
    * const advertisements = await prisma.advertisement.findMany()
    * ```
    */
  get advertisement(): Prisma.AdvertisementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adImpression`: Exposes CRUD operations for the **AdImpression** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdImpressions
    * const adImpressions = await prisma.adImpression.findMany()
    * ```
    */
  get adImpression(): Prisma.AdImpressionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAdSettings`: Exposes CRUD operations for the **UserAdSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAdSettings
    * const userAdSettings = await prisma.userAdSettings.findMany()
    * ```
    */
  get userAdSettings(): Prisma.UserAdSettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Artist: 'Artist',
    Album: 'Album',
    Song: 'Song',
    Genre: 'Genre',
    SongGenre: 'SongGenre',
    ArtistGenre: 'ArtistGenre',
    SongArtist: 'SongArtist',
    Playlist: 'Playlist',
    PlaylistSong: 'PlaylistSong',
    UserFollow: 'UserFollow',
    UserLibrary: 'UserLibrary',
    ListeningHistory: 'ListeningHistory',
    RecentlyPlayed: 'RecentlyPlayed',
    PlaybackQueue: 'PlaybackQueue',
    PlaybackState: 'PlaybackState',
    UserOAuthAccount: 'UserOAuthAccount',
    UserSession: 'UserSession',
    UserDevice: 'UserDevice',
    DeviceSyncState: 'DeviceSyncState',
    SyncLog: 'SyncLog',
    DeviceTransfer: 'DeviceTransfer',
    SubscriptionPlan: 'SubscriptionPlan',
    UserSubscription: 'UserSubscription',
    Advertisement: 'Advertisement',
    AdImpression: 'AdImpression',
    UserAdSettings: 'UserAdSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "artist" | "album" | "song" | "genre" | "songGenre" | "artistGenre" | "songArtist" | "playlist" | "playlistSong" | "userFollow" | "userLibrary" | "listeningHistory" | "recentlyPlayed" | "playbackQueue" | "playbackState" | "userOAuthAccount" | "userSession" | "userDevice" | "deviceSyncState" | "syncLog" | "deviceTransfer" | "subscriptionPlan" | "userSubscription" | "advertisement" | "adImpression" | "userAdSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Artist: {
        payload: Prisma.$ArtistPayload<ExtArgs>
        fields: Prisma.ArtistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          findFirst: {
            args: Prisma.ArtistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          findMany: {
            args: Prisma.ArtistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>[]
          }
          create: {
            args: Prisma.ArtistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          createMany: {
            args: Prisma.ArtistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>[]
          }
          delete: {
            args: Prisma.ArtistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          update: {
            args: Prisma.ArtistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          deleteMany: {
            args: Prisma.ArtistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>[]
          }
          upsert: {
            args: Prisma.ArtistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistPayload>
          }
          aggregate: {
            args: Prisma.ArtistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtist>
          }
          groupBy: {
            args: Prisma.ArtistGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtistGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtistCountArgs<ExtArgs>
            result: $Utils.Optional<ArtistCountAggregateOutputType> | number
          }
        }
      }
      Album: {
        payload: Prisma.$AlbumPayload<ExtArgs>
        fields: Prisma.AlbumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlbumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlbumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          findFirst: {
            args: Prisma.AlbumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlbumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          findMany: {
            args: Prisma.AlbumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          create: {
            args: Prisma.AlbumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          createMany: {
            args: Prisma.AlbumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlbumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          delete: {
            args: Prisma.AlbumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          update: {
            args: Prisma.AlbumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          deleteMany: {
            args: Prisma.AlbumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlbumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlbumUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          upsert: {
            args: Prisma.AlbumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          aggregate: {
            args: Prisma.AlbumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlbum>
          }
          groupBy: {
            args: Prisma.AlbumGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlbumGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlbumCountArgs<ExtArgs>
            result: $Utils.Optional<AlbumCountAggregateOutputType> | number
          }
        }
      }
      Song: {
        payload: Prisma.$SongPayload<ExtArgs>
        fields: Prisma.SongFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SongFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SongFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          findFirst: {
            args: Prisma.SongFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SongFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          findMany: {
            args: Prisma.SongFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>[]
          }
          create: {
            args: Prisma.SongCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          createMany: {
            args: Prisma.SongCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SongCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>[]
          }
          delete: {
            args: Prisma.SongDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          update: {
            args: Prisma.SongUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          deleteMany: {
            args: Prisma.SongDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SongUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SongUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>[]
          }
          upsert: {
            args: Prisma.SongUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongPayload>
          }
          aggregate: {
            args: Prisma.SongAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSong>
          }
          groupBy: {
            args: Prisma.SongGroupByArgs<ExtArgs>
            result: $Utils.Optional<SongGroupByOutputType>[]
          }
          count: {
            args: Prisma.SongCountArgs<ExtArgs>
            result: $Utils.Optional<SongCountAggregateOutputType> | number
          }
        }
      }
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>
        fields: Prisma.GenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      SongGenre: {
        payload: Prisma.$SongGenrePayload<ExtArgs>
        fields: Prisma.SongGenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SongGenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SongGenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          findFirst: {
            args: Prisma.SongGenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SongGenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          findMany: {
            args: Prisma.SongGenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>[]
          }
          create: {
            args: Prisma.SongGenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          createMany: {
            args: Prisma.SongGenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SongGenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>[]
          }
          delete: {
            args: Prisma.SongGenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          update: {
            args: Prisma.SongGenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          deleteMany: {
            args: Prisma.SongGenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SongGenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SongGenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>[]
          }
          upsert: {
            args: Prisma.SongGenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongGenrePayload>
          }
          aggregate: {
            args: Prisma.SongGenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSongGenre>
          }
          groupBy: {
            args: Prisma.SongGenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<SongGenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.SongGenreCountArgs<ExtArgs>
            result: $Utils.Optional<SongGenreCountAggregateOutputType> | number
          }
        }
      }
      ArtistGenre: {
        payload: Prisma.$ArtistGenrePayload<ExtArgs>
        fields: Prisma.ArtistGenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtistGenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtistGenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          findFirst: {
            args: Prisma.ArtistGenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtistGenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          findMany: {
            args: Prisma.ArtistGenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>[]
          }
          create: {
            args: Prisma.ArtistGenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          createMany: {
            args: Prisma.ArtistGenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtistGenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>[]
          }
          delete: {
            args: Prisma.ArtistGenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          update: {
            args: Prisma.ArtistGenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          deleteMany: {
            args: Prisma.ArtistGenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtistGenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtistGenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>[]
          }
          upsert: {
            args: Prisma.ArtistGenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtistGenrePayload>
          }
          aggregate: {
            args: Prisma.ArtistGenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtistGenre>
          }
          groupBy: {
            args: Prisma.ArtistGenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtistGenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtistGenreCountArgs<ExtArgs>
            result: $Utils.Optional<ArtistGenreCountAggregateOutputType> | number
          }
        }
      }
      SongArtist: {
        payload: Prisma.$SongArtistPayload<ExtArgs>
        fields: Prisma.SongArtistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SongArtistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SongArtistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          findFirst: {
            args: Prisma.SongArtistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SongArtistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          findMany: {
            args: Prisma.SongArtistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>[]
          }
          create: {
            args: Prisma.SongArtistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          createMany: {
            args: Prisma.SongArtistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SongArtistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>[]
          }
          delete: {
            args: Prisma.SongArtistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          update: {
            args: Prisma.SongArtistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          deleteMany: {
            args: Prisma.SongArtistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SongArtistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SongArtistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>[]
          }
          upsert: {
            args: Prisma.SongArtistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SongArtistPayload>
          }
          aggregate: {
            args: Prisma.SongArtistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSongArtist>
          }
          groupBy: {
            args: Prisma.SongArtistGroupByArgs<ExtArgs>
            result: $Utils.Optional<SongArtistGroupByOutputType>[]
          }
          count: {
            args: Prisma.SongArtistCountArgs<ExtArgs>
            result: $Utils.Optional<SongArtistCountAggregateOutputType> | number
          }
        }
      }
      Playlist: {
        payload: Prisma.$PlaylistPayload<ExtArgs>
        fields: Prisma.PlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findFirst: {
            args: Prisma.PlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findMany: {
            args: Prisma.PlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          create: {
            args: Prisma.PlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          createMany: {
            args: Prisma.PlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          delete: {
            args: Prisma.PlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          update: {
            args: Prisma.PlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          aggregate: {
            args: Prisma.PlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylist>
          }
          groupBy: {
            args: Prisma.PlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistCountAggregateOutputType> | number
          }
        }
      }
      PlaylistSong: {
        payload: Prisma.$PlaylistSongPayload<ExtArgs>
        fields: Prisma.PlaylistSongFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistSongFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistSongFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload>
          }
          findFirst: {
            args: Prisma.PlaylistSongFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistSongFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload>
          }
          findMany: {
            args: Prisma.PlaylistSongFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload>[]
          }
          create: {
            args: Prisma.PlaylistSongCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload>
          }
          createMany: {
            args: Prisma.PlaylistSongCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistSongCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload>[]
          }
          delete: {
            args: Prisma.PlaylistSongDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload>
          }
          update: {
            args: Prisma.PlaylistSongUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistSongDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistSongUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaylistSongUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload>[]
          }
          upsert: {
            args: Prisma.PlaylistSongUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistSongPayload>
          }
          aggregate: {
            args: Prisma.PlaylistSongAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylistSong>
          }
          groupBy: {
            args: Prisma.PlaylistSongGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistSongGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistSongCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistSongCountAggregateOutputType> | number
          }
        }
      }
      UserFollow: {
        payload: Prisma.$UserFollowPayload<ExtArgs>
        fields: Prisma.UserFollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          findFirst: {
            args: Prisma.UserFollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          findMany: {
            args: Prisma.UserFollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          create: {
            args: Prisma.UserFollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          createMany: {
            args: Prisma.UserFollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          delete: {
            args: Prisma.UserFollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          update: {
            args: Prisma.UserFollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          deleteMany: {
            args: Prisma.UserFollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>[]
          }
          upsert: {
            args: Prisma.UserFollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFollowPayload>
          }
          aggregate: {
            args: Prisma.UserFollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFollow>
          }
          groupBy: {
            args: Prisma.UserFollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFollowCountArgs<ExtArgs>
            result: $Utils.Optional<UserFollowCountAggregateOutputType> | number
          }
        }
      }
      UserLibrary: {
        payload: Prisma.$UserLibraryPayload<ExtArgs>
        fields: Prisma.UserLibraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLibraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLibraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload>
          }
          findFirst: {
            args: Prisma.UserLibraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLibraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload>
          }
          findMany: {
            args: Prisma.UserLibraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload>[]
          }
          create: {
            args: Prisma.UserLibraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload>
          }
          createMany: {
            args: Prisma.UserLibraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLibraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload>[]
          }
          delete: {
            args: Prisma.UserLibraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload>
          }
          update: {
            args: Prisma.UserLibraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload>
          }
          deleteMany: {
            args: Prisma.UserLibraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLibraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLibraryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload>[]
          }
          upsert: {
            args: Prisma.UserLibraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLibraryPayload>
          }
          aggregate: {
            args: Prisma.UserLibraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLibrary>
          }
          groupBy: {
            args: Prisma.UserLibraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLibraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLibraryCountArgs<ExtArgs>
            result: $Utils.Optional<UserLibraryCountAggregateOutputType> | number
          }
        }
      }
      ListeningHistory: {
        payload: Prisma.$ListeningHistoryPayload<ExtArgs>
        fields: Prisma.ListeningHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListeningHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListeningHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload>
          }
          findFirst: {
            args: Prisma.ListeningHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListeningHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload>
          }
          findMany: {
            args: Prisma.ListeningHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload>[]
          }
          create: {
            args: Prisma.ListeningHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload>
          }
          createMany: {
            args: Prisma.ListeningHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListeningHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload>[]
          }
          delete: {
            args: Prisma.ListeningHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload>
          }
          update: {
            args: Prisma.ListeningHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ListeningHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListeningHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListeningHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ListeningHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningHistoryPayload>
          }
          aggregate: {
            args: Prisma.ListeningHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListeningHistory>
          }
          groupBy: {
            args: Prisma.ListeningHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListeningHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListeningHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ListeningHistoryCountAggregateOutputType> | number
          }
        }
      }
      RecentlyPlayed: {
        payload: Prisma.$RecentlyPlayedPayload<ExtArgs>
        fields: Prisma.RecentlyPlayedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecentlyPlayedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecentlyPlayedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload>
          }
          findFirst: {
            args: Prisma.RecentlyPlayedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecentlyPlayedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload>
          }
          findMany: {
            args: Prisma.RecentlyPlayedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload>[]
          }
          create: {
            args: Prisma.RecentlyPlayedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload>
          }
          createMany: {
            args: Prisma.RecentlyPlayedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecentlyPlayedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload>[]
          }
          delete: {
            args: Prisma.RecentlyPlayedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload>
          }
          update: {
            args: Prisma.RecentlyPlayedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload>
          }
          deleteMany: {
            args: Prisma.RecentlyPlayedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecentlyPlayedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecentlyPlayedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload>[]
          }
          upsert: {
            args: Prisma.RecentlyPlayedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecentlyPlayedPayload>
          }
          aggregate: {
            args: Prisma.RecentlyPlayedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecentlyPlayed>
          }
          groupBy: {
            args: Prisma.RecentlyPlayedGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecentlyPlayedGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecentlyPlayedCountArgs<ExtArgs>
            result: $Utils.Optional<RecentlyPlayedCountAggregateOutputType> | number
          }
        }
      }
      PlaybackQueue: {
        payload: Prisma.$PlaybackQueuePayload<ExtArgs>
        fields: Prisma.PlaybackQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaybackQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaybackQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload>
          }
          findFirst: {
            args: Prisma.PlaybackQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaybackQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload>
          }
          findMany: {
            args: Prisma.PlaybackQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload>[]
          }
          create: {
            args: Prisma.PlaybackQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload>
          }
          createMany: {
            args: Prisma.PlaybackQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaybackQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload>[]
          }
          delete: {
            args: Prisma.PlaybackQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload>
          }
          update: {
            args: Prisma.PlaybackQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload>
          }
          deleteMany: {
            args: Prisma.PlaybackQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaybackQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaybackQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload>[]
          }
          upsert: {
            args: Prisma.PlaybackQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackQueuePayload>
          }
          aggregate: {
            args: Prisma.PlaybackQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaybackQueue>
          }
          groupBy: {
            args: Prisma.PlaybackQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaybackQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaybackQueueCountArgs<ExtArgs>
            result: $Utils.Optional<PlaybackQueueCountAggregateOutputType> | number
          }
        }
      }
      PlaybackState: {
        payload: Prisma.$PlaybackStatePayload<ExtArgs>
        fields: Prisma.PlaybackStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaybackStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaybackStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload>
          }
          findFirst: {
            args: Prisma.PlaybackStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaybackStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload>
          }
          findMany: {
            args: Prisma.PlaybackStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload>[]
          }
          create: {
            args: Prisma.PlaybackStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload>
          }
          createMany: {
            args: Prisma.PlaybackStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaybackStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload>[]
          }
          delete: {
            args: Prisma.PlaybackStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload>
          }
          update: {
            args: Prisma.PlaybackStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload>
          }
          deleteMany: {
            args: Prisma.PlaybackStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaybackStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaybackStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload>[]
          }
          upsert: {
            args: Prisma.PlaybackStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaybackStatePayload>
          }
          aggregate: {
            args: Prisma.PlaybackStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaybackState>
          }
          groupBy: {
            args: Prisma.PlaybackStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaybackStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaybackStateCountArgs<ExtArgs>
            result: $Utils.Optional<PlaybackStateCountAggregateOutputType> | number
          }
        }
      }
      UserOAuthAccount: {
        payload: Prisma.$UserOAuthAccountPayload<ExtArgs>
        fields: Prisma.UserOAuthAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOAuthAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOAuthAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload>
          }
          findFirst: {
            args: Prisma.UserOAuthAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOAuthAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload>
          }
          findMany: {
            args: Prisma.UserOAuthAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload>[]
          }
          create: {
            args: Prisma.UserOAuthAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload>
          }
          createMany: {
            args: Prisma.UserOAuthAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserOAuthAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload>[]
          }
          delete: {
            args: Prisma.UserOAuthAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload>
          }
          update: {
            args: Prisma.UserOAuthAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserOAuthAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserOAuthAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserOAuthAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload>[]
          }
          upsert: {
            args: Prisma.UserOAuthAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOAuthAccountPayload>
          }
          aggregate: {
            args: Prisma.UserOAuthAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserOAuthAccount>
          }
          groupBy: {
            args: Prisma.UserOAuthAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserOAuthAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOAuthAccountCountArgs<ExtArgs>
            result: $Utils.Optional<UserOAuthAccountCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      UserDevice: {
        payload: Prisma.$UserDevicePayload<ExtArgs>
        fields: Prisma.UserDeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload>
          }
          findFirst: {
            args: Prisma.UserDeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload>
          }
          findMany: {
            args: Prisma.UserDeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload>[]
          }
          create: {
            args: Prisma.UserDeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload>
          }
          createMany: {
            args: Prisma.UserDeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload>[]
          }
          delete: {
            args: Prisma.UserDeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload>
          }
          update: {
            args: Prisma.UserDeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload>
          }
          deleteMany: {
            args: Prisma.UserDeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserDeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload>[]
          }
          upsert: {
            args: Prisma.UserDeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDevicePayload>
          }
          aggregate: {
            args: Prisma.UserDeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDevice>
          }
          groupBy: {
            args: Prisma.UserDeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDeviceCountArgs<ExtArgs>
            result: $Utils.Optional<UserDeviceCountAggregateOutputType> | number
          }
        }
      }
      DeviceSyncState: {
        payload: Prisma.$DeviceSyncStatePayload<ExtArgs>
        fields: Prisma.DeviceSyncStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceSyncStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceSyncStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload>
          }
          findFirst: {
            args: Prisma.DeviceSyncStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceSyncStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload>
          }
          findMany: {
            args: Prisma.DeviceSyncStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload>[]
          }
          create: {
            args: Prisma.DeviceSyncStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload>
          }
          createMany: {
            args: Prisma.DeviceSyncStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceSyncStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload>[]
          }
          delete: {
            args: Prisma.DeviceSyncStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload>
          }
          update: {
            args: Prisma.DeviceSyncStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload>
          }
          deleteMany: {
            args: Prisma.DeviceSyncStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceSyncStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceSyncStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload>[]
          }
          upsert: {
            args: Prisma.DeviceSyncStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceSyncStatePayload>
          }
          aggregate: {
            args: Prisma.DeviceSyncStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceSyncState>
          }
          groupBy: {
            args: Prisma.DeviceSyncStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceSyncStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceSyncStateCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceSyncStateCountAggregateOutputType> | number
          }
        }
      }
      SyncLog: {
        payload: Prisma.$SyncLogPayload<ExtArgs>
        fields: Prisma.SyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findFirst: {
            args: Prisma.SyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findMany: {
            args: Prisma.SyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          create: {
            args: Prisma.SyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          createMany: {
            args: Prisma.SyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          delete: {
            args: Prisma.SyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          update: {
            args: Prisma.SyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          deleteMany: {
            args: Prisma.SyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          upsert: {
            args: Prisma.SyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          aggregate: {
            args: Prisma.SyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncLog>
          }
          groupBy: {
            args: Prisma.SyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<SyncLogCountAggregateOutputType> | number
          }
        }
      }
      DeviceTransfer: {
        payload: Prisma.$DeviceTransferPayload<ExtArgs>
        fields: Prisma.DeviceTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload>
          }
          findFirst: {
            args: Prisma.DeviceTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload>
          }
          findMany: {
            args: Prisma.DeviceTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload>[]
          }
          create: {
            args: Prisma.DeviceTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload>
          }
          createMany: {
            args: Prisma.DeviceTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload>[]
          }
          delete: {
            args: Prisma.DeviceTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload>
          }
          update: {
            args: Prisma.DeviceTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload>[]
          }
          upsert: {
            args: Prisma.DeviceTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTransferPayload>
          }
          aggregate: {
            args: Prisma.DeviceTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceTransfer>
          }
          groupBy: {
            args: Prisma.DeviceTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTransferCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTransferCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
        fields: Prisma.SubscriptionPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPlan>
          }
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPlanCountAggregateOutputType> | number
          }
        }
      }
      UserSubscription: {
        payload: Prisma.$UserSubscriptionPayload<ExtArgs>
        fields: Prisma.UserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          update: {
            args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubscription>
          }
          groupBy: {
            args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Advertisement: {
        payload: Prisma.$AdvertisementPayload<ExtArgs>
        fields: Prisma.AdvertisementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvertisementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvertisementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findFirst: {
            args: Prisma.AdvertisementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvertisementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findMany: {
            args: Prisma.AdvertisementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
          }
          create: {
            args: Prisma.AdvertisementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          createMany: {
            args: Prisma.AdvertisementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvertisementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
          }
          delete: {
            args: Prisma.AdvertisementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          update: {
            args: Prisma.AdvertisementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          deleteMany: {
            args: Prisma.AdvertisementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvertisementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdvertisementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
          }
          upsert: {
            args: Prisma.AdvertisementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          aggregate: {
            args: Prisma.AdvertisementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvertisement>
          }
          groupBy: {
            args: Prisma.AdvertisementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvertisementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvertisementCountArgs<ExtArgs>
            result: $Utils.Optional<AdvertisementCountAggregateOutputType> | number
          }
        }
      }
      AdImpression: {
        payload: Prisma.$AdImpressionPayload<ExtArgs>
        fields: Prisma.AdImpressionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdImpressionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdImpressionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload>
          }
          findFirst: {
            args: Prisma.AdImpressionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdImpressionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload>
          }
          findMany: {
            args: Prisma.AdImpressionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload>[]
          }
          create: {
            args: Prisma.AdImpressionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload>
          }
          createMany: {
            args: Prisma.AdImpressionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdImpressionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload>[]
          }
          delete: {
            args: Prisma.AdImpressionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload>
          }
          update: {
            args: Prisma.AdImpressionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload>
          }
          deleteMany: {
            args: Prisma.AdImpressionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdImpressionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdImpressionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload>[]
          }
          upsert: {
            args: Prisma.AdImpressionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdImpressionPayload>
          }
          aggregate: {
            args: Prisma.AdImpressionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdImpression>
          }
          groupBy: {
            args: Prisma.AdImpressionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdImpressionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdImpressionCountArgs<ExtArgs>
            result: $Utils.Optional<AdImpressionCountAggregateOutputType> | number
          }
        }
      }
      UserAdSettings: {
        payload: Prisma.$UserAdSettingsPayload<ExtArgs>
        fields: Prisma.UserAdSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAdSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAdSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserAdSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAdSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload>
          }
          findMany: {
            args: Prisma.UserAdSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload>[]
          }
          create: {
            args: Prisma.UserAdSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload>
          }
          createMany: {
            args: Prisma.UserAdSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAdSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserAdSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload>
          }
          update: {
            args: Prisma.UserAdSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserAdSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAdSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAdSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserAdSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserAdSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAdSettings>
          }
          groupBy: {
            args: Prisma.UserAdSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAdSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAdSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserAdSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    artist?: ArtistOmit
    album?: AlbumOmit
    song?: SongOmit
    genre?: GenreOmit
    songGenre?: SongGenreOmit
    artistGenre?: ArtistGenreOmit
    songArtist?: SongArtistOmit
    playlist?: PlaylistOmit
    playlistSong?: PlaylistSongOmit
    userFollow?: UserFollowOmit
    userLibrary?: UserLibraryOmit
    listeningHistory?: ListeningHistoryOmit
    recentlyPlayed?: RecentlyPlayedOmit
    playbackQueue?: PlaybackQueueOmit
    playbackState?: PlaybackStateOmit
    userOAuthAccount?: UserOAuthAccountOmit
    userSession?: UserSessionOmit
    userDevice?: UserDeviceOmit
    deviceSyncState?: DeviceSyncStateOmit
    syncLog?: SyncLogOmit
    deviceTransfer?: DeviceTransferOmit
    subscriptionPlan?: SubscriptionPlanOmit
    userSubscription?: UserSubscriptionOmit
    advertisement?: AdvertisementOmit
    adImpression?: AdImpressionOmit
    userAdSettings?: UserAdSettingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    oauthAccounts: number
    sessions: number
    devices: number
    playlists: number
    follows: number
    library: number
    listeningHistory: number
    recentlyPlayed: number
    playbackQueue: number
    subscriptions: number
    adImpressions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    oauthAccounts?: boolean | UserCountOutputTypeCountOauthAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    devices?: boolean | UserCountOutputTypeCountDevicesArgs
    playlists?: boolean | UserCountOutputTypeCountPlaylistsArgs
    follows?: boolean | UserCountOutputTypeCountFollowsArgs
    library?: boolean | UserCountOutputTypeCountLibraryArgs
    listeningHistory?: boolean | UserCountOutputTypeCountListeningHistoryArgs
    recentlyPlayed?: boolean | UserCountOutputTypeCountRecentlyPlayedArgs
    playbackQueue?: boolean | UserCountOutputTypeCountPlaybackQueueArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    adImpressions?: boolean | UserCountOutputTypeCountAdImpressionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOauthAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOAuthAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDeviceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLibraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLibraryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListeningHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListeningHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecentlyPlayedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecentlyPlayedWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlaybackQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaybackQueueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdImpressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdImpressionWhereInput
  }


  /**
   * Count Type ArtistCountOutputType
   */

  export type ArtistCountOutputType = {
    albums: number
    songs: number
    songArtists: number
    genres: number
  }

  export type ArtistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    albums?: boolean | ArtistCountOutputTypeCountAlbumsArgs
    songs?: boolean | ArtistCountOutputTypeCountSongsArgs
    songArtists?: boolean | ArtistCountOutputTypeCountSongArtistsArgs
    genres?: boolean | ArtistCountOutputTypeCountGenresArgs
  }

  // Custom InputTypes
  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistCountOutputType
     */
    select?: ArtistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumWhereInput
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongWhereInput
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountSongArtistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongArtistWhereInput
  }

  /**
   * ArtistCountOutputType without action
   */
  export type ArtistCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistGenreWhereInput
  }


  /**
   * Count Type AlbumCountOutputType
   */

  export type AlbumCountOutputType = {
    songs: number
  }

  export type AlbumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    songs?: boolean | AlbumCountOutputTypeCountSongsArgs
  }

  // Custom InputTypes
  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumCountOutputType
     */
    select?: AlbumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeCountSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongWhereInput
  }


  /**
   * Count Type SongCountOutputType
   */

  export type SongCountOutputType = {
    songArtists: number
    genres: number
    playlistSongs: number
    listeningHistory: number
    recentlyPlayed: number
    playbackStates: number
    playbackQueues: number
  }

  export type SongCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    songArtists?: boolean | SongCountOutputTypeCountSongArtistsArgs
    genres?: boolean | SongCountOutputTypeCountGenresArgs
    playlistSongs?: boolean | SongCountOutputTypeCountPlaylistSongsArgs
    listeningHistory?: boolean | SongCountOutputTypeCountListeningHistoryArgs
    recentlyPlayed?: boolean | SongCountOutputTypeCountRecentlyPlayedArgs
    playbackStates?: boolean | SongCountOutputTypeCountPlaybackStatesArgs
    playbackQueues?: boolean | SongCountOutputTypeCountPlaybackQueuesArgs
  }

  // Custom InputTypes
  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongCountOutputType
     */
    select?: SongCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountSongArtistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongArtistWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongGenreWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountPlaylistSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistSongWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountListeningHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListeningHistoryWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountRecentlyPlayedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecentlyPlayedWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountPlaybackStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaybackStateWhereInput
  }

  /**
   * SongCountOutputType without action
   */
  export type SongCountOutputTypeCountPlaybackQueuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaybackQueueWhereInput
  }


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    songs: number
    artists: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    songs?: boolean | GenreCountOutputTypeCountSongsArgs
    artists?: boolean | GenreCountOutputTypeCountArtistsArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongGenreWhereInput
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountArtistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistGenreWhereInput
  }


  /**
   * Count Type PlaylistCountOutputType
   */

  export type PlaylistCountOutputType = {
    songs: number
    followers: number
  }

  export type PlaylistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    songs?: boolean | PlaylistCountOutputTypeCountSongsArgs
    followers?: boolean | PlaylistCountOutputTypeCountFollowersArgs
  }

  // Custom InputTypes
  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistCountOutputType
     */
    select?: PlaylistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistSongWhereInput
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
  }


  /**
   * Count Type UserDeviceCountOutputType
   */

  export type UserDeviceCountOutputType = {
    sessions: number
    playbackStates: number
    syncStates: number
    syncLogs: number
    transfersFrom: number
    transfersTo: number
    adImpressions: number
  }

  export type UserDeviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserDeviceCountOutputTypeCountSessionsArgs
    playbackStates?: boolean | UserDeviceCountOutputTypeCountPlaybackStatesArgs
    syncStates?: boolean | UserDeviceCountOutputTypeCountSyncStatesArgs
    syncLogs?: boolean | UserDeviceCountOutputTypeCountSyncLogsArgs
    transfersFrom?: boolean | UserDeviceCountOutputTypeCountTransfersFromArgs
    transfersTo?: boolean | UserDeviceCountOutputTypeCountTransfersToArgs
    adImpressions?: boolean | UserDeviceCountOutputTypeCountAdImpressionsArgs
  }

  // Custom InputTypes
  /**
   * UserDeviceCountOutputType without action
   */
  export type UserDeviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDeviceCountOutputType
     */
    select?: UserDeviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserDeviceCountOutputType without action
   */
  export type UserDeviceCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserDeviceCountOutputType without action
   */
  export type UserDeviceCountOutputTypeCountPlaybackStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaybackStateWhereInput
  }

  /**
   * UserDeviceCountOutputType without action
   */
  export type UserDeviceCountOutputTypeCountSyncStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceSyncStateWhereInput
  }

  /**
   * UserDeviceCountOutputType without action
   */
  export type UserDeviceCountOutputTypeCountSyncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
  }

  /**
   * UserDeviceCountOutputType without action
   */
  export type UserDeviceCountOutputTypeCountTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTransferWhereInput
  }

  /**
   * UserDeviceCountOutputType without action
   */
  export type UserDeviceCountOutputTypeCountTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTransferWhereInput
  }

  /**
   * UserDeviceCountOutputType without action
   */
  export type UserDeviceCountOutputTypeCountAdImpressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdImpressionWhereInput
  }


  /**
   * Count Type SubscriptionPlanCountOutputType
   */

  export type SubscriptionPlanCountOutputType = {
    subscriptions: number
  }

  export type SubscriptionPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlanCountOutputType
     */
    select?: SubscriptionPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPlanCountOutputType without action
   */
  export type SubscriptionPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
  }


  /**
   * Count Type AdvertisementCountOutputType
   */

  export type AdvertisementCountOutputType = {
    impressions: number
  }

  export type AdvertisementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impressions?: boolean | AdvertisementCountOutputTypeCountImpressionsArgs
  }

  // Custom InputTypes
  /**
   * AdvertisementCountOutputType without action
   */
  export type AdvertisementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisementCountOutputType
     */
    select?: AdvertisementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdvertisementCountOutputType without action
   */
  export type AdvertisementCountOutputTypeCountImpressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdImpressionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    username: string | null
    displayName: string | null
    avatarUrl: string | null
    dateOfBirth: Date | null
    country: string | null
    subscriptionType: $Enums.SubscriptionType | null
    isArtist: boolean | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    username: string | null
    displayName: string | null
    avatarUrl: string | null
    dateOfBirth: Date | null
    country: string | null
    subscriptionType: $Enums.SubscriptionType | null
    isArtist: boolean | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    username: number
    displayName: number
    avatarUrl: number
    dateOfBirth: number
    country: number
    subscriptionType: number
    isArtist: number
    isActive: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    username?: true
    displayName?: true
    avatarUrl?: true
    dateOfBirth?: true
    country?: true
    subscriptionType?: true
    isArtist?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    username?: true
    displayName?: true
    avatarUrl?: true
    dateOfBirth?: true
    country?: true
    subscriptionType?: true
    isArtist?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    username?: true
    displayName?: true
    avatarUrl?: true
    dateOfBirth?: true
    country?: true
    subscriptionType?: true
    isArtist?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    username: string
    displayName: string | null
    avatarUrl: string | null
    dateOfBirth: Date | null
    country: string | null
    subscriptionType: $Enums.SubscriptionType
    isArtist: boolean
    isActive: boolean
    emailVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    country?: boolean
    subscriptionType?: boolean
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | User$artistArgs<ExtArgs>
    oauthAccounts?: boolean | User$oauthAccountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    playlists?: boolean | User$playlistsArgs<ExtArgs>
    follows?: boolean | User$followsArgs<ExtArgs>
    library?: boolean | User$libraryArgs<ExtArgs>
    listeningHistory?: boolean | User$listeningHistoryArgs<ExtArgs>
    recentlyPlayed?: boolean | User$recentlyPlayedArgs<ExtArgs>
    playbackState?: boolean | User$playbackStateArgs<ExtArgs>
    playbackQueue?: boolean | User$playbackQueueArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    adImpressions?: boolean | User$adImpressionsArgs<ExtArgs>
    adSettings?: boolean | User$adSettingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    country?: boolean
    subscriptionType?: boolean
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    country?: boolean
    subscriptionType?: boolean
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    country?: boolean
    subscriptionType?: boolean
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "username" | "displayName" | "avatarUrl" | "dateOfBirth" | "country" | "subscriptionType" | "isArtist" | "isActive" | "emailVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | User$artistArgs<ExtArgs>
    oauthAccounts?: boolean | User$oauthAccountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    playlists?: boolean | User$playlistsArgs<ExtArgs>
    follows?: boolean | User$followsArgs<ExtArgs>
    library?: boolean | User$libraryArgs<ExtArgs>
    listeningHistory?: boolean | User$listeningHistoryArgs<ExtArgs>
    recentlyPlayed?: boolean | User$recentlyPlayedArgs<ExtArgs>
    playbackState?: boolean | User$playbackStateArgs<ExtArgs>
    playbackQueue?: boolean | User$playbackQueueArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    adImpressions?: boolean | User$adImpressionsArgs<ExtArgs>
    adSettings?: boolean | User$adSettingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      artist: Prisma.$ArtistPayload<ExtArgs> | null
      oauthAccounts: Prisma.$UserOAuthAccountPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      devices: Prisma.$UserDevicePayload<ExtArgs>[]
      playlists: Prisma.$PlaylistPayload<ExtArgs>[]
      follows: Prisma.$UserFollowPayload<ExtArgs>[]
      library: Prisma.$UserLibraryPayload<ExtArgs>[]
      listeningHistory: Prisma.$ListeningHistoryPayload<ExtArgs>[]
      recentlyPlayed: Prisma.$RecentlyPlayedPayload<ExtArgs>[]
      playbackState: Prisma.$PlaybackStatePayload<ExtArgs> | null
      playbackQueue: Prisma.$PlaybackQueuePayload<ExtArgs>[]
      subscriptions: Prisma.$UserSubscriptionPayload<ExtArgs>[]
      adImpressions: Prisma.$AdImpressionPayload<ExtArgs>[]
      adSettings: Prisma.$UserAdSettingsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      username: string
      displayName: string | null
      avatarUrl: string | null
      dateOfBirth: Date | null
      country: string | null
      subscriptionType: $Enums.SubscriptionType
      isArtist: boolean
      isActive: boolean
      emailVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artist<T extends User$artistArgs<ExtArgs> = {}>(args?: Subset<T, User$artistArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    oauthAccounts<T extends User$oauthAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$oauthAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devices<T extends User$devicesArgs<ExtArgs> = {}>(args?: Subset<T, User$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playlists<T extends User$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, User$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    follows<T extends User$followsArgs<ExtArgs> = {}>(args?: Subset<T, User$followsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    library<T extends User$libraryArgs<ExtArgs> = {}>(args?: Subset<T, User$libraryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listeningHistory<T extends User$listeningHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$listeningHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recentlyPlayed<T extends User$recentlyPlayedArgs<ExtArgs> = {}>(args?: Subset<T, User$recentlyPlayedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playbackState<T extends User$playbackStateArgs<ExtArgs> = {}>(args?: Subset<T, User$playbackStateArgs<ExtArgs>>): Prisma__PlaybackStateClient<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    playbackQueue<T extends User$playbackQueueArgs<ExtArgs> = {}>(args?: Subset<T, User$playbackQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adImpressions<T extends User$adImpressionsArgs<ExtArgs> = {}>(args?: Subset<T, User$adImpressionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adSettings<T extends User$adSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$adSettingsArgs<ExtArgs>>): Prisma__UserAdSettingsClient<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly country: FieldRef<"User", 'String'>
    readonly subscriptionType: FieldRef<"User", 'SubscriptionType'>
    readonly isArtist: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.artist
   */
  export type User$artistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    where?: ArtistWhereInput
  }

  /**
   * User.oauthAccounts
   */
  export type User$oauthAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    where?: UserOAuthAccountWhereInput
    orderBy?: UserOAuthAccountOrderByWithRelationInput | UserOAuthAccountOrderByWithRelationInput[]
    cursor?: UserOAuthAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOAuthAccountScalarFieldEnum | UserOAuthAccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.devices
   */
  export type User$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    where?: UserDeviceWhereInput
    orderBy?: UserDeviceOrderByWithRelationInput | UserDeviceOrderByWithRelationInput[]
    cursor?: UserDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDeviceScalarFieldEnum | UserDeviceScalarFieldEnum[]
  }

  /**
   * User.playlists
   */
  export type User$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    cursor?: PlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * User.follows
   */
  export type User$followsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    cursor?: UserFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * User.library
   */
  export type User$libraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    where?: UserLibraryWhereInput
    orderBy?: UserLibraryOrderByWithRelationInput | UserLibraryOrderByWithRelationInput[]
    cursor?: UserLibraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLibraryScalarFieldEnum | UserLibraryScalarFieldEnum[]
  }

  /**
   * User.listeningHistory
   */
  export type User$listeningHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    where?: ListeningHistoryWhereInput
    orderBy?: ListeningHistoryOrderByWithRelationInput | ListeningHistoryOrderByWithRelationInput[]
    cursor?: ListeningHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListeningHistoryScalarFieldEnum | ListeningHistoryScalarFieldEnum[]
  }

  /**
   * User.recentlyPlayed
   */
  export type User$recentlyPlayedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    where?: RecentlyPlayedWhereInput
    orderBy?: RecentlyPlayedOrderByWithRelationInput | RecentlyPlayedOrderByWithRelationInput[]
    cursor?: RecentlyPlayedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecentlyPlayedScalarFieldEnum | RecentlyPlayedScalarFieldEnum[]
  }

  /**
   * User.playbackState
   */
  export type User$playbackStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    where?: PlaybackStateWhereInput
  }

  /**
   * User.playbackQueue
   */
  export type User$playbackQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    where?: PlaybackQueueWhereInput
    orderBy?: PlaybackQueueOrderByWithRelationInput | PlaybackQueueOrderByWithRelationInput[]
    cursor?: PlaybackQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaybackQueueScalarFieldEnum | PlaybackQueueScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    cursor?: UserSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * User.adImpressions
   */
  export type User$adImpressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    where?: AdImpressionWhereInput
    orderBy?: AdImpressionOrderByWithRelationInput | AdImpressionOrderByWithRelationInput[]
    cursor?: AdImpressionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdImpressionScalarFieldEnum | AdImpressionScalarFieldEnum[]
  }

  /**
   * User.adSettings
   */
  export type User$adSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    where?: UserAdSettingsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Artist
   */

  export type AggregateArtist = {
    _count: ArtistCountAggregateOutputType | null
    _avg: ArtistAvgAggregateOutputType | null
    _sum: ArtistSumAggregateOutputType | null
    _min: ArtistMinAggregateOutputType | null
    _max: ArtistMaxAggregateOutputType | null
  }

  export type ArtistAvgAggregateOutputType = {
    monthlyListeners: number | null
  }

  export type ArtistSumAggregateOutputType = {
    monthlyListeners: number | null
  }

  export type ArtistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    slug: string | null
    bio: string | null
    avatarUrl: string | null
    coverUrl: string | null
    verified: boolean | null
    monthlyListeners: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    slug: string | null
    bio: string | null
    avatarUrl: string | null
    coverUrl: string | null
    verified: boolean | null
    monthlyListeners: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArtistCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    slug: number
    bio: number
    avatarUrl: number
    coverUrl: number
    verified: number
    monthlyListeners: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArtistAvgAggregateInputType = {
    monthlyListeners?: true
  }

  export type ArtistSumAggregateInputType = {
    monthlyListeners?: true
  }

  export type ArtistMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    slug?: true
    bio?: true
    avatarUrl?: true
    coverUrl?: true
    verified?: true
    monthlyListeners?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtistMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    slug?: true
    bio?: true
    avatarUrl?: true
    coverUrl?: true
    verified?: true
    monthlyListeners?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArtistCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    slug?: true
    bio?: true
    avatarUrl?: true
    coverUrl?: true
    verified?: true
    monthlyListeners?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArtistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artist to aggregate.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Artists
    **/
    _count?: true | ArtistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtistMaxAggregateInputType
  }

  export type GetArtistAggregateType<T extends ArtistAggregateArgs> = {
        [P in keyof T & keyof AggregateArtist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtist[P]>
      : GetScalarType<T[P], AggregateArtist[P]>
  }




  export type ArtistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistWhereInput
    orderBy?: ArtistOrderByWithAggregationInput | ArtistOrderByWithAggregationInput[]
    by: ArtistScalarFieldEnum[] | ArtistScalarFieldEnum
    having?: ArtistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtistCountAggregateInputType | true
    _avg?: ArtistAvgAggregateInputType
    _sum?: ArtistSumAggregateInputType
    _min?: ArtistMinAggregateInputType
    _max?: ArtistMaxAggregateInputType
  }

  export type ArtistGroupByOutputType = {
    id: string
    userId: string | null
    name: string
    slug: string
    bio: string | null
    avatarUrl: string | null
    coverUrl: string | null
    verified: boolean
    monthlyListeners: number
    createdAt: Date
    updatedAt: Date
    _count: ArtistCountAggregateOutputType | null
    _avg: ArtistAvgAggregateOutputType | null
    _sum: ArtistSumAggregateOutputType | null
    _min: ArtistMinAggregateOutputType | null
    _max: ArtistMaxAggregateOutputType | null
  }

  type GetArtistGroupByPayload<T extends ArtistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtistGroupByOutputType[P]>
            : GetScalarType<T[P], ArtistGroupByOutputType[P]>
        }
      >
    >


  export type ArtistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    slug?: boolean
    bio?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    verified?: boolean
    monthlyListeners?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Artist$userArgs<ExtArgs>
    albums?: boolean | Artist$albumsArgs<ExtArgs>
    songs?: boolean | Artist$songsArgs<ExtArgs>
    songArtists?: boolean | Artist$songArtistsArgs<ExtArgs>
    genres?: boolean | Artist$genresArgs<ExtArgs>
    _count?: boolean | ArtistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artist"]>

  export type ArtistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    slug?: boolean
    bio?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    verified?: boolean
    monthlyListeners?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Artist$userArgs<ExtArgs>
  }, ExtArgs["result"]["artist"]>

  export type ArtistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    slug?: boolean
    bio?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    verified?: boolean
    monthlyListeners?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Artist$userArgs<ExtArgs>
  }, ExtArgs["result"]["artist"]>

  export type ArtistSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    slug?: boolean
    bio?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    verified?: boolean
    monthlyListeners?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArtistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "slug" | "bio" | "avatarUrl" | "coverUrl" | "verified" | "monthlyListeners" | "createdAt" | "updatedAt", ExtArgs["result"]["artist"]>
  export type ArtistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Artist$userArgs<ExtArgs>
    albums?: boolean | Artist$albumsArgs<ExtArgs>
    songs?: boolean | Artist$songsArgs<ExtArgs>
    songArtists?: boolean | Artist$songArtistsArgs<ExtArgs>
    genres?: boolean | Artist$genresArgs<ExtArgs>
    _count?: boolean | ArtistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArtistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Artist$userArgs<ExtArgs>
  }
  export type ArtistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Artist$userArgs<ExtArgs>
  }

  export type $ArtistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Artist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      albums: Prisma.$AlbumPayload<ExtArgs>[]
      songs: Prisma.$SongPayload<ExtArgs>[]
      songArtists: Prisma.$SongArtistPayload<ExtArgs>[]
      genres: Prisma.$ArtistGenrePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      name: string
      slug: string
      bio: string | null
      avatarUrl: string | null
      coverUrl: string | null
      verified: boolean
      monthlyListeners: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["artist"]>
    composites: {}
  }

  type ArtistGetPayload<S extends boolean | null | undefined | ArtistDefaultArgs> = $Result.GetResult<Prisma.$ArtistPayload, S>

  type ArtistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtistCountAggregateInputType | true
    }

  export interface ArtistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artist'], meta: { name: 'Artist' } }
    /**
     * Find zero or one Artist that matches the filter.
     * @param {ArtistFindUniqueArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtistFindUniqueArgs>(args: SelectSubset<T, ArtistFindUniqueArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtistFindUniqueOrThrowArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtistFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindFirstArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtistFindFirstArgs>(args?: SelectSubset<T, ArtistFindFirstArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindFirstOrThrowArgs} args - Arguments to find a Artist
     * @example
     * // Get one Artist
     * const artist = await prisma.artist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtistFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtistFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artists
     * const artists = await prisma.artist.findMany()
     * 
     * // Get first 10 Artists
     * const artists = await prisma.artist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artistWithIdOnly = await prisma.artist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtistFindManyArgs>(args?: SelectSubset<T, ArtistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artist.
     * @param {ArtistCreateArgs} args - Arguments to create a Artist.
     * @example
     * // Create one Artist
     * const Artist = await prisma.artist.create({
     *   data: {
     *     // ... data to create a Artist
     *   }
     * })
     * 
     */
    create<T extends ArtistCreateArgs>(args: SelectSubset<T, ArtistCreateArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artists.
     * @param {ArtistCreateManyArgs} args - Arguments to create many Artists.
     * @example
     * // Create many Artists
     * const artist = await prisma.artist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtistCreateManyArgs>(args?: SelectSubset<T, ArtistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artists and returns the data saved in the database.
     * @param {ArtistCreateManyAndReturnArgs} args - Arguments to create many Artists.
     * @example
     * // Create many Artists
     * const artist = await prisma.artist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artists and only return the `id`
     * const artistWithIdOnly = await prisma.artist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtistCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artist.
     * @param {ArtistDeleteArgs} args - Arguments to delete one Artist.
     * @example
     * // Delete one Artist
     * const Artist = await prisma.artist.delete({
     *   where: {
     *     // ... filter to delete one Artist
     *   }
     * })
     * 
     */
    delete<T extends ArtistDeleteArgs>(args: SelectSubset<T, ArtistDeleteArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artist.
     * @param {ArtistUpdateArgs} args - Arguments to update one Artist.
     * @example
     * // Update one Artist
     * const artist = await prisma.artist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtistUpdateArgs>(args: SelectSubset<T, ArtistUpdateArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artists.
     * @param {ArtistDeleteManyArgs} args - Arguments to filter Artists to delete.
     * @example
     * // Delete a few Artists
     * const { count } = await prisma.artist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtistDeleteManyArgs>(args?: SelectSubset<T, ArtistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artists
     * const artist = await prisma.artist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtistUpdateManyArgs>(args: SelectSubset<T, ArtistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artists and returns the data updated in the database.
     * @param {ArtistUpdateManyAndReturnArgs} args - Arguments to update many Artists.
     * @example
     * // Update many Artists
     * const artist = await prisma.artist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Artists and only return the `id`
     * const artistWithIdOnly = await prisma.artist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtistUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artist.
     * @param {ArtistUpsertArgs} args - Arguments to update or create a Artist.
     * @example
     * // Update or create a Artist
     * const artist = await prisma.artist.upsert({
     *   create: {
     *     // ... data to create a Artist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artist we want to update
     *   }
     * })
     */
    upsert<T extends ArtistUpsertArgs>(args: SelectSubset<T, ArtistUpsertArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Artists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistCountArgs} args - Arguments to filter Artists to count.
     * @example
     * // Count the number of Artists
     * const count = await prisma.artist.count({
     *   where: {
     *     // ... the filter for the Artists we want to count
     *   }
     * })
    **/
    count<T extends ArtistCountArgs>(
      args?: Subset<T, ArtistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtistAggregateArgs>(args: Subset<T, ArtistAggregateArgs>): Prisma.PrismaPromise<GetArtistAggregateType<T>>

    /**
     * Group by Artist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtistGroupByArgs['orderBy'] }
        : { orderBy?: ArtistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Artist model
   */
  readonly fields: ArtistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Artist$userArgs<ExtArgs> = {}>(args?: Subset<T, Artist$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    albums<T extends Artist$albumsArgs<ExtArgs> = {}>(args?: Subset<T, Artist$albumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    songs<T extends Artist$songsArgs<ExtArgs> = {}>(args?: Subset<T, Artist$songsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    songArtists<T extends Artist$songArtistsArgs<ExtArgs> = {}>(args?: Subset<T, Artist$songArtistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genres<T extends Artist$genresArgs<ExtArgs> = {}>(args?: Subset<T, Artist$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Artist model
   */
  interface ArtistFieldRefs {
    readonly id: FieldRef<"Artist", 'String'>
    readonly userId: FieldRef<"Artist", 'String'>
    readonly name: FieldRef<"Artist", 'String'>
    readonly slug: FieldRef<"Artist", 'String'>
    readonly bio: FieldRef<"Artist", 'String'>
    readonly avatarUrl: FieldRef<"Artist", 'String'>
    readonly coverUrl: FieldRef<"Artist", 'String'>
    readonly verified: FieldRef<"Artist", 'Boolean'>
    readonly monthlyListeners: FieldRef<"Artist", 'Int'>
    readonly createdAt: FieldRef<"Artist", 'DateTime'>
    readonly updatedAt: FieldRef<"Artist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Artist findUnique
   */
  export type ArtistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist findUniqueOrThrow
   */
  export type ArtistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist findFirst
   */
  export type ArtistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artists.
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artists.
     */
    distinct?: ArtistScalarFieldEnum | ArtistScalarFieldEnum[]
  }

  /**
   * Artist findFirstOrThrow
   */
  export type ArtistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artist to fetch.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artists.
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artists.
     */
    distinct?: ArtistScalarFieldEnum | ArtistScalarFieldEnum[]
  }

  /**
   * Artist findMany
   */
  export type ArtistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter, which Artists to fetch.
     */
    where?: ArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artists to fetch.
     */
    orderBy?: ArtistOrderByWithRelationInput | ArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Artists.
     */
    cursor?: ArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artists.
     */
    skip?: number
    distinct?: ArtistScalarFieldEnum | ArtistScalarFieldEnum[]
  }

  /**
   * Artist create
   */
  export type ArtistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * The data needed to create a Artist.
     */
    data: XOR<ArtistCreateInput, ArtistUncheckedCreateInput>
  }

  /**
   * Artist createMany
   */
  export type ArtistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artists.
     */
    data: ArtistCreateManyInput | ArtistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Artist createManyAndReturn
   */
  export type ArtistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * The data used to create many Artists.
     */
    data: ArtistCreateManyInput | ArtistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artist update
   */
  export type ArtistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * The data needed to update a Artist.
     */
    data: XOR<ArtistUpdateInput, ArtistUncheckedUpdateInput>
    /**
     * Choose, which Artist to update.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist updateMany
   */
  export type ArtistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Artists.
     */
    data: XOR<ArtistUpdateManyMutationInput, ArtistUncheckedUpdateManyInput>
    /**
     * Filter which Artists to update
     */
    where?: ArtistWhereInput
    /**
     * Limit how many Artists to update.
     */
    limit?: number
  }

  /**
   * Artist updateManyAndReturn
   */
  export type ArtistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * The data used to update Artists.
     */
    data: XOR<ArtistUpdateManyMutationInput, ArtistUncheckedUpdateManyInput>
    /**
     * Filter which Artists to update
     */
    where?: ArtistWhereInput
    /**
     * Limit how many Artists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artist upsert
   */
  export type ArtistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * The filter to search for the Artist to update in case it exists.
     */
    where: ArtistWhereUniqueInput
    /**
     * In case the Artist found by the `where` argument doesn't exist, create a new Artist with this data.
     */
    create: XOR<ArtistCreateInput, ArtistUncheckedCreateInput>
    /**
     * In case the Artist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtistUpdateInput, ArtistUncheckedUpdateInput>
  }

  /**
   * Artist delete
   */
  export type ArtistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
    /**
     * Filter which Artist to delete.
     */
    where: ArtistWhereUniqueInput
  }

  /**
   * Artist deleteMany
   */
  export type ArtistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artists to delete
     */
    where?: ArtistWhereInput
    /**
     * Limit how many Artists to delete.
     */
    limit?: number
  }

  /**
   * Artist.user
   */
  export type Artist$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Artist.albums
   */
  export type Artist$albumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    where?: AlbumWhereInput
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    cursor?: AlbumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Artist.songs
   */
  export type Artist$songsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    where?: SongWhereInput
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    cursor?: SongWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongScalarFieldEnum | SongScalarFieldEnum[]
  }

  /**
   * Artist.songArtists
   */
  export type Artist$songArtistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    where?: SongArtistWhereInput
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    cursor?: SongArtistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * Artist.genres
   */
  export type Artist$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    where?: ArtistGenreWhereInput
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    cursor?: ArtistGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * Artist without action
   */
  export type ArtistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artist
     */
    select?: ArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artist
     */
    omit?: ArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistInclude<ExtArgs> | null
  }


  /**
   * Model Album
   */

  export type AggregateAlbum = {
    _count: AlbumCountAggregateOutputType | null
    _avg: AlbumAvgAggregateOutputType | null
    _sum: AlbumSumAggregateOutputType | null
    _min: AlbumMinAggregateOutputType | null
    _max: AlbumMaxAggregateOutputType | null
  }

  export type AlbumAvgAggregateOutputType = {
    totalTracks: number | null
    durationMs: number | null
  }

  export type AlbumSumAggregateOutputType = {
    totalTracks: number | null
    durationMs: number | null
  }

  export type AlbumMinAggregateOutputType = {
    id: string | null
    artistId: string | null
    title: string | null
    slug: string | null
    description: string | null
    coverUrl: string | null
    releaseDate: Date | null
    albumType: $Enums.AlbumType | null
    totalTracks: number | null
    durationMs: number | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlbumMaxAggregateOutputType = {
    id: string | null
    artistId: string | null
    title: string | null
    slug: string | null
    description: string | null
    coverUrl: string | null
    releaseDate: Date | null
    albumType: $Enums.AlbumType | null
    totalTracks: number | null
    durationMs: number | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlbumCountAggregateOutputType = {
    id: number
    artistId: number
    title: number
    slug: number
    description: number
    coverUrl: number
    releaseDate: number
    albumType: number
    totalTracks: number
    durationMs: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlbumAvgAggregateInputType = {
    totalTracks?: true
    durationMs?: true
  }

  export type AlbumSumAggregateInputType = {
    totalTracks?: true
    durationMs?: true
  }

  export type AlbumMinAggregateInputType = {
    id?: true
    artistId?: true
    title?: true
    slug?: true
    description?: true
    coverUrl?: true
    releaseDate?: true
    albumType?: true
    totalTracks?: true
    durationMs?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlbumMaxAggregateInputType = {
    id?: true
    artistId?: true
    title?: true
    slug?: true
    description?: true
    coverUrl?: true
    releaseDate?: true
    albumType?: true
    totalTracks?: true
    durationMs?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlbumCountAggregateInputType = {
    id?: true
    artistId?: true
    title?: true
    slug?: true
    description?: true
    coverUrl?: true
    releaseDate?: true
    albumType?: true
    totalTracks?: true
    durationMs?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlbumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Album to aggregate.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Albums
    **/
    _count?: true | AlbumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlbumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlbumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlbumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlbumMaxAggregateInputType
  }

  export type GetAlbumAggregateType<T extends AlbumAggregateArgs> = {
        [P in keyof T & keyof AggregateAlbum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlbum[P]>
      : GetScalarType<T[P], AggregateAlbum[P]>
  }




  export type AlbumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumWhereInput
    orderBy?: AlbumOrderByWithAggregationInput | AlbumOrderByWithAggregationInput[]
    by: AlbumScalarFieldEnum[] | AlbumScalarFieldEnum
    having?: AlbumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlbumCountAggregateInputType | true
    _avg?: AlbumAvgAggregateInputType
    _sum?: AlbumSumAggregateInputType
    _min?: AlbumMinAggregateInputType
    _max?: AlbumMaxAggregateInputType
  }

  export type AlbumGroupByOutputType = {
    id: string
    artistId: string
    title: string
    slug: string
    description: string | null
    coverUrl: string | null
    releaseDate: Date | null
    albumType: $Enums.AlbumType
    totalTracks: number
    durationMs: number
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: AlbumCountAggregateOutputType | null
    _avg: AlbumAvgAggregateOutputType | null
    _sum: AlbumSumAggregateOutputType | null
    _min: AlbumMinAggregateOutputType | null
    _max: AlbumMaxAggregateOutputType | null
  }

  type GetAlbumGroupByPayload<T extends AlbumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlbumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlbumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlbumGroupByOutputType[P]>
            : GetScalarType<T[P], AlbumGroupByOutputType[P]>
        }
      >
    >


  export type AlbumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artistId?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    coverUrl?: boolean
    releaseDate?: boolean
    albumType?: boolean
    totalTracks?: boolean
    durationMs?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    songs?: boolean | Album$songsArgs<ExtArgs>
    _count?: boolean | AlbumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artistId?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    coverUrl?: boolean
    releaseDate?: boolean
    albumType?: boolean
    totalTracks?: boolean
    durationMs?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artistId?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    coverUrl?: boolean
    releaseDate?: boolean
    albumType?: boolean
    totalTracks?: boolean
    durationMs?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectScalar = {
    id?: boolean
    artistId?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    coverUrl?: boolean
    releaseDate?: boolean
    albumType?: boolean
    totalTracks?: boolean
    durationMs?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlbumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "artistId" | "title" | "slug" | "description" | "coverUrl" | "releaseDate" | "albumType" | "totalTracks" | "durationMs" | "isPublished" | "createdAt" | "updatedAt", ExtArgs["result"]["album"]>
  export type AlbumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    songs?: boolean | Album$songsArgs<ExtArgs>
    _count?: boolean | AlbumCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlbumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }
  export type AlbumIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }

  export type $AlbumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Album"
    objects: {
      artist: Prisma.$ArtistPayload<ExtArgs>
      songs: Prisma.$SongPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      artistId: string
      title: string
      slug: string
      description: string | null
      coverUrl: string | null
      releaseDate: Date | null
      albumType: $Enums.AlbumType
      totalTracks: number
      durationMs: number
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["album"]>
    composites: {}
  }

  type AlbumGetPayload<S extends boolean | null | undefined | AlbumDefaultArgs> = $Result.GetResult<Prisma.$AlbumPayload, S>

  type AlbumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlbumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlbumCountAggregateInputType | true
    }

  export interface AlbumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Album'], meta: { name: 'Album' } }
    /**
     * Find zero or one Album that matches the filter.
     * @param {AlbumFindUniqueArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlbumFindUniqueArgs>(args: SelectSubset<T, AlbumFindUniqueArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Album that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlbumFindUniqueOrThrowArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlbumFindUniqueOrThrowArgs>(args: SelectSubset<T, AlbumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Album that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindFirstArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlbumFindFirstArgs>(args?: SelectSubset<T, AlbumFindFirstArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Album that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindFirstOrThrowArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlbumFindFirstOrThrowArgs>(args?: SelectSubset<T, AlbumFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Albums
     * const albums = await prisma.album.findMany()
     * 
     * // Get first 10 Albums
     * const albums = await prisma.album.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const albumWithIdOnly = await prisma.album.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlbumFindManyArgs>(args?: SelectSubset<T, AlbumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Album.
     * @param {AlbumCreateArgs} args - Arguments to create a Album.
     * @example
     * // Create one Album
     * const Album = await prisma.album.create({
     *   data: {
     *     // ... data to create a Album
     *   }
     * })
     * 
     */
    create<T extends AlbumCreateArgs>(args: SelectSubset<T, AlbumCreateArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Albums.
     * @param {AlbumCreateManyArgs} args - Arguments to create many Albums.
     * @example
     * // Create many Albums
     * const album = await prisma.album.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlbumCreateManyArgs>(args?: SelectSubset<T, AlbumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Albums and returns the data saved in the database.
     * @param {AlbumCreateManyAndReturnArgs} args - Arguments to create many Albums.
     * @example
     * // Create many Albums
     * const album = await prisma.album.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Albums and only return the `id`
     * const albumWithIdOnly = await prisma.album.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlbumCreateManyAndReturnArgs>(args?: SelectSubset<T, AlbumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Album.
     * @param {AlbumDeleteArgs} args - Arguments to delete one Album.
     * @example
     * // Delete one Album
     * const Album = await prisma.album.delete({
     *   where: {
     *     // ... filter to delete one Album
     *   }
     * })
     * 
     */
    delete<T extends AlbumDeleteArgs>(args: SelectSubset<T, AlbumDeleteArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Album.
     * @param {AlbumUpdateArgs} args - Arguments to update one Album.
     * @example
     * // Update one Album
     * const album = await prisma.album.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlbumUpdateArgs>(args: SelectSubset<T, AlbumUpdateArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Albums.
     * @param {AlbumDeleteManyArgs} args - Arguments to filter Albums to delete.
     * @example
     * // Delete a few Albums
     * const { count } = await prisma.album.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlbumDeleteManyArgs>(args?: SelectSubset<T, AlbumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Albums
     * const album = await prisma.album.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlbumUpdateManyArgs>(args: SelectSubset<T, AlbumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Albums and returns the data updated in the database.
     * @param {AlbumUpdateManyAndReturnArgs} args - Arguments to update many Albums.
     * @example
     * // Update many Albums
     * const album = await prisma.album.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Albums and only return the `id`
     * const albumWithIdOnly = await prisma.album.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlbumUpdateManyAndReturnArgs>(args: SelectSubset<T, AlbumUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Album.
     * @param {AlbumUpsertArgs} args - Arguments to update or create a Album.
     * @example
     * // Update or create a Album
     * const album = await prisma.album.upsert({
     *   create: {
     *     // ... data to create a Album
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Album we want to update
     *   }
     * })
     */
    upsert<T extends AlbumUpsertArgs>(args: SelectSubset<T, AlbumUpsertArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumCountArgs} args - Arguments to filter Albums to count.
     * @example
     * // Count the number of Albums
     * const count = await prisma.album.count({
     *   where: {
     *     // ... the filter for the Albums we want to count
     *   }
     * })
    **/
    count<T extends AlbumCountArgs>(
      args?: Subset<T, AlbumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlbumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Album.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlbumAggregateArgs>(args: Subset<T, AlbumAggregateArgs>): Prisma.PrismaPromise<GetAlbumAggregateType<T>>

    /**
     * Group by Album.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlbumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlbumGroupByArgs['orderBy'] }
        : { orderBy?: AlbumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlbumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlbumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Album model
   */
  readonly fields: AlbumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Album.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlbumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artist<T extends ArtistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistDefaultArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    songs<T extends Album$songsArgs<ExtArgs> = {}>(args?: Subset<T, Album$songsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Album model
   */
  interface AlbumFieldRefs {
    readonly id: FieldRef<"Album", 'String'>
    readonly artistId: FieldRef<"Album", 'String'>
    readonly title: FieldRef<"Album", 'String'>
    readonly slug: FieldRef<"Album", 'String'>
    readonly description: FieldRef<"Album", 'String'>
    readonly coverUrl: FieldRef<"Album", 'String'>
    readonly releaseDate: FieldRef<"Album", 'DateTime'>
    readonly albumType: FieldRef<"Album", 'AlbumType'>
    readonly totalTracks: FieldRef<"Album", 'Int'>
    readonly durationMs: FieldRef<"Album", 'Int'>
    readonly isPublished: FieldRef<"Album", 'Boolean'>
    readonly createdAt: FieldRef<"Album", 'DateTime'>
    readonly updatedAt: FieldRef<"Album", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Album findUnique
   */
  export type AlbumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album findUniqueOrThrow
   */
  export type AlbumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album findFirst
   */
  export type AlbumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Albums.
     */
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Album findFirstOrThrow
   */
  export type AlbumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Albums.
     */
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Album findMany
   */
  export type AlbumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Albums to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }

  /**
   * Album create
   */
  export type AlbumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The data needed to create a Album.
     */
    data: XOR<AlbumCreateInput, AlbumUncheckedCreateInput>
  }

  /**
   * Album createMany
   */
  export type AlbumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Albums.
     */
    data: AlbumCreateManyInput | AlbumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Album createManyAndReturn
   */
  export type AlbumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * The data used to create many Albums.
     */
    data: AlbumCreateManyInput | AlbumCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Album update
   */
  export type AlbumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The data needed to update a Album.
     */
    data: XOR<AlbumUpdateInput, AlbumUncheckedUpdateInput>
    /**
     * Choose, which Album to update.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album updateMany
   */
  export type AlbumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Albums.
     */
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyInput>
    /**
     * Filter which Albums to update
     */
    where?: AlbumWhereInput
    /**
     * Limit how many Albums to update.
     */
    limit?: number
  }

  /**
   * Album updateManyAndReturn
   */
  export type AlbumUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * The data used to update Albums.
     */
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyInput>
    /**
     * Filter which Albums to update
     */
    where?: AlbumWhereInput
    /**
     * Limit how many Albums to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Album upsert
   */
  export type AlbumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The filter to search for the Album to update in case it exists.
     */
    where: AlbumWhereUniqueInput
    /**
     * In case the Album found by the `where` argument doesn't exist, create a new Album with this data.
     */
    create: XOR<AlbumCreateInput, AlbumUncheckedCreateInput>
    /**
     * In case the Album was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlbumUpdateInput, AlbumUncheckedUpdateInput>
  }

  /**
   * Album delete
   */
  export type AlbumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter which Album to delete.
     */
    where: AlbumWhereUniqueInput
  }

  /**
   * Album deleteMany
   */
  export type AlbumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Albums to delete
     */
    where?: AlbumWhereInput
    /**
     * Limit how many Albums to delete.
     */
    limit?: number
  }

  /**
   * Album.songs
   */
  export type Album$songsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    where?: SongWhereInput
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    cursor?: SongWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongScalarFieldEnum | SongScalarFieldEnum[]
  }

  /**
   * Album without action
   */
  export type AlbumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
  }


  /**
   * Model Song
   */

  export type AggregateSong = {
    _count: SongCountAggregateOutputType | null
    _avg: SongAvgAggregateOutputType | null
    _sum: SongSumAggregateOutputType | null
    _min: SongMinAggregateOutputType | null
    _max: SongMaxAggregateOutputType | null
  }

  export type SongAvgAggregateOutputType = {
    trackNumber: number | null
    discNumber: number | null
    durationMs: number | null
    playCount: number | null
  }

  export type SongSumAggregateOutputType = {
    trackNumber: number | null
    discNumber: number | null
    durationMs: number | null
    playCount: bigint | null
  }

  export type SongMinAggregateOutputType = {
    id: string | null
    albumId: string | null
    artistId: string | null
    title: string | null
    slug: string | null
    trackNumber: number | null
    discNumber: number | null
    durationMs: number | null
    audioUrl: string | null
    previewUrl: string | null
    lyricsUrl: string | null
    isExplicit: boolean | null
    isPlayable: boolean | null
    playCount: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SongMaxAggregateOutputType = {
    id: string | null
    albumId: string | null
    artistId: string | null
    title: string | null
    slug: string | null
    trackNumber: number | null
    discNumber: number | null
    durationMs: number | null
    audioUrl: string | null
    previewUrl: string | null
    lyricsUrl: string | null
    isExplicit: boolean | null
    isPlayable: boolean | null
    playCount: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SongCountAggregateOutputType = {
    id: number
    albumId: number
    artistId: number
    title: number
    slug: number
    trackNumber: number
    discNumber: number
    durationMs: number
    audioUrl: number
    previewUrl: number
    lyricsUrl: number
    isExplicit: number
    isPlayable: number
    playCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SongAvgAggregateInputType = {
    trackNumber?: true
    discNumber?: true
    durationMs?: true
    playCount?: true
  }

  export type SongSumAggregateInputType = {
    trackNumber?: true
    discNumber?: true
    durationMs?: true
    playCount?: true
  }

  export type SongMinAggregateInputType = {
    id?: true
    albumId?: true
    artistId?: true
    title?: true
    slug?: true
    trackNumber?: true
    discNumber?: true
    durationMs?: true
    audioUrl?: true
    previewUrl?: true
    lyricsUrl?: true
    isExplicit?: true
    isPlayable?: true
    playCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SongMaxAggregateInputType = {
    id?: true
    albumId?: true
    artistId?: true
    title?: true
    slug?: true
    trackNumber?: true
    discNumber?: true
    durationMs?: true
    audioUrl?: true
    previewUrl?: true
    lyricsUrl?: true
    isExplicit?: true
    isPlayable?: true
    playCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SongCountAggregateInputType = {
    id?: true
    albumId?: true
    artistId?: true
    title?: true
    slug?: true
    trackNumber?: true
    discNumber?: true
    durationMs?: true
    audioUrl?: true
    previewUrl?: true
    lyricsUrl?: true
    isExplicit?: true
    isPlayable?: true
    playCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SongAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Song to aggregate.
     */
    where?: SongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Songs to fetch.
     */
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Songs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Songs
    **/
    _count?: true | SongCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SongAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SongSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongMaxAggregateInputType
  }

  export type GetSongAggregateType<T extends SongAggregateArgs> = {
        [P in keyof T & keyof AggregateSong]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSong[P]>
      : GetScalarType<T[P], AggregateSong[P]>
  }




  export type SongGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongWhereInput
    orderBy?: SongOrderByWithAggregationInput | SongOrderByWithAggregationInput[]
    by: SongScalarFieldEnum[] | SongScalarFieldEnum
    having?: SongScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongCountAggregateInputType | true
    _avg?: SongAvgAggregateInputType
    _sum?: SongSumAggregateInputType
    _min?: SongMinAggregateInputType
    _max?: SongMaxAggregateInputType
  }

  export type SongGroupByOutputType = {
    id: string
    albumId: string | null
    artistId: string
    title: string
    slug: string
    trackNumber: number | null
    discNumber: number
    durationMs: number
    audioUrl: string
    previewUrl: string | null
    lyricsUrl: string | null
    isExplicit: boolean
    isPlayable: boolean
    playCount: bigint
    createdAt: Date
    updatedAt: Date
    _count: SongCountAggregateOutputType | null
    _avg: SongAvgAggregateOutputType | null
    _sum: SongSumAggregateOutputType | null
    _min: SongMinAggregateOutputType | null
    _max: SongMaxAggregateOutputType | null
  }

  type GetSongGroupByPayload<T extends SongGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SongGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongGroupByOutputType[P]>
            : GetScalarType<T[P], SongGroupByOutputType[P]>
        }
      >
    >


  export type SongSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    albumId?: boolean
    artistId?: boolean
    title?: boolean
    slug?: boolean
    trackNumber?: boolean
    discNumber?: boolean
    durationMs?: boolean
    audioUrl?: boolean
    previewUrl?: boolean
    lyricsUrl?: boolean
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    album?: boolean | Song$albumArgs<ExtArgs>
    primaryArtist?: boolean | ArtistDefaultArgs<ExtArgs>
    songArtists?: boolean | Song$songArtistsArgs<ExtArgs>
    genres?: boolean | Song$genresArgs<ExtArgs>
    playlistSongs?: boolean | Song$playlistSongsArgs<ExtArgs>
    listeningHistory?: boolean | Song$listeningHistoryArgs<ExtArgs>
    recentlyPlayed?: boolean | Song$recentlyPlayedArgs<ExtArgs>
    playbackStates?: boolean | Song$playbackStatesArgs<ExtArgs>
    playbackQueues?: boolean | Song$playbackQueuesArgs<ExtArgs>
    _count?: boolean | SongCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["song"]>

  export type SongSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    albumId?: boolean
    artistId?: boolean
    title?: boolean
    slug?: boolean
    trackNumber?: boolean
    discNumber?: boolean
    durationMs?: boolean
    audioUrl?: boolean
    previewUrl?: boolean
    lyricsUrl?: boolean
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    album?: boolean | Song$albumArgs<ExtArgs>
    primaryArtist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["song"]>

  export type SongSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    albumId?: boolean
    artistId?: boolean
    title?: boolean
    slug?: boolean
    trackNumber?: boolean
    discNumber?: boolean
    durationMs?: boolean
    audioUrl?: boolean
    previewUrl?: boolean
    lyricsUrl?: boolean
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    album?: boolean | Song$albumArgs<ExtArgs>
    primaryArtist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["song"]>

  export type SongSelectScalar = {
    id?: boolean
    albumId?: boolean
    artistId?: boolean
    title?: boolean
    slug?: boolean
    trackNumber?: boolean
    discNumber?: boolean
    durationMs?: boolean
    audioUrl?: boolean
    previewUrl?: boolean
    lyricsUrl?: boolean
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SongOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "albumId" | "artistId" | "title" | "slug" | "trackNumber" | "discNumber" | "durationMs" | "audioUrl" | "previewUrl" | "lyricsUrl" | "isExplicit" | "isPlayable" | "playCount" | "createdAt" | "updatedAt", ExtArgs["result"]["song"]>
  export type SongInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | Song$albumArgs<ExtArgs>
    primaryArtist?: boolean | ArtistDefaultArgs<ExtArgs>
    songArtists?: boolean | Song$songArtistsArgs<ExtArgs>
    genres?: boolean | Song$genresArgs<ExtArgs>
    playlistSongs?: boolean | Song$playlistSongsArgs<ExtArgs>
    listeningHistory?: boolean | Song$listeningHistoryArgs<ExtArgs>
    recentlyPlayed?: boolean | Song$recentlyPlayedArgs<ExtArgs>
    playbackStates?: boolean | Song$playbackStatesArgs<ExtArgs>
    playbackQueues?: boolean | Song$playbackQueuesArgs<ExtArgs>
    _count?: boolean | SongCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SongIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | Song$albumArgs<ExtArgs>
    primaryArtist?: boolean | ArtistDefaultArgs<ExtArgs>
  }
  export type SongIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | Song$albumArgs<ExtArgs>
    primaryArtist?: boolean | ArtistDefaultArgs<ExtArgs>
  }

  export type $SongPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Song"
    objects: {
      album: Prisma.$AlbumPayload<ExtArgs> | null
      primaryArtist: Prisma.$ArtistPayload<ExtArgs>
      songArtists: Prisma.$SongArtistPayload<ExtArgs>[]
      genres: Prisma.$SongGenrePayload<ExtArgs>[]
      playlistSongs: Prisma.$PlaylistSongPayload<ExtArgs>[]
      listeningHistory: Prisma.$ListeningHistoryPayload<ExtArgs>[]
      recentlyPlayed: Prisma.$RecentlyPlayedPayload<ExtArgs>[]
      playbackStates: Prisma.$PlaybackStatePayload<ExtArgs>[]
      playbackQueues: Prisma.$PlaybackQueuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      albumId: string | null
      artistId: string
      title: string
      slug: string
      trackNumber: number | null
      discNumber: number
      durationMs: number
      audioUrl: string
      previewUrl: string | null
      lyricsUrl: string | null
      isExplicit: boolean
      isPlayable: boolean
      playCount: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["song"]>
    composites: {}
  }

  type SongGetPayload<S extends boolean | null | undefined | SongDefaultArgs> = $Result.GetResult<Prisma.$SongPayload, S>

  type SongCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SongFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SongCountAggregateInputType | true
    }

  export interface SongDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Song'], meta: { name: 'Song' } }
    /**
     * Find zero or one Song that matches the filter.
     * @param {SongFindUniqueArgs} args - Arguments to find a Song
     * @example
     * // Get one Song
     * const song = await prisma.song.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SongFindUniqueArgs>(args: SelectSubset<T, SongFindUniqueArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Song that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SongFindUniqueOrThrowArgs} args - Arguments to find a Song
     * @example
     * // Get one Song
     * const song = await prisma.song.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SongFindUniqueOrThrowArgs>(args: SelectSubset<T, SongFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Song that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongFindFirstArgs} args - Arguments to find a Song
     * @example
     * // Get one Song
     * const song = await prisma.song.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SongFindFirstArgs>(args?: SelectSubset<T, SongFindFirstArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Song that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongFindFirstOrThrowArgs} args - Arguments to find a Song
     * @example
     * // Get one Song
     * const song = await prisma.song.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SongFindFirstOrThrowArgs>(args?: SelectSubset<T, SongFindFirstOrThrowArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Songs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Songs
     * const songs = await prisma.song.findMany()
     * 
     * // Get first 10 Songs
     * const songs = await prisma.song.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const songWithIdOnly = await prisma.song.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SongFindManyArgs>(args?: SelectSubset<T, SongFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Song.
     * @param {SongCreateArgs} args - Arguments to create a Song.
     * @example
     * // Create one Song
     * const Song = await prisma.song.create({
     *   data: {
     *     // ... data to create a Song
     *   }
     * })
     * 
     */
    create<T extends SongCreateArgs>(args: SelectSubset<T, SongCreateArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Songs.
     * @param {SongCreateManyArgs} args - Arguments to create many Songs.
     * @example
     * // Create many Songs
     * const song = await prisma.song.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SongCreateManyArgs>(args?: SelectSubset<T, SongCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Songs and returns the data saved in the database.
     * @param {SongCreateManyAndReturnArgs} args - Arguments to create many Songs.
     * @example
     * // Create many Songs
     * const song = await prisma.song.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Songs and only return the `id`
     * const songWithIdOnly = await prisma.song.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SongCreateManyAndReturnArgs>(args?: SelectSubset<T, SongCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Song.
     * @param {SongDeleteArgs} args - Arguments to delete one Song.
     * @example
     * // Delete one Song
     * const Song = await prisma.song.delete({
     *   where: {
     *     // ... filter to delete one Song
     *   }
     * })
     * 
     */
    delete<T extends SongDeleteArgs>(args: SelectSubset<T, SongDeleteArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Song.
     * @param {SongUpdateArgs} args - Arguments to update one Song.
     * @example
     * // Update one Song
     * const song = await prisma.song.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SongUpdateArgs>(args: SelectSubset<T, SongUpdateArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Songs.
     * @param {SongDeleteManyArgs} args - Arguments to filter Songs to delete.
     * @example
     * // Delete a few Songs
     * const { count } = await prisma.song.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SongDeleteManyArgs>(args?: SelectSubset<T, SongDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Songs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Songs
     * const song = await prisma.song.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SongUpdateManyArgs>(args: SelectSubset<T, SongUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Songs and returns the data updated in the database.
     * @param {SongUpdateManyAndReturnArgs} args - Arguments to update many Songs.
     * @example
     * // Update many Songs
     * const song = await prisma.song.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Songs and only return the `id`
     * const songWithIdOnly = await prisma.song.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SongUpdateManyAndReturnArgs>(args: SelectSubset<T, SongUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Song.
     * @param {SongUpsertArgs} args - Arguments to update or create a Song.
     * @example
     * // Update or create a Song
     * const song = await prisma.song.upsert({
     *   create: {
     *     // ... data to create a Song
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Song we want to update
     *   }
     * })
     */
    upsert<T extends SongUpsertArgs>(args: SelectSubset<T, SongUpsertArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Songs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongCountArgs} args - Arguments to filter Songs to count.
     * @example
     * // Count the number of Songs
     * const count = await prisma.song.count({
     *   where: {
     *     // ... the filter for the Songs we want to count
     *   }
     * })
    **/
    count<T extends SongCountArgs>(
      args?: Subset<T, SongCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Song.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongAggregateArgs>(args: Subset<T, SongAggregateArgs>): Prisma.PrismaPromise<GetSongAggregateType<T>>

    /**
     * Group by Song.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongGroupByArgs['orderBy'] }
        : { orderBy?: SongGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Song model
   */
  readonly fields: SongFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Song.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SongClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    album<T extends Song$albumArgs<ExtArgs> = {}>(args?: Subset<T, Song$albumArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    primaryArtist<T extends ArtistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistDefaultArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    songArtists<T extends Song$songArtistsArgs<ExtArgs> = {}>(args?: Subset<T, Song$songArtistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genres<T extends Song$genresArgs<ExtArgs> = {}>(args?: Subset<T, Song$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playlistSongs<T extends Song$playlistSongsArgs<ExtArgs> = {}>(args?: Subset<T, Song$playlistSongsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listeningHistory<T extends Song$listeningHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Song$listeningHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recentlyPlayed<T extends Song$recentlyPlayedArgs<ExtArgs> = {}>(args?: Subset<T, Song$recentlyPlayedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playbackStates<T extends Song$playbackStatesArgs<ExtArgs> = {}>(args?: Subset<T, Song$playbackStatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playbackQueues<T extends Song$playbackQueuesArgs<ExtArgs> = {}>(args?: Subset<T, Song$playbackQueuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Song model
   */
  interface SongFieldRefs {
    readonly id: FieldRef<"Song", 'String'>
    readonly albumId: FieldRef<"Song", 'String'>
    readonly artistId: FieldRef<"Song", 'String'>
    readonly title: FieldRef<"Song", 'String'>
    readonly slug: FieldRef<"Song", 'String'>
    readonly trackNumber: FieldRef<"Song", 'Int'>
    readonly discNumber: FieldRef<"Song", 'Int'>
    readonly durationMs: FieldRef<"Song", 'Int'>
    readonly audioUrl: FieldRef<"Song", 'String'>
    readonly previewUrl: FieldRef<"Song", 'String'>
    readonly lyricsUrl: FieldRef<"Song", 'String'>
    readonly isExplicit: FieldRef<"Song", 'Boolean'>
    readonly isPlayable: FieldRef<"Song", 'Boolean'>
    readonly playCount: FieldRef<"Song", 'BigInt'>
    readonly createdAt: FieldRef<"Song", 'DateTime'>
    readonly updatedAt: FieldRef<"Song", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Song findUnique
   */
  export type SongFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Song to fetch.
     */
    where: SongWhereUniqueInput
  }

  /**
   * Song findUniqueOrThrow
   */
  export type SongFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Song to fetch.
     */
    where: SongWhereUniqueInput
  }

  /**
   * Song findFirst
   */
  export type SongFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Song to fetch.
     */
    where?: SongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Songs to fetch.
     */
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Songs.
     */
    cursor?: SongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Songs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Songs.
     */
    distinct?: SongScalarFieldEnum | SongScalarFieldEnum[]
  }

  /**
   * Song findFirstOrThrow
   */
  export type SongFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Song to fetch.
     */
    where?: SongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Songs to fetch.
     */
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Songs.
     */
    cursor?: SongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Songs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Songs.
     */
    distinct?: SongScalarFieldEnum | SongScalarFieldEnum[]
  }

  /**
   * Song findMany
   */
  export type SongFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter, which Songs to fetch.
     */
    where?: SongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Songs to fetch.
     */
    orderBy?: SongOrderByWithRelationInput | SongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Songs.
     */
    cursor?: SongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Songs.
     */
    skip?: number
    distinct?: SongScalarFieldEnum | SongScalarFieldEnum[]
  }

  /**
   * Song create
   */
  export type SongCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * The data needed to create a Song.
     */
    data: XOR<SongCreateInput, SongUncheckedCreateInput>
  }

  /**
   * Song createMany
   */
  export type SongCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Songs.
     */
    data: SongCreateManyInput | SongCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Song createManyAndReturn
   */
  export type SongCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * The data used to create many Songs.
     */
    data: SongCreateManyInput | SongCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Song update
   */
  export type SongUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * The data needed to update a Song.
     */
    data: XOR<SongUpdateInput, SongUncheckedUpdateInput>
    /**
     * Choose, which Song to update.
     */
    where: SongWhereUniqueInput
  }

  /**
   * Song updateMany
   */
  export type SongUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Songs.
     */
    data: XOR<SongUpdateManyMutationInput, SongUncheckedUpdateManyInput>
    /**
     * Filter which Songs to update
     */
    where?: SongWhereInput
    /**
     * Limit how many Songs to update.
     */
    limit?: number
  }

  /**
   * Song updateManyAndReturn
   */
  export type SongUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * The data used to update Songs.
     */
    data: XOR<SongUpdateManyMutationInput, SongUncheckedUpdateManyInput>
    /**
     * Filter which Songs to update
     */
    where?: SongWhereInput
    /**
     * Limit how many Songs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Song upsert
   */
  export type SongUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * The filter to search for the Song to update in case it exists.
     */
    where: SongWhereUniqueInput
    /**
     * In case the Song found by the `where` argument doesn't exist, create a new Song with this data.
     */
    create: XOR<SongCreateInput, SongUncheckedCreateInput>
    /**
     * In case the Song was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SongUpdateInput, SongUncheckedUpdateInput>
  }

  /**
   * Song delete
   */
  export type SongDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    /**
     * Filter which Song to delete.
     */
    where: SongWhereUniqueInput
  }

  /**
   * Song deleteMany
   */
  export type SongDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Songs to delete
     */
    where?: SongWhereInput
    /**
     * Limit how many Songs to delete.
     */
    limit?: number
  }

  /**
   * Song.album
   */
  export type Song$albumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Album
     */
    omit?: AlbumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlbumInclude<ExtArgs> | null
    where?: AlbumWhereInput
  }

  /**
   * Song.songArtists
   */
  export type Song$songArtistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    where?: SongArtistWhereInput
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    cursor?: SongArtistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * Song.genres
   */
  export type Song$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    where?: SongGenreWhereInput
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    cursor?: SongGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * Song.playlistSongs
   */
  export type Song$playlistSongsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    where?: PlaylistSongWhereInput
    orderBy?: PlaylistSongOrderByWithRelationInput | PlaylistSongOrderByWithRelationInput[]
    cursor?: PlaylistSongWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistSongScalarFieldEnum | PlaylistSongScalarFieldEnum[]
  }

  /**
   * Song.listeningHistory
   */
  export type Song$listeningHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    where?: ListeningHistoryWhereInput
    orderBy?: ListeningHistoryOrderByWithRelationInput | ListeningHistoryOrderByWithRelationInput[]
    cursor?: ListeningHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListeningHistoryScalarFieldEnum | ListeningHistoryScalarFieldEnum[]
  }

  /**
   * Song.recentlyPlayed
   */
  export type Song$recentlyPlayedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    where?: RecentlyPlayedWhereInput
    orderBy?: RecentlyPlayedOrderByWithRelationInput | RecentlyPlayedOrderByWithRelationInput[]
    cursor?: RecentlyPlayedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecentlyPlayedScalarFieldEnum | RecentlyPlayedScalarFieldEnum[]
  }

  /**
   * Song.playbackStates
   */
  export type Song$playbackStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    where?: PlaybackStateWhereInput
    orderBy?: PlaybackStateOrderByWithRelationInput | PlaybackStateOrderByWithRelationInput[]
    cursor?: PlaybackStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaybackStateScalarFieldEnum | PlaybackStateScalarFieldEnum[]
  }

  /**
   * Song.playbackQueues
   */
  export type Song$playbackQueuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    where?: PlaybackQueueWhereInput
    orderBy?: PlaybackQueueOrderByWithRelationInput | PlaybackQueueOrderByWithRelationInput[]
    cursor?: PlaybackQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaybackQueueScalarFieldEnum | PlaybackQueueScalarFieldEnum[]
  }

  /**
   * Song without action
   */
  export type SongDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
  }


  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    imageUrl: string | null
    color: string | null
    createdAt: Date | null
  }

  export type GenreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    imageUrl: string | null
    color: string | null
    createdAt: Date | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    imageUrl: number
    color: number
    createdAt: number
    _all: number
  }


  export type GenreMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    imageUrl?: true
    color?: true
    createdAt?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    imageUrl?: true
    color?: true
    createdAt?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    imageUrl?: true
    color?: true
    createdAt?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type GenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithAggregationInput | GenreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: GenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    imageUrl: string | null
    color: string | null
    createdAt: Date
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type GenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    color?: boolean
    createdAt?: boolean
    songs?: boolean | Genre$songsArgs<ExtArgs>
    artists?: boolean | Genre$artistsArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    color?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    color?: boolean
    createdAt?: boolean
  }

  export type GenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "imageUrl" | "color" | "createdAt", ExtArgs["result"]["genre"]>
  export type GenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    songs?: boolean | Genre$songsArgs<ExtArgs>
    artists?: boolean | Genre$artistsArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genre"
    objects: {
      songs: Prisma.$SongGenrePayload<ExtArgs>[]
      artists: Prisma.$ArtistGenrePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      imageUrl: string | null
      color: string | null
      createdAt: Date
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type GenreGetPayload<S extends boolean | null | undefined | GenreDefaultArgs> = $Result.GetResult<Prisma.$GenrePayload, S>

  type GenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface GenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genre'], meta: { name: 'Genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenreFindManyArgs>(args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends GenreCreateArgs>(args: SelectSubset<T, GenreCreateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreCreateManyArgs>(args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends GenreDeleteArgs>(args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreUpdateArgs>(args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreDeleteManyArgs>(args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreUpdateManyArgs>(args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs['orderBy'] }
        : { orderBy?: GenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genre model
   */
  readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    songs<T extends Genre$songsArgs<ExtArgs> = {}>(args?: Subset<T, Genre$songsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artists<T extends Genre$artistsArgs<ExtArgs> = {}>(args?: Subset<T, Genre$artistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genre model
   */
  interface GenreFieldRefs {
    readonly id: FieldRef<"Genre", 'String'>
    readonly name: FieldRef<"Genre", 'String'>
    readonly slug: FieldRef<"Genre", 'String'>
    readonly description: FieldRef<"Genre", 'String'>
    readonly imageUrl: FieldRef<"Genre", 'String'>
    readonly color: FieldRef<"Genre", 'String'>
    readonly createdAt: FieldRef<"Genre", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre create
   */
  export type GenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre update
   */
  export type GenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre updateManyAndReturn
   */
  export type GenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genre.songs
   */
  export type Genre$songsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    where?: SongGenreWhereInput
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    cursor?: SongGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * Genre.artists
   */
  export type Genre$artistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    where?: ArtistGenreWhereInput
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    cursor?: ArtistGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
  }


  /**
   * Model SongGenre
   */

  export type AggregateSongGenre = {
    _count: SongGenreCountAggregateOutputType | null
    _min: SongGenreMinAggregateOutputType | null
    _max: SongGenreMaxAggregateOutputType | null
  }

  export type SongGenreMinAggregateOutputType = {
    songId: string | null
    genreId: string | null
  }

  export type SongGenreMaxAggregateOutputType = {
    songId: string | null
    genreId: string | null
  }

  export type SongGenreCountAggregateOutputType = {
    songId: number
    genreId: number
    _all: number
  }


  export type SongGenreMinAggregateInputType = {
    songId?: true
    genreId?: true
  }

  export type SongGenreMaxAggregateInputType = {
    songId?: true
    genreId?: true
  }

  export type SongGenreCountAggregateInputType = {
    songId?: true
    genreId?: true
    _all?: true
  }

  export type SongGenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongGenre to aggregate.
     */
    where?: SongGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongGenres to fetch.
     */
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SongGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SongGenres
    **/
    _count?: true | SongGenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongGenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongGenreMaxAggregateInputType
  }

  export type GetSongGenreAggregateType<T extends SongGenreAggregateArgs> = {
        [P in keyof T & keyof AggregateSongGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSongGenre[P]>
      : GetScalarType<T[P], AggregateSongGenre[P]>
  }




  export type SongGenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongGenreWhereInput
    orderBy?: SongGenreOrderByWithAggregationInput | SongGenreOrderByWithAggregationInput[]
    by: SongGenreScalarFieldEnum[] | SongGenreScalarFieldEnum
    having?: SongGenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongGenreCountAggregateInputType | true
    _min?: SongGenreMinAggregateInputType
    _max?: SongGenreMaxAggregateInputType
  }

  export type SongGenreGroupByOutputType = {
    songId: string
    genreId: string
    _count: SongGenreCountAggregateOutputType | null
    _min: SongGenreMinAggregateOutputType | null
    _max: SongGenreMaxAggregateOutputType | null
  }

  type GetSongGenreGroupByPayload<T extends SongGenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SongGenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongGenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongGenreGroupByOutputType[P]>
            : GetScalarType<T[P], SongGenreGroupByOutputType[P]>
        }
      >
    >


  export type SongGenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    songId?: boolean
    genreId?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songGenre"]>

  export type SongGenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    songId?: boolean
    genreId?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songGenre"]>

  export type SongGenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    songId?: boolean
    genreId?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songGenre"]>

  export type SongGenreSelectScalar = {
    songId?: boolean
    genreId?: boolean
  }

  export type SongGenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"songId" | "genreId", ExtArgs["result"]["songGenre"]>
  export type SongGenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type SongGenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type SongGenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $SongGenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SongGenre"
    objects: {
      song: Prisma.$SongPayload<ExtArgs>
      genre: Prisma.$GenrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      songId: string
      genreId: string
    }, ExtArgs["result"]["songGenre"]>
    composites: {}
  }

  type SongGenreGetPayload<S extends boolean | null | undefined | SongGenreDefaultArgs> = $Result.GetResult<Prisma.$SongGenrePayload, S>

  type SongGenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SongGenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SongGenreCountAggregateInputType | true
    }

  export interface SongGenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SongGenre'], meta: { name: 'SongGenre' } }
    /**
     * Find zero or one SongGenre that matches the filter.
     * @param {SongGenreFindUniqueArgs} args - Arguments to find a SongGenre
     * @example
     * // Get one SongGenre
     * const songGenre = await prisma.songGenre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SongGenreFindUniqueArgs>(args: SelectSubset<T, SongGenreFindUniqueArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SongGenre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SongGenreFindUniqueOrThrowArgs} args - Arguments to find a SongGenre
     * @example
     * // Get one SongGenre
     * const songGenre = await prisma.songGenre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SongGenreFindUniqueOrThrowArgs>(args: SelectSubset<T, SongGenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongGenre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreFindFirstArgs} args - Arguments to find a SongGenre
     * @example
     * // Get one SongGenre
     * const songGenre = await prisma.songGenre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SongGenreFindFirstArgs>(args?: SelectSubset<T, SongGenreFindFirstArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongGenre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreFindFirstOrThrowArgs} args - Arguments to find a SongGenre
     * @example
     * // Get one SongGenre
     * const songGenre = await prisma.songGenre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SongGenreFindFirstOrThrowArgs>(args?: SelectSubset<T, SongGenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SongGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SongGenres
     * const songGenres = await prisma.songGenre.findMany()
     * 
     * // Get first 10 SongGenres
     * const songGenres = await prisma.songGenre.findMany({ take: 10 })
     * 
     * // Only select the `songId`
     * const songGenreWithSongIdOnly = await prisma.songGenre.findMany({ select: { songId: true } })
     * 
     */
    findMany<T extends SongGenreFindManyArgs>(args?: SelectSubset<T, SongGenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SongGenre.
     * @param {SongGenreCreateArgs} args - Arguments to create a SongGenre.
     * @example
     * // Create one SongGenre
     * const SongGenre = await prisma.songGenre.create({
     *   data: {
     *     // ... data to create a SongGenre
     *   }
     * })
     * 
     */
    create<T extends SongGenreCreateArgs>(args: SelectSubset<T, SongGenreCreateArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SongGenres.
     * @param {SongGenreCreateManyArgs} args - Arguments to create many SongGenres.
     * @example
     * // Create many SongGenres
     * const songGenre = await prisma.songGenre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SongGenreCreateManyArgs>(args?: SelectSubset<T, SongGenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SongGenres and returns the data saved in the database.
     * @param {SongGenreCreateManyAndReturnArgs} args - Arguments to create many SongGenres.
     * @example
     * // Create many SongGenres
     * const songGenre = await prisma.songGenre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SongGenres and only return the `songId`
     * const songGenreWithSongIdOnly = await prisma.songGenre.createManyAndReturn({
     *   select: { songId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SongGenreCreateManyAndReturnArgs>(args?: SelectSubset<T, SongGenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SongGenre.
     * @param {SongGenreDeleteArgs} args - Arguments to delete one SongGenre.
     * @example
     * // Delete one SongGenre
     * const SongGenre = await prisma.songGenre.delete({
     *   where: {
     *     // ... filter to delete one SongGenre
     *   }
     * })
     * 
     */
    delete<T extends SongGenreDeleteArgs>(args: SelectSubset<T, SongGenreDeleteArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SongGenre.
     * @param {SongGenreUpdateArgs} args - Arguments to update one SongGenre.
     * @example
     * // Update one SongGenre
     * const songGenre = await prisma.songGenre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SongGenreUpdateArgs>(args: SelectSubset<T, SongGenreUpdateArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SongGenres.
     * @param {SongGenreDeleteManyArgs} args - Arguments to filter SongGenres to delete.
     * @example
     * // Delete a few SongGenres
     * const { count } = await prisma.songGenre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SongGenreDeleteManyArgs>(args?: SelectSubset<T, SongGenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SongGenres
     * const songGenre = await prisma.songGenre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SongGenreUpdateManyArgs>(args: SelectSubset<T, SongGenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongGenres and returns the data updated in the database.
     * @param {SongGenreUpdateManyAndReturnArgs} args - Arguments to update many SongGenres.
     * @example
     * // Update many SongGenres
     * const songGenre = await prisma.songGenre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SongGenres and only return the `songId`
     * const songGenreWithSongIdOnly = await prisma.songGenre.updateManyAndReturn({
     *   select: { songId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SongGenreUpdateManyAndReturnArgs>(args: SelectSubset<T, SongGenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SongGenre.
     * @param {SongGenreUpsertArgs} args - Arguments to update or create a SongGenre.
     * @example
     * // Update or create a SongGenre
     * const songGenre = await prisma.songGenre.upsert({
     *   create: {
     *     // ... data to create a SongGenre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SongGenre we want to update
     *   }
     * })
     */
    upsert<T extends SongGenreUpsertArgs>(args: SelectSubset<T, SongGenreUpsertArgs<ExtArgs>>): Prisma__SongGenreClient<$Result.GetResult<Prisma.$SongGenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SongGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreCountArgs} args - Arguments to filter SongGenres to count.
     * @example
     * // Count the number of SongGenres
     * const count = await prisma.songGenre.count({
     *   where: {
     *     // ... the filter for the SongGenres we want to count
     *   }
     * })
    **/
    count<T extends SongGenreCountArgs>(
      args?: Subset<T, SongGenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongGenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SongGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongGenreAggregateArgs>(args: Subset<T, SongGenreAggregateArgs>): Prisma.PrismaPromise<GetSongGenreAggregateType<T>>

    /**
     * Group by SongGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongGenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongGenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongGenreGroupByArgs['orderBy'] }
        : { orderBy?: SongGenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongGenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SongGenre model
   */
  readonly fields: SongGenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SongGenre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SongGenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SongGenre model
   */
  interface SongGenreFieldRefs {
    readonly songId: FieldRef<"SongGenre", 'String'>
    readonly genreId: FieldRef<"SongGenre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SongGenre findUnique
   */
  export type SongGenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenre to fetch.
     */
    where: SongGenreWhereUniqueInput
  }

  /**
   * SongGenre findUniqueOrThrow
   */
  export type SongGenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenre to fetch.
     */
    where: SongGenreWhereUniqueInput
  }

  /**
   * SongGenre findFirst
   */
  export type SongGenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenre to fetch.
     */
    where?: SongGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongGenres to fetch.
     */
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongGenres.
     */
    cursor?: SongGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongGenres.
     */
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * SongGenre findFirstOrThrow
   */
  export type SongGenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenre to fetch.
     */
    where?: SongGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongGenres to fetch.
     */
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongGenres.
     */
    cursor?: SongGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongGenres.
     */
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * SongGenre findMany
   */
  export type SongGenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter, which SongGenres to fetch.
     */
    where?: SongGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongGenres to fetch.
     */
    orderBy?: SongGenreOrderByWithRelationInput | SongGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SongGenres.
     */
    cursor?: SongGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongGenres.
     */
    skip?: number
    distinct?: SongGenreScalarFieldEnum | SongGenreScalarFieldEnum[]
  }

  /**
   * SongGenre create
   */
  export type SongGenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * The data needed to create a SongGenre.
     */
    data: XOR<SongGenreCreateInput, SongGenreUncheckedCreateInput>
  }

  /**
   * SongGenre createMany
   */
  export type SongGenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SongGenres.
     */
    data: SongGenreCreateManyInput | SongGenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SongGenre createManyAndReturn
   */
  export type SongGenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * The data used to create many SongGenres.
     */
    data: SongGenreCreateManyInput | SongGenreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongGenre update
   */
  export type SongGenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * The data needed to update a SongGenre.
     */
    data: XOR<SongGenreUpdateInput, SongGenreUncheckedUpdateInput>
    /**
     * Choose, which SongGenre to update.
     */
    where: SongGenreWhereUniqueInput
  }

  /**
   * SongGenre updateMany
   */
  export type SongGenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SongGenres.
     */
    data: XOR<SongGenreUpdateManyMutationInput, SongGenreUncheckedUpdateManyInput>
    /**
     * Filter which SongGenres to update
     */
    where?: SongGenreWhereInput
    /**
     * Limit how many SongGenres to update.
     */
    limit?: number
  }

  /**
   * SongGenre updateManyAndReturn
   */
  export type SongGenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * The data used to update SongGenres.
     */
    data: XOR<SongGenreUpdateManyMutationInput, SongGenreUncheckedUpdateManyInput>
    /**
     * Filter which SongGenres to update
     */
    where?: SongGenreWhereInput
    /**
     * Limit how many SongGenres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongGenre upsert
   */
  export type SongGenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * The filter to search for the SongGenre to update in case it exists.
     */
    where: SongGenreWhereUniqueInput
    /**
     * In case the SongGenre found by the `where` argument doesn't exist, create a new SongGenre with this data.
     */
    create: XOR<SongGenreCreateInput, SongGenreUncheckedCreateInput>
    /**
     * In case the SongGenre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SongGenreUpdateInput, SongGenreUncheckedUpdateInput>
  }

  /**
   * SongGenre delete
   */
  export type SongGenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
    /**
     * Filter which SongGenre to delete.
     */
    where: SongGenreWhereUniqueInput
  }

  /**
   * SongGenre deleteMany
   */
  export type SongGenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongGenres to delete
     */
    where?: SongGenreWhereInput
    /**
     * Limit how many SongGenres to delete.
     */
    limit?: number
  }

  /**
   * SongGenre without action
   */
  export type SongGenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongGenre
     */
    select?: SongGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongGenre
     */
    omit?: SongGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongGenreInclude<ExtArgs> | null
  }


  /**
   * Model ArtistGenre
   */

  export type AggregateArtistGenre = {
    _count: ArtistGenreCountAggregateOutputType | null
    _min: ArtistGenreMinAggregateOutputType | null
    _max: ArtistGenreMaxAggregateOutputType | null
  }

  export type ArtistGenreMinAggregateOutputType = {
    artistId: string | null
    genreId: string | null
  }

  export type ArtistGenreMaxAggregateOutputType = {
    artistId: string | null
    genreId: string | null
  }

  export type ArtistGenreCountAggregateOutputType = {
    artistId: number
    genreId: number
    _all: number
  }


  export type ArtistGenreMinAggregateInputType = {
    artistId?: true
    genreId?: true
  }

  export type ArtistGenreMaxAggregateInputType = {
    artistId?: true
    genreId?: true
  }

  export type ArtistGenreCountAggregateInputType = {
    artistId?: true
    genreId?: true
    _all?: true
  }

  export type ArtistGenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtistGenre to aggregate.
     */
    where?: ArtistGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistGenres to fetch.
     */
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtistGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArtistGenres
    **/
    _count?: true | ArtistGenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtistGenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtistGenreMaxAggregateInputType
  }

  export type GetArtistGenreAggregateType<T extends ArtistGenreAggregateArgs> = {
        [P in keyof T & keyof AggregateArtistGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtistGenre[P]>
      : GetScalarType<T[P], AggregateArtistGenre[P]>
  }




  export type ArtistGenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtistGenreWhereInput
    orderBy?: ArtistGenreOrderByWithAggregationInput | ArtistGenreOrderByWithAggregationInput[]
    by: ArtistGenreScalarFieldEnum[] | ArtistGenreScalarFieldEnum
    having?: ArtistGenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtistGenreCountAggregateInputType | true
    _min?: ArtistGenreMinAggregateInputType
    _max?: ArtistGenreMaxAggregateInputType
  }

  export type ArtistGenreGroupByOutputType = {
    artistId: string
    genreId: string
    _count: ArtistGenreCountAggregateOutputType | null
    _min: ArtistGenreMinAggregateOutputType | null
    _max: ArtistGenreMaxAggregateOutputType | null
  }

  type GetArtistGenreGroupByPayload<T extends ArtistGenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtistGenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtistGenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtistGenreGroupByOutputType[P]>
            : GetScalarType<T[P], ArtistGenreGroupByOutputType[P]>
        }
      >
    >


  export type ArtistGenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artistId?: boolean
    genreId?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistGenre"]>

  export type ArtistGenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artistId?: boolean
    genreId?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistGenre"]>

  export type ArtistGenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artistId?: boolean
    genreId?: boolean
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artistGenre"]>

  export type ArtistGenreSelectScalar = {
    artistId?: boolean
    genreId?: boolean
  }

  export type ArtistGenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"artistId" | "genreId", ExtArgs["result"]["artistGenre"]>
  export type ArtistGenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type ArtistGenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type ArtistGenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $ArtistGenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArtistGenre"
    objects: {
      artist: Prisma.$ArtistPayload<ExtArgs>
      genre: Prisma.$GenrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      artistId: string
      genreId: string
    }, ExtArgs["result"]["artistGenre"]>
    composites: {}
  }

  type ArtistGenreGetPayload<S extends boolean | null | undefined | ArtistGenreDefaultArgs> = $Result.GetResult<Prisma.$ArtistGenrePayload, S>

  type ArtistGenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtistGenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtistGenreCountAggregateInputType | true
    }

  export interface ArtistGenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArtistGenre'], meta: { name: 'ArtistGenre' } }
    /**
     * Find zero or one ArtistGenre that matches the filter.
     * @param {ArtistGenreFindUniqueArgs} args - Arguments to find a ArtistGenre
     * @example
     * // Get one ArtistGenre
     * const artistGenre = await prisma.artistGenre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtistGenreFindUniqueArgs>(args: SelectSubset<T, ArtistGenreFindUniqueArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArtistGenre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtistGenreFindUniqueOrThrowArgs} args - Arguments to find a ArtistGenre
     * @example
     * // Get one ArtistGenre
     * const artistGenre = await prisma.artistGenre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtistGenreFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtistGenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtistGenre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreFindFirstArgs} args - Arguments to find a ArtistGenre
     * @example
     * // Get one ArtistGenre
     * const artistGenre = await prisma.artistGenre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtistGenreFindFirstArgs>(args?: SelectSubset<T, ArtistGenreFindFirstArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtistGenre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreFindFirstOrThrowArgs} args - Arguments to find a ArtistGenre
     * @example
     * // Get one ArtistGenre
     * const artistGenre = await prisma.artistGenre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtistGenreFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtistGenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArtistGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArtistGenres
     * const artistGenres = await prisma.artistGenre.findMany()
     * 
     * // Get first 10 ArtistGenres
     * const artistGenres = await prisma.artistGenre.findMany({ take: 10 })
     * 
     * // Only select the `artistId`
     * const artistGenreWithArtistIdOnly = await prisma.artistGenre.findMany({ select: { artistId: true } })
     * 
     */
    findMany<T extends ArtistGenreFindManyArgs>(args?: SelectSubset<T, ArtistGenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArtistGenre.
     * @param {ArtistGenreCreateArgs} args - Arguments to create a ArtistGenre.
     * @example
     * // Create one ArtistGenre
     * const ArtistGenre = await prisma.artistGenre.create({
     *   data: {
     *     // ... data to create a ArtistGenre
     *   }
     * })
     * 
     */
    create<T extends ArtistGenreCreateArgs>(args: SelectSubset<T, ArtistGenreCreateArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArtistGenres.
     * @param {ArtistGenreCreateManyArgs} args - Arguments to create many ArtistGenres.
     * @example
     * // Create many ArtistGenres
     * const artistGenre = await prisma.artistGenre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtistGenreCreateManyArgs>(args?: SelectSubset<T, ArtistGenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArtistGenres and returns the data saved in the database.
     * @param {ArtistGenreCreateManyAndReturnArgs} args - Arguments to create many ArtistGenres.
     * @example
     * // Create many ArtistGenres
     * const artistGenre = await prisma.artistGenre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArtistGenres and only return the `artistId`
     * const artistGenreWithArtistIdOnly = await prisma.artistGenre.createManyAndReturn({
     *   select: { artistId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtistGenreCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtistGenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArtistGenre.
     * @param {ArtistGenreDeleteArgs} args - Arguments to delete one ArtistGenre.
     * @example
     * // Delete one ArtistGenre
     * const ArtistGenre = await prisma.artistGenre.delete({
     *   where: {
     *     // ... filter to delete one ArtistGenre
     *   }
     * })
     * 
     */
    delete<T extends ArtistGenreDeleteArgs>(args: SelectSubset<T, ArtistGenreDeleteArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArtistGenre.
     * @param {ArtistGenreUpdateArgs} args - Arguments to update one ArtistGenre.
     * @example
     * // Update one ArtistGenre
     * const artistGenre = await prisma.artistGenre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtistGenreUpdateArgs>(args: SelectSubset<T, ArtistGenreUpdateArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArtistGenres.
     * @param {ArtistGenreDeleteManyArgs} args - Arguments to filter ArtistGenres to delete.
     * @example
     * // Delete a few ArtistGenres
     * const { count } = await prisma.artistGenre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtistGenreDeleteManyArgs>(args?: SelectSubset<T, ArtistGenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtistGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArtistGenres
     * const artistGenre = await prisma.artistGenre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtistGenreUpdateManyArgs>(args: SelectSubset<T, ArtistGenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtistGenres and returns the data updated in the database.
     * @param {ArtistGenreUpdateManyAndReturnArgs} args - Arguments to update many ArtistGenres.
     * @example
     * // Update many ArtistGenres
     * const artistGenre = await prisma.artistGenre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArtistGenres and only return the `artistId`
     * const artistGenreWithArtistIdOnly = await prisma.artistGenre.updateManyAndReturn({
     *   select: { artistId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtistGenreUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtistGenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArtistGenre.
     * @param {ArtistGenreUpsertArgs} args - Arguments to update or create a ArtistGenre.
     * @example
     * // Update or create a ArtistGenre
     * const artistGenre = await prisma.artistGenre.upsert({
     *   create: {
     *     // ... data to create a ArtistGenre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArtistGenre we want to update
     *   }
     * })
     */
    upsert<T extends ArtistGenreUpsertArgs>(args: SelectSubset<T, ArtistGenreUpsertArgs<ExtArgs>>): Prisma__ArtistGenreClient<$Result.GetResult<Prisma.$ArtistGenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArtistGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreCountArgs} args - Arguments to filter ArtistGenres to count.
     * @example
     * // Count the number of ArtistGenres
     * const count = await prisma.artistGenre.count({
     *   where: {
     *     // ... the filter for the ArtistGenres we want to count
     *   }
     * })
    **/
    count<T extends ArtistGenreCountArgs>(
      args?: Subset<T, ArtistGenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtistGenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArtistGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtistGenreAggregateArgs>(args: Subset<T, ArtistGenreAggregateArgs>): Prisma.PrismaPromise<GetArtistGenreAggregateType<T>>

    /**
     * Group by ArtistGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtistGenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtistGenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtistGenreGroupByArgs['orderBy'] }
        : { orderBy?: ArtistGenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtistGenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtistGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArtistGenre model
   */
  readonly fields: ArtistGenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArtistGenre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtistGenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artist<T extends ArtistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistDefaultArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArtistGenre model
   */
  interface ArtistGenreFieldRefs {
    readonly artistId: FieldRef<"ArtistGenre", 'String'>
    readonly genreId: FieldRef<"ArtistGenre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ArtistGenre findUnique
   */
  export type ArtistGenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenre to fetch.
     */
    where: ArtistGenreWhereUniqueInput
  }

  /**
   * ArtistGenre findUniqueOrThrow
   */
  export type ArtistGenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenre to fetch.
     */
    where: ArtistGenreWhereUniqueInput
  }

  /**
   * ArtistGenre findFirst
   */
  export type ArtistGenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenre to fetch.
     */
    where?: ArtistGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistGenres to fetch.
     */
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtistGenres.
     */
    cursor?: ArtistGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtistGenres.
     */
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * ArtistGenre findFirstOrThrow
   */
  export type ArtistGenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenre to fetch.
     */
    where?: ArtistGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistGenres to fetch.
     */
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtistGenres.
     */
    cursor?: ArtistGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtistGenres.
     */
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * ArtistGenre findMany
   */
  export type ArtistGenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter, which ArtistGenres to fetch.
     */
    where?: ArtistGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtistGenres to fetch.
     */
    orderBy?: ArtistGenreOrderByWithRelationInput | ArtistGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArtistGenres.
     */
    cursor?: ArtistGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtistGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtistGenres.
     */
    skip?: number
    distinct?: ArtistGenreScalarFieldEnum | ArtistGenreScalarFieldEnum[]
  }

  /**
   * ArtistGenre create
   */
  export type ArtistGenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * The data needed to create a ArtistGenre.
     */
    data: XOR<ArtistGenreCreateInput, ArtistGenreUncheckedCreateInput>
  }

  /**
   * ArtistGenre createMany
   */
  export type ArtistGenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArtistGenres.
     */
    data: ArtistGenreCreateManyInput | ArtistGenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtistGenre createManyAndReturn
   */
  export type ArtistGenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * The data used to create many ArtistGenres.
     */
    data: ArtistGenreCreateManyInput | ArtistGenreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtistGenre update
   */
  export type ArtistGenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * The data needed to update a ArtistGenre.
     */
    data: XOR<ArtistGenreUpdateInput, ArtistGenreUncheckedUpdateInput>
    /**
     * Choose, which ArtistGenre to update.
     */
    where: ArtistGenreWhereUniqueInput
  }

  /**
   * ArtistGenre updateMany
   */
  export type ArtistGenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArtistGenres.
     */
    data: XOR<ArtistGenreUpdateManyMutationInput, ArtistGenreUncheckedUpdateManyInput>
    /**
     * Filter which ArtistGenres to update
     */
    where?: ArtistGenreWhereInput
    /**
     * Limit how many ArtistGenres to update.
     */
    limit?: number
  }

  /**
   * ArtistGenre updateManyAndReturn
   */
  export type ArtistGenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * The data used to update ArtistGenres.
     */
    data: XOR<ArtistGenreUpdateManyMutationInput, ArtistGenreUncheckedUpdateManyInput>
    /**
     * Filter which ArtistGenres to update
     */
    where?: ArtistGenreWhereInput
    /**
     * Limit how many ArtistGenres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtistGenre upsert
   */
  export type ArtistGenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * The filter to search for the ArtistGenre to update in case it exists.
     */
    where: ArtistGenreWhereUniqueInput
    /**
     * In case the ArtistGenre found by the `where` argument doesn't exist, create a new ArtistGenre with this data.
     */
    create: XOR<ArtistGenreCreateInput, ArtistGenreUncheckedCreateInput>
    /**
     * In case the ArtistGenre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtistGenreUpdateInput, ArtistGenreUncheckedUpdateInput>
  }

  /**
   * ArtistGenre delete
   */
  export type ArtistGenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
    /**
     * Filter which ArtistGenre to delete.
     */
    where: ArtistGenreWhereUniqueInput
  }

  /**
   * ArtistGenre deleteMany
   */
  export type ArtistGenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtistGenres to delete
     */
    where?: ArtistGenreWhereInput
    /**
     * Limit how many ArtistGenres to delete.
     */
    limit?: number
  }

  /**
   * ArtistGenre without action
   */
  export type ArtistGenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtistGenre
     */
    select?: ArtistGenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtistGenre
     */
    omit?: ArtistGenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtistGenreInclude<ExtArgs> | null
  }


  /**
   * Model SongArtist
   */

  export type AggregateSongArtist = {
    _count: SongArtistCountAggregateOutputType | null
    _min: SongArtistMinAggregateOutputType | null
    _max: SongArtistMaxAggregateOutputType | null
  }

  export type SongArtistMinAggregateOutputType = {
    songId: string | null
    artistId: string | null
    role: $Enums.ArtistRole | null
  }

  export type SongArtistMaxAggregateOutputType = {
    songId: string | null
    artistId: string | null
    role: $Enums.ArtistRole | null
  }

  export type SongArtistCountAggregateOutputType = {
    songId: number
    artistId: number
    role: number
    _all: number
  }


  export type SongArtistMinAggregateInputType = {
    songId?: true
    artistId?: true
    role?: true
  }

  export type SongArtistMaxAggregateInputType = {
    songId?: true
    artistId?: true
    role?: true
  }

  export type SongArtistCountAggregateInputType = {
    songId?: true
    artistId?: true
    role?: true
    _all?: true
  }

  export type SongArtistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongArtist to aggregate.
     */
    where?: SongArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongArtists to fetch.
     */
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SongArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongArtists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SongArtists
    **/
    _count?: true | SongArtistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongArtistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongArtistMaxAggregateInputType
  }

  export type GetSongArtistAggregateType<T extends SongArtistAggregateArgs> = {
        [P in keyof T & keyof AggregateSongArtist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSongArtist[P]>
      : GetScalarType<T[P], AggregateSongArtist[P]>
  }




  export type SongArtistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SongArtistWhereInput
    orderBy?: SongArtistOrderByWithAggregationInput | SongArtistOrderByWithAggregationInput[]
    by: SongArtistScalarFieldEnum[] | SongArtistScalarFieldEnum
    having?: SongArtistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongArtistCountAggregateInputType | true
    _min?: SongArtistMinAggregateInputType
    _max?: SongArtistMaxAggregateInputType
  }

  export type SongArtistGroupByOutputType = {
    songId: string
    artistId: string
    role: $Enums.ArtistRole
    _count: SongArtistCountAggregateOutputType | null
    _min: SongArtistMinAggregateOutputType | null
    _max: SongArtistMaxAggregateOutputType | null
  }

  type GetSongArtistGroupByPayload<T extends SongArtistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SongArtistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongArtistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongArtistGroupByOutputType[P]>
            : GetScalarType<T[P], SongArtistGroupByOutputType[P]>
        }
      >
    >


  export type SongArtistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    songId?: boolean
    artistId?: boolean
    role?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songArtist"]>

  export type SongArtistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    songId?: boolean
    artistId?: boolean
    role?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songArtist"]>

  export type SongArtistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    songId?: boolean
    artistId?: boolean
    role?: boolean
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["songArtist"]>

  export type SongArtistSelectScalar = {
    songId?: boolean
    artistId?: boolean
    role?: boolean
  }

  export type SongArtistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"songId" | "artistId" | "role", ExtArgs["result"]["songArtist"]>
  export type SongArtistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }
  export type SongArtistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }
  export type SongArtistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    song?: boolean | SongDefaultArgs<ExtArgs>
    artist?: boolean | ArtistDefaultArgs<ExtArgs>
  }

  export type $SongArtistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SongArtist"
    objects: {
      song: Prisma.$SongPayload<ExtArgs>
      artist: Prisma.$ArtistPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      songId: string
      artistId: string
      role: $Enums.ArtistRole
    }, ExtArgs["result"]["songArtist"]>
    composites: {}
  }

  type SongArtistGetPayload<S extends boolean | null | undefined | SongArtistDefaultArgs> = $Result.GetResult<Prisma.$SongArtistPayload, S>

  type SongArtistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SongArtistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SongArtistCountAggregateInputType | true
    }

  export interface SongArtistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SongArtist'], meta: { name: 'SongArtist' } }
    /**
     * Find zero or one SongArtist that matches the filter.
     * @param {SongArtistFindUniqueArgs} args - Arguments to find a SongArtist
     * @example
     * // Get one SongArtist
     * const songArtist = await prisma.songArtist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SongArtistFindUniqueArgs>(args: SelectSubset<T, SongArtistFindUniqueArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SongArtist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SongArtistFindUniqueOrThrowArgs} args - Arguments to find a SongArtist
     * @example
     * // Get one SongArtist
     * const songArtist = await prisma.songArtist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SongArtistFindUniqueOrThrowArgs>(args: SelectSubset<T, SongArtistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongArtist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistFindFirstArgs} args - Arguments to find a SongArtist
     * @example
     * // Get one SongArtist
     * const songArtist = await prisma.songArtist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SongArtistFindFirstArgs>(args?: SelectSubset<T, SongArtistFindFirstArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SongArtist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistFindFirstOrThrowArgs} args - Arguments to find a SongArtist
     * @example
     * // Get one SongArtist
     * const songArtist = await prisma.songArtist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SongArtistFindFirstOrThrowArgs>(args?: SelectSubset<T, SongArtistFindFirstOrThrowArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SongArtists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SongArtists
     * const songArtists = await prisma.songArtist.findMany()
     * 
     * // Get first 10 SongArtists
     * const songArtists = await prisma.songArtist.findMany({ take: 10 })
     * 
     * // Only select the `songId`
     * const songArtistWithSongIdOnly = await prisma.songArtist.findMany({ select: { songId: true } })
     * 
     */
    findMany<T extends SongArtistFindManyArgs>(args?: SelectSubset<T, SongArtistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SongArtist.
     * @param {SongArtistCreateArgs} args - Arguments to create a SongArtist.
     * @example
     * // Create one SongArtist
     * const SongArtist = await prisma.songArtist.create({
     *   data: {
     *     // ... data to create a SongArtist
     *   }
     * })
     * 
     */
    create<T extends SongArtistCreateArgs>(args: SelectSubset<T, SongArtistCreateArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SongArtists.
     * @param {SongArtistCreateManyArgs} args - Arguments to create many SongArtists.
     * @example
     * // Create many SongArtists
     * const songArtist = await prisma.songArtist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SongArtistCreateManyArgs>(args?: SelectSubset<T, SongArtistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SongArtists and returns the data saved in the database.
     * @param {SongArtistCreateManyAndReturnArgs} args - Arguments to create many SongArtists.
     * @example
     * // Create many SongArtists
     * const songArtist = await prisma.songArtist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SongArtists and only return the `songId`
     * const songArtistWithSongIdOnly = await prisma.songArtist.createManyAndReturn({
     *   select: { songId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SongArtistCreateManyAndReturnArgs>(args?: SelectSubset<T, SongArtistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SongArtist.
     * @param {SongArtistDeleteArgs} args - Arguments to delete one SongArtist.
     * @example
     * // Delete one SongArtist
     * const SongArtist = await prisma.songArtist.delete({
     *   where: {
     *     // ... filter to delete one SongArtist
     *   }
     * })
     * 
     */
    delete<T extends SongArtistDeleteArgs>(args: SelectSubset<T, SongArtistDeleteArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SongArtist.
     * @param {SongArtistUpdateArgs} args - Arguments to update one SongArtist.
     * @example
     * // Update one SongArtist
     * const songArtist = await prisma.songArtist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SongArtistUpdateArgs>(args: SelectSubset<T, SongArtistUpdateArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SongArtists.
     * @param {SongArtistDeleteManyArgs} args - Arguments to filter SongArtists to delete.
     * @example
     * // Delete a few SongArtists
     * const { count } = await prisma.songArtist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SongArtistDeleteManyArgs>(args?: SelectSubset<T, SongArtistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongArtists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SongArtists
     * const songArtist = await prisma.songArtist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SongArtistUpdateManyArgs>(args: SelectSubset<T, SongArtistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SongArtists and returns the data updated in the database.
     * @param {SongArtistUpdateManyAndReturnArgs} args - Arguments to update many SongArtists.
     * @example
     * // Update many SongArtists
     * const songArtist = await prisma.songArtist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SongArtists and only return the `songId`
     * const songArtistWithSongIdOnly = await prisma.songArtist.updateManyAndReturn({
     *   select: { songId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SongArtistUpdateManyAndReturnArgs>(args: SelectSubset<T, SongArtistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SongArtist.
     * @param {SongArtistUpsertArgs} args - Arguments to update or create a SongArtist.
     * @example
     * // Update or create a SongArtist
     * const songArtist = await prisma.songArtist.upsert({
     *   create: {
     *     // ... data to create a SongArtist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SongArtist we want to update
     *   }
     * })
     */
    upsert<T extends SongArtistUpsertArgs>(args: SelectSubset<T, SongArtistUpsertArgs<ExtArgs>>): Prisma__SongArtistClient<$Result.GetResult<Prisma.$SongArtistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SongArtists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistCountArgs} args - Arguments to filter SongArtists to count.
     * @example
     * // Count the number of SongArtists
     * const count = await prisma.songArtist.count({
     *   where: {
     *     // ... the filter for the SongArtists we want to count
     *   }
     * })
    **/
    count<T extends SongArtistCountArgs>(
      args?: Subset<T, SongArtistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongArtistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SongArtist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongArtistAggregateArgs>(args: Subset<T, SongArtistAggregateArgs>): Prisma.PrismaPromise<GetSongArtistAggregateType<T>>

    /**
     * Group by SongArtist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongArtistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SongArtistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SongArtistGroupByArgs['orderBy'] }
        : { orderBy?: SongArtistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SongArtistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongArtistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SongArtist model
   */
  readonly fields: SongArtistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SongArtist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SongArtistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artist<T extends ArtistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtistDefaultArgs<ExtArgs>>): Prisma__ArtistClient<$Result.GetResult<Prisma.$ArtistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SongArtist model
   */
  interface SongArtistFieldRefs {
    readonly songId: FieldRef<"SongArtist", 'String'>
    readonly artistId: FieldRef<"SongArtist", 'String'>
    readonly role: FieldRef<"SongArtist", 'ArtistRole'>
  }
    

  // Custom InputTypes
  /**
   * SongArtist findUnique
   */
  export type SongArtistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtist to fetch.
     */
    where: SongArtistWhereUniqueInput
  }

  /**
   * SongArtist findUniqueOrThrow
   */
  export type SongArtistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtist to fetch.
     */
    where: SongArtistWhereUniqueInput
  }

  /**
   * SongArtist findFirst
   */
  export type SongArtistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtist to fetch.
     */
    where?: SongArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongArtists to fetch.
     */
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongArtists.
     */
    cursor?: SongArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongArtists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongArtists.
     */
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * SongArtist findFirstOrThrow
   */
  export type SongArtistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtist to fetch.
     */
    where?: SongArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongArtists to fetch.
     */
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SongArtists.
     */
    cursor?: SongArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongArtists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SongArtists.
     */
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * SongArtist findMany
   */
  export type SongArtistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter, which SongArtists to fetch.
     */
    where?: SongArtistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SongArtists to fetch.
     */
    orderBy?: SongArtistOrderByWithRelationInput | SongArtistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SongArtists.
     */
    cursor?: SongArtistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SongArtists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SongArtists.
     */
    skip?: number
    distinct?: SongArtistScalarFieldEnum | SongArtistScalarFieldEnum[]
  }

  /**
   * SongArtist create
   */
  export type SongArtistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * The data needed to create a SongArtist.
     */
    data: XOR<SongArtistCreateInput, SongArtistUncheckedCreateInput>
  }

  /**
   * SongArtist createMany
   */
  export type SongArtistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SongArtists.
     */
    data: SongArtistCreateManyInput | SongArtistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SongArtist createManyAndReturn
   */
  export type SongArtistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * The data used to create many SongArtists.
     */
    data: SongArtistCreateManyInput | SongArtistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongArtist update
   */
  export type SongArtistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * The data needed to update a SongArtist.
     */
    data: XOR<SongArtistUpdateInput, SongArtistUncheckedUpdateInput>
    /**
     * Choose, which SongArtist to update.
     */
    where: SongArtistWhereUniqueInput
  }

  /**
   * SongArtist updateMany
   */
  export type SongArtistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SongArtists.
     */
    data: XOR<SongArtistUpdateManyMutationInput, SongArtistUncheckedUpdateManyInput>
    /**
     * Filter which SongArtists to update
     */
    where?: SongArtistWhereInput
    /**
     * Limit how many SongArtists to update.
     */
    limit?: number
  }

  /**
   * SongArtist updateManyAndReturn
   */
  export type SongArtistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * The data used to update SongArtists.
     */
    data: XOR<SongArtistUpdateManyMutationInput, SongArtistUncheckedUpdateManyInput>
    /**
     * Filter which SongArtists to update
     */
    where?: SongArtistWhereInput
    /**
     * Limit how many SongArtists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SongArtist upsert
   */
  export type SongArtistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * The filter to search for the SongArtist to update in case it exists.
     */
    where: SongArtistWhereUniqueInput
    /**
     * In case the SongArtist found by the `where` argument doesn't exist, create a new SongArtist with this data.
     */
    create: XOR<SongArtistCreateInput, SongArtistUncheckedCreateInput>
    /**
     * In case the SongArtist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SongArtistUpdateInput, SongArtistUncheckedUpdateInput>
  }

  /**
   * SongArtist delete
   */
  export type SongArtistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
    /**
     * Filter which SongArtist to delete.
     */
    where: SongArtistWhereUniqueInput
  }

  /**
   * SongArtist deleteMany
   */
  export type SongArtistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SongArtists to delete
     */
    where?: SongArtistWhereInput
    /**
     * Limit how many SongArtists to delete.
     */
    limit?: number
  }

  /**
   * SongArtist without action
   */
  export type SongArtistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SongArtist
     */
    select?: SongArtistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SongArtist
     */
    omit?: SongArtistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongArtistInclude<ExtArgs> | null
  }


  /**
   * Model Playlist
   */

  export type AggregatePlaylist = {
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  export type PlaylistAvgAggregateOutputType = {
    totalTracks: number | null
    durationMs: number | null
  }

  export type PlaylistSumAggregateOutputType = {
    totalTracks: number | null
    durationMs: number | null
  }

  export type PlaylistMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    slug: string | null
    description: string | null
    imageUrl: string | null
    isPublic: boolean | null
    isCollaborative: boolean | null
    totalTracks: number | null
    durationMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaylistMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    slug: string | null
    description: string | null
    imageUrl: string | null
    isPublic: boolean | null
    isCollaborative: boolean | null
    totalTracks: number | null
    durationMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaylistCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    slug: number
    description: number
    imageUrl: number
    isPublic: number
    isCollaborative: number
    totalTracks: number
    durationMs: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlaylistAvgAggregateInputType = {
    totalTracks?: true
    durationMs?: true
  }

  export type PlaylistSumAggregateInputType = {
    totalTracks?: true
    durationMs?: true
  }

  export type PlaylistMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    slug?: true
    description?: true
    imageUrl?: true
    isPublic?: true
    isCollaborative?: true
    totalTracks?: true
    durationMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaylistMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    slug?: true
    description?: true
    imageUrl?: true
    isPublic?: true
    isCollaborative?: true
    totalTracks?: true
    durationMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaylistCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    slug?: true
    description?: true
    imageUrl?: true
    isPublic?: true
    isCollaborative?: true
    totalTracks?: true
    durationMs?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlist to aggregate.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Playlists
    **/
    _count?: true | PlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistMaxAggregateInputType
  }

  export type GetPlaylistAggregateType<T extends PlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylist[P]>
      : GetScalarType<T[P], AggregatePlaylist[P]>
  }




  export type PlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithAggregationInput | PlaylistOrderByWithAggregationInput[]
    by: PlaylistScalarFieldEnum[] | PlaylistScalarFieldEnum
    having?: PlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaylistCountAggregateInputType | true
    _avg?: PlaylistAvgAggregateInputType
    _sum?: PlaylistSumAggregateInputType
    _min?: PlaylistMinAggregateInputType
    _max?: PlaylistMaxAggregateInputType
  }

  export type PlaylistGroupByOutputType = {
    id: string
    userId: string
    name: string
    slug: string
    description: string | null
    imageUrl: string | null
    isPublic: boolean
    isCollaborative: boolean
    totalTracks: number
    durationMs: number
    createdAt: Date
    updatedAt: Date
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  type GetPlaylistGroupByPayload<T extends PlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: boolean
    durationMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    songs?: boolean | Playlist$songsArgs<ExtArgs>
    followers?: boolean | Playlist$followersArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: boolean
    durationMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: boolean
    durationMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: boolean
    durationMs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlaylistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "slug" | "description" | "imageUrl" | "isPublic" | "isCollaborative" | "totalTracks" | "durationMs" | "createdAt" | "updatedAt", ExtArgs["result"]["playlist"]>
  export type PlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    songs?: boolean | Playlist$songsArgs<ExtArgs>
    followers?: boolean | Playlist$followersArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlaylistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlaylistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Playlist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      songs: Prisma.$PlaylistSongPayload<ExtArgs>[]
      followers: Prisma.$UserFollowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      slug: string
      description: string | null
      imageUrl: string | null
      isPublic: boolean
      isCollaborative: boolean
      totalTracks: number
      durationMs: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playlist"]>
    composites: {}
  }

  type PlaylistGetPayload<S extends boolean | null | undefined | PlaylistDefaultArgs> = $Result.GetResult<Prisma.$PlaylistPayload, S>

  type PlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistCountAggregateInputType | true
    }

  export interface PlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Playlist'], meta: { name: 'Playlist' } }
    /**
     * Find zero or one Playlist that matches the filter.
     * @param {PlaylistFindUniqueArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistFindUniqueArgs>(args: SelectSubset<T, PlaylistFindUniqueArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Playlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistFindUniqueOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistFindFirstArgs>(args?: SelectSubset<T, PlaylistFindFirstArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Playlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Playlists
     * const playlists = await prisma.playlist.findMany()
     * 
     * // Get first 10 Playlists
     * const playlists = await prisma.playlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistWithIdOnly = await prisma.playlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistFindManyArgs>(args?: SelectSubset<T, PlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Playlist.
     * @param {PlaylistCreateArgs} args - Arguments to create a Playlist.
     * @example
     * // Create one Playlist
     * const Playlist = await prisma.playlist.create({
     *   data: {
     *     // ... data to create a Playlist
     *   }
     * })
     * 
     */
    create<T extends PlaylistCreateArgs>(args: SelectSubset<T, PlaylistCreateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Playlists.
     * @param {PlaylistCreateManyArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistCreateManyArgs>(args?: SelectSubset<T, PlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Playlists and returns the data saved in the database.
     * @param {PlaylistCreateManyAndReturnArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Playlists and only return the `id`
     * const playlistWithIdOnly = await prisma.playlist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Playlist.
     * @param {PlaylistDeleteArgs} args - Arguments to delete one Playlist.
     * @example
     * // Delete one Playlist
     * const Playlist = await prisma.playlist.delete({
     *   where: {
     *     // ... filter to delete one Playlist
     *   }
     * })
     * 
     */
    delete<T extends PlaylistDeleteArgs>(args: SelectSubset<T, PlaylistDeleteArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Playlist.
     * @param {PlaylistUpdateArgs} args - Arguments to update one Playlist.
     * @example
     * // Update one Playlist
     * const playlist = await prisma.playlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistUpdateArgs>(args: SelectSubset<T, PlaylistUpdateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Playlists.
     * @param {PlaylistDeleteManyArgs} args - Arguments to filter Playlists to delete.
     * @example
     * // Delete a few Playlists
     * const { count } = await prisma.playlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistDeleteManyArgs>(args?: SelectSubset<T, PlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistUpdateManyArgs>(args: SelectSubset<T, PlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists and returns the data updated in the database.
     * @param {PlaylistUpdateManyAndReturnArgs} args - Arguments to update many Playlists.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Playlists and only return the `id`
     * const playlistWithIdOnly = await prisma.playlist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Playlist.
     * @param {PlaylistUpsertArgs} args - Arguments to update or create a Playlist.
     * @example
     * // Update or create a Playlist
     * const playlist = await prisma.playlist.upsert({
     *   create: {
     *     // ... data to create a Playlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Playlist we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistUpsertArgs>(args: SelectSubset<T, PlaylistUpsertArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistCountArgs} args - Arguments to filter Playlists to count.
     * @example
     * // Count the number of Playlists
     * const count = await prisma.playlist.count({
     *   where: {
     *     // ... the filter for the Playlists we want to count
     *   }
     * })
    **/
    count<T extends PlaylistCountArgs>(
      args?: Subset<T, PlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistAggregateArgs>(args: Subset<T, PlaylistAggregateArgs>): Prisma.PrismaPromise<GetPlaylistAggregateType<T>>

    /**
     * Group by Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Playlist model
   */
  readonly fields: PlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Playlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    songs<T extends Playlist$songsArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$songsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends Playlist$followersArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Playlist model
   */
  interface PlaylistFieldRefs {
    readonly id: FieldRef<"Playlist", 'String'>
    readonly userId: FieldRef<"Playlist", 'String'>
    readonly name: FieldRef<"Playlist", 'String'>
    readonly slug: FieldRef<"Playlist", 'String'>
    readonly description: FieldRef<"Playlist", 'String'>
    readonly imageUrl: FieldRef<"Playlist", 'String'>
    readonly isPublic: FieldRef<"Playlist", 'Boolean'>
    readonly isCollaborative: FieldRef<"Playlist", 'Boolean'>
    readonly totalTracks: FieldRef<"Playlist", 'Int'>
    readonly durationMs: FieldRef<"Playlist", 'Int'>
    readonly createdAt: FieldRef<"Playlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Playlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Playlist findUnique
   */
  export type PlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findUniqueOrThrow
   */
  export type PlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findFirst
   */
  export type PlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findFirstOrThrow
   */
  export type PlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findMany
   */
  export type PlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlists to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist create
   */
  export type PlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a Playlist.
     */
    data: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
  }

  /**
   * Playlist createMany
   */
  export type PlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Playlist createManyAndReturn
   */
  export type PlaylistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Playlist update
   */
  export type PlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a Playlist.
     */
    data: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
    /**
     * Choose, which Playlist to update.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist updateMany
   */
  export type PlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to update.
     */
    limit?: number
  }

  /**
   * Playlist updateManyAndReturn
   */
  export type PlaylistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Playlist upsert
   */
  export type PlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the Playlist to update in case it exists.
     */
    where: PlaylistWhereUniqueInput
    /**
     * In case the Playlist found by the `where` argument doesn't exist, create a new Playlist with this data.
     */
    create: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
    /**
     * In case the Playlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
  }

  /**
   * Playlist delete
   */
  export type PlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter which Playlist to delete.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist deleteMany
   */
  export type PlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlists to delete
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to delete.
     */
    limit?: number
  }

  /**
   * Playlist.songs
   */
  export type Playlist$songsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    where?: PlaylistSongWhereInput
    orderBy?: PlaylistSongOrderByWithRelationInput | PlaylistSongOrderByWithRelationInput[]
    cursor?: PlaylistSongWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistSongScalarFieldEnum | PlaylistSongScalarFieldEnum[]
  }

  /**
   * Playlist.followers
   */
  export type Playlist$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    cursor?: UserFollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * Playlist without action
   */
  export type PlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
  }


  /**
   * Model PlaylistSong
   */

  export type AggregatePlaylistSong = {
    _count: PlaylistSongCountAggregateOutputType | null
    _avg: PlaylistSongAvgAggregateOutputType | null
    _sum: PlaylistSongSumAggregateOutputType | null
    _min: PlaylistSongMinAggregateOutputType | null
    _max: PlaylistSongMaxAggregateOutputType | null
  }

  export type PlaylistSongAvgAggregateOutputType = {
    position: number | null
  }

  export type PlaylistSongSumAggregateOutputType = {
    position: number | null
  }

  export type PlaylistSongMinAggregateOutputType = {
    id: string | null
    playlistId: string | null
    songId: string | null
    position: number | null
    addedBy: string | null
    addedAt: Date | null
  }

  export type PlaylistSongMaxAggregateOutputType = {
    id: string | null
    playlistId: string | null
    songId: string | null
    position: number | null
    addedBy: string | null
    addedAt: Date | null
  }

  export type PlaylistSongCountAggregateOutputType = {
    id: number
    playlistId: number
    songId: number
    position: number
    addedBy: number
    addedAt: number
    _all: number
  }


  export type PlaylistSongAvgAggregateInputType = {
    position?: true
  }

  export type PlaylistSongSumAggregateInputType = {
    position?: true
  }

  export type PlaylistSongMinAggregateInputType = {
    id?: true
    playlistId?: true
    songId?: true
    position?: true
    addedBy?: true
    addedAt?: true
  }

  export type PlaylistSongMaxAggregateInputType = {
    id?: true
    playlistId?: true
    songId?: true
    position?: true
    addedBy?: true
    addedAt?: true
  }

  export type PlaylistSongCountAggregateInputType = {
    id?: true
    playlistId?: true
    songId?: true
    position?: true
    addedBy?: true
    addedAt?: true
    _all?: true
  }

  export type PlaylistSongAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistSong to aggregate.
     */
    where?: PlaylistSongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistSongs to fetch.
     */
    orderBy?: PlaylistSongOrderByWithRelationInput | PlaylistSongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistSongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistSongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistSongs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaylistSongs
    **/
    _count?: true | PlaylistSongCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistSongAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistSongSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistSongMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistSongMaxAggregateInputType
  }

  export type GetPlaylistSongAggregateType<T extends PlaylistSongAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylistSong]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylistSong[P]>
      : GetScalarType<T[P], AggregatePlaylistSong[P]>
  }




  export type PlaylistSongGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistSongWhereInput
    orderBy?: PlaylistSongOrderByWithAggregationInput | PlaylistSongOrderByWithAggregationInput[]
    by: PlaylistSongScalarFieldEnum[] | PlaylistSongScalarFieldEnum
    having?: PlaylistSongScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaylistSongCountAggregateInputType | true
    _avg?: PlaylistSongAvgAggregateInputType
    _sum?: PlaylistSongSumAggregateInputType
    _min?: PlaylistSongMinAggregateInputType
    _max?: PlaylistSongMaxAggregateInputType
  }

  export type PlaylistSongGroupByOutputType = {
    id: string
    playlistId: string
    songId: string
    position: number
    addedBy: string | null
    addedAt: Date
    _count: PlaylistSongCountAggregateOutputType | null
    _avg: PlaylistSongAvgAggregateOutputType | null
    _sum: PlaylistSongSumAggregateOutputType | null
    _min: PlaylistSongMinAggregateOutputType | null
    _max: PlaylistSongMaxAggregateOutputType | null
  }

  type GetPlaylistSongGroupByPayload<T extends PlaylistSongGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistSongGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistSongGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistSongGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistSongGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistSongSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playlistId?: boolean
    songId?: boolean
    position?: boolean
    addedBy?: boolean
    addedAt?: boolean
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlistSong"]>

  export type PlaylistSongSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playlistId?: boolean
    songId?: boolean
    position?: boolean
    addedBy?: boolean
    addedAt?: boolean
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlistSong"]>

  export type PlaylistSongSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playlistId?: boolean
    songId?: boolean
    position?: boolean
    addedBy?: boolean
    addedAt?: boolean
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlistSong"]>

  export type PlaylistSongSelectScalar = {
    id?: boolean
    playlistId?: boolean
    songId?: boolean
    position?: boolean
    addedBy?: boolean
    addedAt?: boolean
  }

  export type PlaylistSongOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playlistId" | "songId" | "position" | "addedBy" | "addedAt", ExtArgs["result"]["playlistSong"]>
  export type PlaylistSongInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type PlaylistSongIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type PlaylistSongIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }

  export type $PlaylistSongPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaylistSong"
    objects: {
      playlist: Prisma.$PlaylistPayload<ExtArgs>
      song: Prisma.$SongPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playlistId: string
      songId: string
      position: number
      addedBy: string | null
      addedAt: Date
    }, ExtArgs["result"]["playlistSong"]>
    composites: {}
  }

  type PlaylistSongGetPayload<S extends boolean | null | undefined | PlaylistSongDefaultArgs> = $Result.GetResult<Prisma.$PlaylistSongPayload, S>

  type PlaylistSongCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistSongFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistSongCountAggregateInputType | true
    }

  export interface PlaylistSongDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaylistSong'], meta: { name: 'PlaylistSong' } }
    /**
     * Find zero or one PlaylistSong that matches the filter.
     * @param {PlaylistSongFindUniqueArgs} args - Arguments to find a PlaylistSong
     * @example
     * // Get one PlaylistSong
     * const playlistSong = await prisma.playlistSong.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistSongFindUniqueArgs>(args: SelectSubset<T, PlaylistSongFindUniqueArgs<ExtArgs>>): Prisma__PlaylistSongClient<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaylistSong that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistSongFindUniqueOrThrowArgs} args - Arguments to find a PlaylistSong
     * @example
     * // Get one PlaylistSong
     * const playlistSong = await prisma.playlistSong.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistSongFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistSongFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistSongClient<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistSong that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistSongFindFirstArgs} args - Arguments to find a PlaylistSong
     * @example
     * // Get one PlaylistSong
     * const playlistSong = await prisma.playlistSong.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistSongFindFirstArgs>(args?: SelectSubset<T, PlaylistSongFindFirstArgs<ExtArgs>>): Prisma__PlaylistSongClient<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistSong that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistSongFindFirstOrThrowArgs} args - Arguments to find a PlaylistSong
     * @example
     * // Get one PlaylistSong
     * const playlistSong = await prisma.playlistSong.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistSongFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistSongFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistSongClient<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaylistSongs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistSongFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaylistSongs
     * const playlistSongs = await prisma.playlistSong.findMany()
     * 
     * // Get first 10 PlaylistSongs
     * const playlistSongs = await prisma.playlistSong.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistSongWithIdOnly = await prisma.playlistSong.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistSongFindManyArgs>(args?: SelectSubset<T, PlaylistSongFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaylistSong.
     * @param {PlaylistSongCreateArgs} args - Arguments to create a PlaylistSong.
     * @example
     * // Create one PlaylistSong
     * const PlaylistSong = await prisma.playlistSong.create({
     *   data: {
     *     // ... data to create a PlaylistSong
     *   }
     * })
     * 
     */
    create<T extends PlaylistSongCreateArgs>(args: SelectSubset<T, PlaylistSongCreateArgs<ExtArgs>>): Prisma__PlaylistSongClient<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaylistSongs.
     * @param {PlaylistSongCreateManyArgs} args - Arguments to create many PlaylistSongs.
     * @example
     * // Create many PlaylistSongs
     * const playlistSong = await prisma.playlistSong.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistSongCreateManyArgs>(args?: SelectSubset<T, PlaylistSongCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaylistSongs and returns the data saved in the database.
     * @param {PlaylistSongCreateManyAndReturnArgs} args - Arguments to create many PlaylistSongs.
     * @example
     * // Create many PlaylistSongs
     * const playlistSong = await prisma.playlistSong.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaylistSongs and only return the `id`
     * const playlistSongWithIdOnly = await prisma.playlistSong.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistSongCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistSongCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaylistSong.
     * @param {PlaylistSongDeleteArgs} args - Arguments to delete one PlaylistSong.
     * @example
     * // Delete one PlaylistSong
     * const PlaylistSong = await prisma.playlistSong.delete({
     *   where: {
     *     // ... filter to delete one PlaylistSong
     *   }
     * })
     * 
     */
    delete<T extends PlaylistSongDeleteArgs>(args: SelectSubset<T, PlaylistSongDeleteArgs<ExtArgs>>): Prisma__PlaylistSongClient<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaylistSong.
     * @param {PlaylistSongUpdateArgs} args - Arguments to update one PlaylistSong.
     * @example
     * // Update one PlaylistSong
     * const playlistSong = await prisma.playlistSong.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistSongUpdateArgs>(args: SelectSubset<T, PlaylistSongUpdateArgs<ExtArgs>>): Prisma__PlaylistSongClient<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaylistSongs.
     * @param {PlaylistSongDeleteManyArgs} args - Arguments to filter PlaylistSongs to delete.
     * @example
     * // Delete a few PlaylistSongs
     * const { count } = await prisma.playlistSong.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistSongDeleteManyArgs>(args?: SelectSubset<T, PlaylistSongDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistSongs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistSongUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaylistSongs
     * const playlistSong = await prisma.playlistSong.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistSongUpdateManyArgs>(args: SelectSubset<T, PlaylistSongUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistSongs and returns the data updated in the database.
     * @param {PlaylistSongUpdateManyAndReturnArgs} args - Arguments to update many PlaylistSongs.
     * @example
     * // Update many PlaylistSongs
     * const playlistSong = await prisma.playlistSong.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaylistSongs and only return the `id`
     * const playlistSongWithIdOnly = await prisma.playlistSong.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaylistSongUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaylistSongUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaylistSong.
     * @param {PlaylistSongUpsertArgs} args - Arguments to update or create a PlaylistSong.
     * @example
     * // Update or create a PlaylistSong
     * const playlistSong = await prisma.playlistSong.upsert({
     *   create: {
     *     // ... data to create a PlaylistSong
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaylistSong we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistSongUpsertArgs>(args: SelectSubset<T, PlaylistSongUpsertArgs<ExtArgs>>): Prisma__PlaylistSongClient<$Result.GetResult<Prisma.$PlaylistSongPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaylistSongs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistSongCountArgs} args - Arguments to filter PlaylistSongs to count.
     * @example
     * // Count the number of PlaylistSongs
     * const count = await prisma.playlistSong.count({
     *   where: {
     *     // ... the filter for the PlaylistSongs we want to count
     *   }
     * })
    **/
    count<T extends PlaylistSongCountArgs>(
      args?: Subset<T, PlaylistSongCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistSongCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaylistSong.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistSongAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistSongAggregateArgs>(args: Subset<T, PlaylistSongAggregateArgs>): Prisma.PrismaPromise<GetPlaylistSongAggregateType<T>>

    /**
     * Group by PlaylistSong.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistSongGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistSongGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistSongGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistSongGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistSongGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistSongGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaylistSong model
   */
  readonly fields: PlaylistSongFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaylistSong.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistSongClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlist<T extends PlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistDefaultArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaylistSong model
   */
  interface PlaylistSongFieldRefs {
    readonly id: FieldRef<"PlaylistSong", 'String'>
    readonly playlistId: FieldRef<"PlaylistSong", 'String'>
    readonly songId: FieldRef<"PlaylistSong", 'String'>
    readonly position: FieldRef<"PlaylistSong", 'Int'>
    readonly addedBy: FieldRef<"PlaylistSong", 'String'>
    readonly addedAt: FieldRef<"PlaylistSong", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlaylistSong findUnique
   */
  export type PlaylistSongFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSong to fetch.
     */
    where: PlaylistSongWhereUniqueInput
  }

  /**
   * PlaylistSong findUniqueOrThrow
   */
  export type PlaylistSongFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSong to fetch.
     */
    where: PlaylistSongWhereUniqueInput
  }

  /**
   * PlaylistSong findFirst
   */
  export type PlaylistSongFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSong to fetch.
     */
    where?: PlaylistSongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistSongs to fetch.
     */
    orderBy?: PlaylistSongOrderByWithRelationInput | PlaylistSongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistSongs.
     */
    cursor?: PlaylistSongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistSongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistSongs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistSongs.
     */
    distinct?: PlaylistSongScalarFieldEnum | PlaylistSongScalarFieldEnum[]
  }

  /**
   * PlaylistSong findFirstOrThrow
   */
  export type PlaylistSongFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSong to fetch.
     */
    where?: PlaylistSongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistSongs to fetch.
     */
    orderBy?: PlaylistSongOrderByWithRelationInput | PlaylistSongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistSongs.
     */
    cursor?: PlaylistSongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistSongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistSongs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistSongs.
     */
    distinct?: PlaylistSongScalarFieldEnum | PlaylistSongScalarFieldEnum[]
  }

  /**
   * PlaylistSong findMany
   */
  export type PlaylistSongFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistSongs to fetch.
     */
    where?: PlaylistSongWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistSongs to fetch.
     */
    orderBy?: PlaylistSongOrderByWithRelationInput | PlaylistSongOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaylistSongs.
     */
    cursor?: PlaylistSongWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistSongs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistSongs.
     */
    skip?: number
    distinct?: PlaylistSongScalarFieldEnum | PlaylistSongScalarFieldEnum[]
  }

  /**
   * PlaylistSong create
   */
  export type PlaylistSongCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaylistSong.
     */
    data: XOR<PlaylistSongCreateInput, PlaylistSongUncheckedCreateInput>
  }

  /**
   * PlaylistSong createMany
   */
  export type PlaylistSongCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaylistSongs.
     */
    data: PlaylistSongCreateManyInput | PlaylistSongCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaylistSong createManyAndReturn
   */
  export type PlaylistSongCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * The data used to create many PlaylistSongs.
     */
    data: PlaylistSongCreateManyInput | PlaylistSongCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistSong update
   */
  export type PlaylistSongUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaylistSong.
     */
    data: XOR<PlaylistSongUpdateInput, PlaylistSongUncheckedUpdateInput>
    /**
     * Choose, which PlaylistSong to update.
     */
    where: PlaylistSongWhereUniqueInput
  }

  /**
   * PlaylistSong updateMany
   */
  export type PlaylistSongUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaylistSongs.
     */
    data: XOR<PlaylistSongUpdateManyMutationInput, PlaylistSongUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistSongs to update
     */
    where?: PlaylistSongWhereInput
    /**
     * Limit how many PlaylistSongs to update.
     */
    limit?: number
  }

  /**
   * PlaylistSong updateManyAndReturn
   */
  export type PlaylistSongUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * The data used to update PlaylistSongs.
     */
    data: XOR<PlaylistSongUpdateManyMutationInput, PlaylistSongUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistSongs to update
     */
    where?: PlaylistSongWhereInput
    /**
     * Limit how many PlaylistSongs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaylistSong upsert
   */
  export type PlaylistSongUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaylistSong to update in case it exists.
     */
    where: PlaylistSongWhereUniqueInput
    /**
     * In case the PlaylistSong found by the `where` argument doesn't exist, create a new PlaylistSong with this data.
     */
    create: XOR<PlaylistSongCreateInput, PlaylistSongUncheckedCreateInput>
    /**
     * In case the PlaylistSong was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistSongUpdateInput, PlaylistSongUncheckedUpdateInput>
  }

  /**
   * PlaylistSong delete
   */
  export type PlaylistSongDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
    /**
     * Filter which PlaylistSong to delete.
     */
    where: PlaylistSongWhereUniqueInput
  }

  /**
   * PlaylistSong deleteMany
   */
  export type PlaylistSongDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistSongs to delete
     */
    where?: PlaylistSongWhereInput
    /**
     * Limit how many PlaylistSongs to delete.
     */
    limit?: number
  }

  /**
   * PlaylistSong without action
   */
  export type PlaylistSongDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistSong
     */
    select?: PlaylistSongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistSong
     */
    omit?: PlaylistSongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistSongInclude<ExtArgs> | null
  }


  /**
   * Model UserFollow
   */

  export type AggregateUserFollow = {
    _count: UserFollowCountAggregateOutputType | null
    _min: UserFollowMinAggregateOutputType | null
    _max: UserFollowMaxAggregateOutputType | null
  }

  export type UserFollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingType: $Enums.FollowType | null
    followingId: string | null
    createdAt: Date | null
  }

  export type UserFollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingType: $Enums.FollowType | null
    followingId: string | null
    createdAt: Date | null
  }

  export type UserFollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingType: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type UserFollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingType?: true
    followingId?: true
    createdAt?: true
  }

  export type UserFollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingType?: true
    followingId?: true
    createdAt?: true
  }

  export type UserFollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingType?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type UserFollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollow to aggregate.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFollows
    **/
    _count?: true | UserFollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFollowMaxAggregateInputType
  }

  export type GetUserFollowAggregateType<T extends UserFollowAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFollow[P]>
      : GetScalarType<T[P], AggregateUserFollow[P]>
  }




  export type UserFollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFollowWhereInput
    orderBy?: UserFollowOrderByWithAggregationInput | UserFollowOrderByWithAggregationInput[]
    by: UserFollowScalarFieldEnum[] | UserFollowScalarFieldEnum
    having?: UserFollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFollowCountAggregateInputType | true
    _min?: UserFollowMinAggregateInputType
    _max?: UserFollowMaxAggregateInputType
  }

  export type UserFollowGroupByOutputType = {
    id: string
    followerId: string
    followingType: $Enums.FollowType
    followingId: string
    createdAt: Date
    _count: UserFollowCountAggregateOutputType | null
    _min: UserFollowMinAggregateOutputType | null
    _max: UserFollowMaxAggregateOutputType | null
  }

  type GetUserFollowGroupByPayload<T extends UserFollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFollowGroupByOutputType[P]>
            : GetScalarType<T[P], UserFollowGroupByOutputType[P]>
        }
      >
    >


  export type UserFollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingType?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | UserFollow$playlistArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingType?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | UserFollow$playlistArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingType?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | UserFollow$playlistArgs<ExtArgs>
  }, ExtArgs["result"]["userFollow"]>

  export type UserFollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingType?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type UserFollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingType" | "followingId" | "createdAt", ExtArgs["result"]["userFollow"]>
  export type UserFollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | UserFollow$playlistArgs<ExtArgs>
  }
  export type UserFollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | UserFollow$playlistArgs<ExtArgs>
  }
  export type UserFollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    playlist?: boolean | UserFollow$playlistArgs<ExtArgs>
  }

  export type $UserFollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFollow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      playlist: Prisma.$PlaylistPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingType: $Enums.FollowType
      followingId: string
      createdAt: Date
    }, ExtArgs["result"]["userFollow"]>
    composites: {}
  }

  type UserFollowGetPayload<S extends boolean | null | undefined | UserFollowDefaultArgs> = $Result.GetResult<Prisma.$UserFollowPayload, S>

  type UserFollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFollowCountAggregateInputType | true
    }

  export interface UserFollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFollow'], meta: { name: 'UserFollow' } }
    /**
     * Find zero or one UserFollow that matches the filter.
     * @param {UserFollowFindUniqueArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFollowFindUniqueArgs>(args: SelectSubset<T, UserFollowFindUniqueArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFollow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFollowFindUniqueOrThrowArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFollowFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFollow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindFirstArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFollowFindFirstArgs>(args?: SelectSubset<T, UserFollowFindFirstArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFollow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindFirstOrThrowArgs} args - Arguments to find a UserFollow
     * @example
     * // Get one UserFollow
     * const userFollow = await prisma.userFollow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFollowFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFollows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFollows
     * const userFollows = await prisma.userFollow.findMany()
     * 
     * // Get first 10 UserFollows
     * const userFollows = await prisma.userFollow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFollowWithIdOnly = await prisma.userFollow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFollowFindManyArgs>(args?: SelectSubset<T, UserFollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFollow.
     * @param {UserFollowCreateArgs} args - Arguments to create a UserFollow.
     * @example
     * // Create one UserFollow
     * const UserFollow = await prisma.userFollow.create({
     *   data: {
     *     // ... data to create a UserFollow
     *   }
     * })
     * 
     */
    create<T extends UserFollowCreateArgs>(args: SelectSubset<T, UserFollowCreateArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFollows.
     * @param {UserFollowCreateManyArgs} args - Arguments to create many UserFollows.
     * @example
     * // Create many UserFollows
     * const userFollow = await prisma.userFollow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFollowCreateManyArgs>(args?: SelectSubset<T, UserFollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFollows and returns the data saved in the database.
     * @param {UserFollowCreateManyAndReturnArgs} args - Arguments to create many UserFollows.
     * @example
     * // Create many UserFollows
     * const userFollow = await prisma.userFollow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFollows and only return the `id`
     * const userFollowWithIdOnly = await prisma.userFollow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFollowCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFollow.
     * @param {UserFollowDeleteArgs} args - Arguments to delete one UserFollow.
     * @example
     * // Delete one UserFollow
     * const UserFollow = await prisma.userFollow.delete({
     *   where: {
     *     // ... filter to delete one UserFollow
     *   }
     * })
     * 
     */
    delete<T extends UserFollowDeleteArgs>(args: SelectSubset<T, UserFollowDeleteArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFollow.
     * @param {UserFollowUpdateArgs} args - Arguments to update one UserFollow.
     * @example
     * // Update one UserFollow
     * const userFollow = await prisma.userFollow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFollowUpdateArgs>(args: SelectSubset<T, UserFollowUpdateArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFollows.
     * @param {UserFollowDeleteManyArgs} args - Arguments to filter UserFollows to delete.
     * @example
     * // Delete a few UserFollows
     * const { count } = await prisma.userFollow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFollowDeleteManyArgs>(args?: SelectSubset<T, UserFollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFollows
     * const userFollow = await prisma.userFollow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFollowUpdateManyArgs>(args: SelectSubset<T, UserFollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFollows and returns the data updated in the database.
     * @param {UserFollowUpdateManyAndReturnArgs} args - Arguments to update many UserFollows.
     * @example
     * // Update many UserFollows
     * const userFollow = await prisma.userFollow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFollows and only return the `id`
     * const userFollowWithIdOnly = await prisma.userFollow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFollowUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFollow.
     * @param {UserFollowUpsertArgs} args - Arguments to update or create a UserFollow.
     * @example
     * // Update or create a UserFollow
     * const userFollow = await prisma.userFollow.upsert({
     *   create: {
     *     // ... data to create a UserFollow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFollow we want to update
     *   }
     * })
     */
    upsert<T extends UserFollowUpsertArgs>(args: SelectSubset<T, UserFollowUpsertArgs<ExtArgs>>): Prisma__UserFollowClient<$Result.GetResult<Prisma.$UserFollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFollows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowCountArgs} args - Arguments to filter UserFollows to count.
     * @example
     * // Count the number of UserFollows
     * const count = await prisma.userFollow.count({
     *   where: {
     *     // ... the filter for the UserFollows we want to count
     *   }
     * })
    **/
    count<T extends UserFollowCountArgs>(
      args?: Subset<T, UserFollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFollowAggregateArgs>(args: Subset<T, UserFollowAggregateArgs>): Prisma.PrismaPromise<GetUserFollowAggregateType<T>>

    /**
     * Group by UserFollow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFollowGroupByArgs['orderBy'] }
        : { orderBy?: UserFollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFollow model
   */
  readonly fields: UserFollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFollow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    playlist<T extends UserFollow$playlistArgs<ExtArgs> = {}>(args?: Subset<T, UserFollow$playlistArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFollow model
   */
  interface UserFollowFieldRefs {
    readonly id: FieldRef<"UserFollow", 'String'>
    readonly followerId: FieldRef<"UserFollow", 'String'>
    readonly followingType: FieldRef<"UserFollow", 'FollowType'>
    readonly followingId: FieldRef<"UserFollow", 'String'>
    readonly createdAt: FieldRef<"UserFollow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFollow findUnique
   */
  export type UserFollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow findUniqueOrThrow
   */
  export type UserFollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow findFirst
   */
  export type UserFollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollows.
     */
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow findFirstOrThrow
   */
  export type UserFollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollow to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFollows.
     */
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow findMany
   */
  export type UserFollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter, which UserFollows to fetch.
     */
    where?: UserFollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFollows to fetch.
     */
    orderBy?: UserFollowOrderByWithRelationInput | UserFollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFollows.
     */
    cursor?: UserFollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFollows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFollows.
     */
    skip?: number
    distinct?: UserFollowScalarFieldEnum | UserFollowScalarFieldEnum[]
  }

  /**
   * UserFollow create
   */
  export type UserFollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFollow.
     */
    data: XOR<UserFollowCreateInput, UserFollowUncheckedCreateInput>
  }

  /**
   * UserFollow createMany
   */
  export type UserFollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFollows.
     */
    data: UserFollowCreateManyInput | UserFollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFollow createManyAndReturn
   */
  export type UserFollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * The data used to create many UserFollows.
     */
    data: UserFollowCreateManyInput | UserFollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFollow update
   */
  export type UserFollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFollow.
     */
    data: XOR<UserFollowUpdateInput, UserFollowUncheckedUpdateInput>
    /**
     * Choose, which UserFollow to update.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow updateMany
   */
  export type UserFollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFollows.
     */
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyInput>
    /**
     * Filter which UserFollows to update
     */
    where?: UserFollowWhereInput
    /**
     * Limit how many UserFollows to update.
     */
    limit?: number
  }

  /**
   * UserFollow updateManyAndReturn
   */
  export type UserFollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * The data used to update UserFollows.
     */
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyInput>
    /**
     * Filter which UserFollows to update
     */
    where?: UserFollowWhereInput
    /**
     * Limit how many UserFollows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFollow upsert
   */
  export type UserFollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFollow to update in case it exists.
     */
    where: UserFollowWhereUniqueInput
    /**
     * In case the UserFollow found by the `where` argument doesn't exist, create a new UserFollow with this data.
     */
    create: XOR<UserFollowCreateInput, UserFollowUncheckedCreateInput>
    /**
     * In case the UserFollow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFollowUpdateInput, UserFollowUncheckedUpdateInput>
  }

  /**
   * UserFollow delete
   */
  export type UserFollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
    /**
     * Filter which UserFollow to delete.
     */
    where: UserFollowWhereUniqueInput
  }

  /**
   * UserFollow deleteMany
   */
  export type UserFollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFollows to delete
     */
    where?: UserFollowWhereInput
    /**
     * Limit how many UserFollows to delete.
     */
    limit?: number
  }

  /**
   * UserFollow.playlist
   */
  export type UserFollow$playlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput
  }

  /**
   * UserFollow without action
   */
  export type UserFollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFollow
     */
    select?: UserFollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFollow
     */
    omit?: UserFollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFollowInclude<ExtArgs> | null
  }


  /**
   * Model UserLibrary
   */

  export type AggregateUserLibrary = {
    _count: UserLibraryCountAggregateOutputType | null
    _min: UserLibraryMinAggregateOutputType | null
    _max: UserLibraryMaxAggregateOutputType | null
  }

  export type UserLibraryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    itemType: $Enums.LibraryItemType | null
    itemId: string | null
    addedAt: Date | null
  }

  export type UserLibraryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    itemType: $Enums.LibraryItemType | null
    itemId: string | null
    addedAt: Date | null
  }

  export type UserLibraryCountAggregateOutputType = {
    id: number
    userId: number
    itemType: number
    itemId: number
    addedAt: number
    _all: number
  }


  export type UserLibraryMinAggregateInputType = {
    id?: true
    userId?: true
    itemType?: true
    itemId?: true
    addedAt?: true
  }

  export type UserLibraryMaxAggregateInputType = {
    id?: true
    userId?: true
    itemType?: true
    itemId?: true
    addedAt?: true
  }

  export type UserLibraryCountAggregateInputType = {
    id?: true
    userId?: true
    itemType?: true
    itemId?: true
    addedAt?: true
    _all?: true
  }

  export type UserLibraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLibrary to aggregate.
     */
    where?: UserLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraries to fetch.
     */
    orderBy?: UserLibraryOrderByWithRelationInput | UserLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLibraries
    **/
    _count?: true | UserLibraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLibraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLibraryMaxAggregateInputType
  }

  export type GetUserLibraryAggregateType<T extends UserLibraryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLibrary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLibrary[P]>
      : GetScalarType<T[P], AggregateUserLibrary[P]>
  }




  export type UserLibraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLibraryWhereInput
    orderBy?: UserLibraryOrderByWithAggregationInput | UserLibraryOrderByWithAggregationInput[]
    by: UserLibraryScalarFieldEnum[] | UserLibraryScalarFieldEnum
    having?: UserLibraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLibraryCountAggregateInputType | true
    _min?: UserLibraryMinAggregateInputType
    _max?: UserLibraryMaxAggregateInputType
  }

  export type UserLibraryGroupByOutputType = {
    id: string
    userId: string
    itemType: $Enums.LibraryItemType
    itemId: string
    addedAt: Date
    _count: UserLibraryCountAggregateOutputType | null
    _min: UserLibraryMinAggregateOutputType | null
    _max: UserLibraryMaxAggregateOutputType | null
  }

  type GetUserLibraryGroupByPayload<T extends UserLibraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLibraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLibraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLibraryGroupByOutputType[P]>
            : GetScalarType<T[P], UserLibraryGroupByOutputType[P]>
        }
      >
    >


  export type UserLibrarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLibrary"]>

  export type UserLibrarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLibrary"]>

  export type UserLibrarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLibrary"]>

  export type UserLibrarySelectScalar = {
    id?: boolean
    userId?: boolean
    itemType?: boolean
    itemId?: boolean
    addedAt?: boolean
  }

  export type UserLibraryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "itemType" | "itemId" | "addedAt", ExtArgs["result"]["userLibrary"]>
  export type UserLibraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLibraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLibraryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserLibraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLibrary"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      itemType: $Enums.LibraryItemType
      itemId: string
      addedAt: Date
    }, ExtArgs["result"]["userLibrary"]>
    composites: {}
  }

  type UserLibraryGetPayload<S extends boolean | null | undefined | UserLibraryDefaultArgs> = $Result.GetResult<Prisma.$UserLibraryPayload, S>

  type UserLibraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLibraryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLibraryCountAggregateInputType | true
    }

  export interface UserLibraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLibrary'], meta: { name: 'UserLibrary' } }
    /**
     * Find zero or one UserLibrary that matches the filter.
     * @param {UserLibraryFindUniqueArgs} args - Arguments to find a UserLibrary
     * @example
     * // Get one UserLibrary
     * const userLibrary = await prisma.userLibrary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLibraryFindUniqueArgs>(args: SelectSubset<T, UserLibraryFindUniqueArgs<ExtArgs>>): Prisma__UserLibraryClient<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLibrary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLibraryFindUniqueOrThrowArgs} args - Arguments to find a UserLibrary
     * @example
     * // Get one UserLibrary
     * const userLibrary = await prisma.userLibrary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLibraryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLibraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLibraryClient<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLibrary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryFindFirstArgs} args - Arguments to find a UserLibrary
     * @example
     * // Get one UserLibrary
     * const userLibrary = await prisma.userLibrary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLibraryFindFirstArgs>(args?: SelectSubset<T, UserLibraryFindFirstArgs<ExtArgs>>): Prisma__UserLibraryClient<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLibrary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryFindFirstOrThrowArgs} args - Arguments to find a UserLibrary
     * @example
     * // Get one UserLibrary
     * const userLibrary = await prisma.userLibrary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLibraryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLibraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLibraryClient<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLibraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLibraries
     * const userLibraries = await prisma.userLibrary.findMany()
     * 
     * // Get first 10 UserLibraries
     * const userLibraries = await prisma.userLibrary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLibraryWithIdOnly = await prisma.userLibrary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLibraryFindManyArgs>(args?: SelectSubset<T, UserLibraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLibrary.
     * @param {UserLibraryCreateArgs} args - Arguments to create a UserLibrary.
     * @example
     * // Create one UserLibrary
     * const UserLibrary = await prisma.userLibrary.create({
     *   data: {
     *     // ... data to create a UserLibrary
     *   }
     * })
     * 
     */
    create<T extends UserLibraryCreateArgs>(args: SelectSubset<T, UserLibraryCreateArgs<ExtArgs>>): Prisma__UserLibraryClient<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLibraries.
     * @param {UserLibraryCreateManyArgs} args - Arguments to create many UserLibraries.
     * @example
     * // Create many UserLibraries
     * const userLibrary = await prisma.userLibrary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLibraryCreateManyArgs>(args?: SelectSubset<T, UserLibraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLibraries and returns the data saved in the database.
     * @param {UserLibraryCreateManyAndReturnArgs} args - Arguments to create many UserLibraries.
     * @example
     * // Create many UserLibraries
     * const userLibrary = await prisma.userLibrary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLibraries and only return the `id`
     * const userLibraryWithIdOnly = await prisma.userLibrary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLibraryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLibraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLibrary.
     * @param {UserLibraryDeleteArgs} args - Arguments to delete one UserLibrary.
     * @example
     * // Delete one UserLibrary
     * const UserLibrary = await prisma.userLibrary.delete({
     *   where: {
     *     // ... filter to delete one UserLibrary
     *   }
     * })
     * 
     */
    delete<T extends UserLibraryDeleteArgs>(args: SelectSubset<T, UserLibraryDeleteArgs<ExtArgs>>): Prisma__UserLibraryClient<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLibrary.
     * @param {UserLibraryUpdateArgs} args - Arguments to update one UserLibrary.
     * @example
     * // Update one UserLibrary
     * const userLibrary = await prisma.userLibrary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLibraryUpdateArgs>(args: SelectSubset<T, UserLibraryUpdateArgs<ExtArgs>>): Prisma__UserLibraryClient<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLibraries.
     * @param {UserLibraryDeleteManyArgs} args - Arguments to filter UserLibraries to delete.
     * @example
     * // Delete a few UserLibraries
     * const { count } = await prisma.userLibrary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLibraryDeleteManyArgs>(args?: SelectSubset<T, UserLibraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLibraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLibraries
     * const userLibrary = await prisma.userLibrary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLibraryUpdateManyArgs>(args: SelectSubset<T, UserLibraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLibraries and returns the data updated in the database.
     * @param {UserLibraryUpdateManyAndReturnArgs} args - Arguments to update many UserLibraries.
     * @example
     * // Update many UserLibraries
     * const userLibrary = await prisma.userLibrary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLibraries and only return the `id`
     * const userLibraryWithIdOnly = await prisma.userLibrary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLibraryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLibraryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLibrary.
     * @param {UserLibraryUpsertArgs} args - Arguments to update or create a UserLibrary.
     * @example
     * // Update or create a UserLibrary
     * const userLibrary = await prisma.userLibrary.upsert({
     *   create: {
     *     // ... data to create a UserLibrary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLibrary we want to update
     *   }
     * })
     */
    upsert<T extends UserLibraryUpsertArgs>(args: SelectSubset<T, UserLibraryUpsertArgs<ExtArgs>>): Prisma__UserLibraryClient<$Result.GetResult<Prisma.$UserLibraryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLibraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryCountArgs} args - Arguments to filter UserLibraries to count.
     * @example
     * // Count the number of UserLibraries
     * const count = await prisma.userLibrary.count({
     *   where: {
     *     // ... the filter for the UserLibraries we want to count
     *   }
     * })
    **/
    count<T extends UserLibraryCountArgs>(
      args?: Subset<T, UserLibraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLibraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLibrary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLibraryAggregateArgs>(args: Subset<T, UserLibraryAggregateArgs>): Prisma.PrismaPromise<GetUserLibraryAggregateType<T>>

    /**
     * Group by UserLibrary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLibraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLibraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLibraryGroupByArgs['orderBy'] }
        : { orderBy?: UserLibraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLibraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLibraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLibrary model
   */
  readonly fields: UserLibraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLibrary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLibraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLibrary model
   */
  interface UserLibraryFieldRefs {
    readonly id: FieldRef<"UserLibrary", 'String'>
    readonly userId: FieldRef<"UserLibrary", 'String'>
    readonly itemType: FieldRef<"UserLibrary", 'LibraryItemType'>
    readonly itemId: FieldRef<"UserLibrary", 'String'>
    readonly addedAt: FieldRef<"UserLibrary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLibrary findUnique
   */
  export type UserLibraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibrary to fetch.
     */
    where: UserLibraryWhereUniqueInput
  }

  /**
   * UserLibrary findUniqueOrThrow
   */
  export type UserLibraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibrary to fetch.
     */
    where: UserLibraryWhereUniqueInput
  }

  /**
   * UserLibrary findFirst
   */
  export type UserLibraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibrary to fetch.
     */
    where?: UserLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraries to fetch.
     */
    orderBy?: UserLibraryOrderByWithRelationInput | UserLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLibraries.
     */
    cursor?: UserLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLibraries.
     */
    distinct?: UserLibraryScalarFieldEnum | UserLibraryScalarFieldEnum[]
  }

  /**
   * UserLibrary findFirstOrThrow
   */
  export type UserLibraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibrary to fetch.
     */
    where?: UserLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraries to fetch.
     */
    orderBy?: UserLibraryOrderByWithRelationInput | UserLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLibraries.
     */
    cursor?: UserLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLibraries.
     */
    distinct?: UserLibraryScalarFieldEnum | UserLibraryScalarFieldEnum[]
  }

  /**
   * UserLibrary findMany
   */
  export type UserLibraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserLibraries to fetch.
     */
    where?: UserLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLibraries to fetch.
     */
    orderBy?: UserLibraryOrderByWithRelationInput | UserLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLibraries.
     */
    cursor?: UserLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLibraries.
     */
    skip?: number
    distinct?: UserLibraryScalarFieldEnum | UserLibraryScalarFieldEnum[]
  }

  /**
   * UserLibrary create
   */
  export type UserLibraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLibrary.
     */
    data: XOR<UserLibraryCreateInput, UserLibraryUncheckedCreateInput>
  }

  /**
   * UserLibrary createMany
   */
  export type UserLibraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLibraries.
     */
    data: UserLibraryCreateManyInput | UserLibraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLibrary createManyAndReturn
   */
  export type UserLibraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * The data used to create many UserLibraries.
     */
    data: UserLibraryCreateManyInput | UserLibraryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLibrary update
   */
  export type UserLibraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLibrary.
     */
    data: XOR<UserLibraryUpdateInput, UserLibraryUncheckedUpdateInput>
    /**
     * Choose, which UserLibrary to update.
     */
    where: UserLibraryWhereUniqueInput
  }

  /**
   * UserLibrary updateMany
   */
  export type UserLibraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLibraries.
     */
    data: XOR<UserLibraryUpdateManyMutationInput, UserLibraryUncheckedUpdateManyInput>
    /**
     * Filter which UserLibraries to update
     */
    where?: UserLibraryWhereInput
    /**
     * Limit how many UserLibraries to update.
     */
    limit?: number
  }

  /**
   * UserLibrary updateManyAndReturn
   */
  export type UserLibraryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * The data used to update UserLibraries.
     */
    data: XOR<UserLibraryUpdateManyMutationInput, UserLibraryUncheckedUpdateManyInput>
    /**
     * Filter which UserLibraries to update
     */
    where?: UserLibraryWhereInput
    /**
     * Limit how many UserLibraries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLibrary upsert
   */
  export type UserLibraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLibrary to update in case it exists.
     */
    where: UserLibraryWhereUniqueInput
    /**
     * In case the UserLibrary found by the `where` argument doesn't exist, create a new UserLibrary with this data.
     */
    create: XOR<UserLibraryCreateInput, UserLibraryUncheckedCreateInput>
    /**
     * In case the UserLibrary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLibraryUpdateInput, UserLibraryUncheckedUpdateInput>
  }

  /**
   * UserLibrary delete
   */
  export type UserLibraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
    /**
     * Filter which UserLibrary to delete.
     */
    where: UserLibraryWhereUniqueInput
  }

  /**
   * UserLibrary deleteMany
   */
  export type UserLibraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLibraries to delete
     */
    where?: UserLibraryWhereInput
    /**
     * Limit how many UserLibraries to delete.
     */
    limit?: number
  }

  /**
   * UserLibrary without action
   */
  export type UserLibraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLibrary
     */
    select?: UserLibrarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLibrary
     */
    omit?: UserLibraryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLibraryInclude<ExtArgs> | null
  }


  /**
   * Model ListeningHistory
   */

  export type AggregateListeningHistory = {
    _count: ListeningHistoryCountAggregateOutputType | null
    _avg: ListeningHistoryAvgAggregateOutputType | null
    _sum: ListeningHistorySumAggregateOutputType | null
    _min: ListeningHistoryMinAggregateOutputType | null
    _max: ListeningHistoryMaxAggregateOutputType | null
  }

  export type ListeningHistoryAvgAggregateOutputType = {
    durationMs: number | null
  }

  export type ListeningHistorySumAggregateOutputType = {
    durationMs: number | null
  }

  export type ListeningHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    songId: string | null
    playedAt: Date | null
    durationMs: number | null
    contextType: $Enums.ContextType | null
    contextId: string | null
  }

  export type ListeningHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    songId: string | null
    playedAt: Date | null
    durationMs: number | null
    contextType: $Enums.ContextType | null
    contextId: string | null
  }

  export type ListeningHistoryCountAggregateOutputType = {
    id: number
    userId: number
    songId: number
    playedAt: number
    durationMs: number
    contextType: number
    contextId: number
    _all: number
  }


  export type ListeningHistoryAvgAggregateInputType = {
    durationMs?: true
  }

  export type ListeningHistorySumAggregateInputType = {
    durationMs?: true
  }

  export type ListeningHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    songId?: true
    playedAt?: true
    durationMs?: true
    contextType?: true
    contextId?: true
  }

  export type ListeningHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    songId?: true
    playedAt?: true
    durationMs?: true
    contextType?: true
    contextId?: true
  }

  export type ListeningHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    songId?: true
    playedAt?: true
    durationMs?: true
    contextType?: true
    contextId?: true
    _all?: true
  }

  export type ListeningHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListeningHistory to aggregate.
     */
    where?: ListeningHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningHistories to fetch.
     */
    orderBy?: ListeningHistoryOrderByWithRelationInput | ListeningHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListeningHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListeningHistories
    **/
    _count?: true | ListeningHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListeningHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListeningHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListeningHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListeningHistoryMaxAggregateInputType
  }

  export type GetListeningHistoryAggregateType<T extends ListeningHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateListeningHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListeningHistory[P]>
      : GetScalarType<T[P], AggregateListeningHistory[P]>
  }




  export type ListeningHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListeningHistoryWhereInput
    orderBy?: ListeningHistoryOrderByWithAggregationInput | ListeningHistoryOrderByWithAggregationInput[]
    by: ListeningHistoryScalarFieldEnum[] | ListeningHistoryScalarFieldEnum
    having?: ListeningHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListeningHistoryCountAggregateInputType | true
    _avg?: ListeningHistoryAvgAggregateInputType
    _sum?: ListeningHistorySumAggregateInputType
    _min?: ListeningHistoryMinAggregateInputType
    _max?: ListeningHistoryMaxAggregateInputType
  }

  export type ListeningHistoryGroupByOutputType = {
    id: string
    userId: string
    songId: string
    playedAt: Date
    durationMs: number
    contextType: $Enums.ContextType | null
    contextId: string | null
    _count: ListeningHistoryCountAggregateOutputType | null
    _avg: ListeningHistoryAvgAggregateOutputType | null
    _sum: ListeningHistorySumAggregateOutputType | null
    _min: ListeningHistoryMinAggregateOutputType | null
    _max: ListeningHistoryMaxAggregateOutputType | null
  }

  type GetListeningHistoryGroupByPayload<T extends ListeningHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListeningHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListeningHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListeningHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ListeningHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ListeningHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    songId?: boolean
    playedAt?: boolean
    durationMs?: boolean
    contextType?: boolean
    contextId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listeningHistory"]>

  export type ListeningHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    songId?: boolean
    playedAt?: boolean
    durationMs?: boolean
    contextType?: boolean
    contextId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listeningHistory"]>

  export type ListeningHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    songId?: boolean
    playedAt?: boolean
    durationMs?: boolean
    contextType?: boolean
    contextId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listeningHistory"]>

  export type ListeningHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    songId?: boolean
    playedAt?: boolean
    durationMs?: boolean
    contextType?: boolean
    contextId?: boolean
  }

  export type ListeningHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "songId" | "playedAt" | "durationMs" | "contextType" | "contextId", ExtArgs["result"]["listeningHistory"]>
  export type ListeningHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type ListeningHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type ListeningHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }

  export type $ListeningHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListeningHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      song: Prisma.$SongPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      songId: string
      playedAt: Date
      durationMs: number
      contextType: $Enums.ContextType | null
      contextId: string | null
    }, ExtArgs["result"]["listeningHistory"]>
    composites: {}
  }

  type ListeningHistoryGetPayload<S extends boolean | null | undefined | ListeningHistoryDefaultArgs> = $Result.GetResult<Prisma.$ListeningHistoryPayload, S>

  type ListeningHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListeningHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListeningHistoryCountAggregateInputType | true
    }

  export interface ListeningHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListeningHistory'], meta: { name: 'ListeningHistory' } }
    /**
     * Find zero or one ListeningHistory that matches the filter.
     * @param {ListeningHistoryFindUniqueArgs} args - Arguments to find a ListeningHistory
     * @example
     * // Get one ListeningHistory
     * const listeningHistory = await prisma.listeningHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListeningHistoryFindUniqueArgs>(args: SelectSubset<T, ListeningHistoryFindUniqueArgs<ExtArgs>>): Prisma__ListeningHistoryClient<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListeningHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListeningHistoryFindUniqueOrThrowArgs} args - Arguments to find a ListeningHistory
     * @example
     * // Get one ListeningHistory
     * const listeningHistory = await prisma.listeningHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListeningHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ListeningHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListeningHistoryClient<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListeningHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningHistoryFindFirstArgs} args - Arguments to find a ListeningHistory
     * @example
     * // Get one ListeningHistory
     * const listeningHistory = await prisma.listeningHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListeningHistoryFindFirstArgs>(args?: SelectSubset<T, ListeningHistoryFindFirstArgs<ExtArgs>>): Prisma__ListeningHistoryClient<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListeningHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningHistoryFindFirstOrThrowArgs} args - Arguments to find a ListeningHistory
     * @example
     * // Get one ListeningHistory
     * const listeningHistory = await prisma.listeningHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListeningHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ListeningHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListeningHistoryClient<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListeningHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListeningHistories
     * const listeningHistories = await prisma.listeningHistory.findMany()
     * 
     * // Get first 10 ListeningHistories
     * const listeningHistories = await prisma.listeningHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listeningHistoryWithIdOnly = await prisma.listeningHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListeningHistoryFindManyArgs>(args?: SelectSubset<T, ListeningHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListeningHistory.
     * @param {ListeningHistoryCreateArgs} args - Arguments to create a ListeningHistory.
     * @example
     * // Create one ListeningHistory
     * const ListeningHistory = await prisma.listeningHistory.create({
     *   data: {
     *     // ... data to create a ListeningHistory
     *   }
     * })
     * 
     */
    create<T extends ListeningHistoryCreateArgs>(args: SelectSubset<T, ListeningHistoryCreateArgs<ExtArgs>>): Prisma__ListeningHistoryClient<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListeningHistories.
     * @param {ListeningHistoryCreateManyArgs} args - Arguments to create many ListeningHistories.
     * @example
     * // Create many ListeningHistories
     * const listeningHistory = await prisma.listeningHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListeningHistoryCreateManyArgs>(args?: SelectSubset<T, ListeningHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListeningHistories and returns the data saved in the database.
     * @param {ListeningHistoryCreateManyAndReturnArgs} args - Arguments to create many ListeningHistories.
     * @example
     * // Create many ListeningHistories
     * const listeningHistory = await prisma.listeningHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListeningHistories and only return the `id`
     * const listeningHistoryWithIdOnly = await prisma.listeningHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListeningHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ListeningHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListeningHistory.
     * @param {ListeningHistoryDeleteArgs} args - Arguments to delete one ListeningHistory.
     * @example
     * // Delete one ListeningHistory
     * const ListeningHistory = await prisma.listeningHistory.delete({
     *   where: {
     *     // ... filter to delete one ListeningHistory
     *   }
     * })
     * 
     */
    delete<T extends ListeningHistoryDeleteArgs>(args: SelectSubset<T, ListeningHistoryDeleteArgs<ExtArgs>>): Prisma__ListeningHistoryClient<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListeningHistory.
     * @param {ListeningHistoryUpdateArgs} args - Arguments to update one ListeningHistory.
     * @example
     * // Update one ListeningHistory
     * const listeningHistory = await prisma.listeningHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListeningHistoryUpdateArgs>(args: SelectSubset<T, ListeningHistoryUpdateArgs<ExtArgs>>): Prisma__ListeningHistoryClient<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListeningHistories.
     * @param {ListeningHistoryDeleteManyArgs} args - Arguments to filter ListeningHistories to delete.
     * @example
     * // Delete a few ListeningHistories
     * const { count } = await prisma.listeningHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListeningHistoryDeleteManyArgs>(args?: SelectSubset<T, ListeningHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListeningHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListeningHistories
     * const listeningHistory = await prisma.listeningHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListeningHistoryUpdateManyArgs>(args: SelectSubset<T, ListeningHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListeningHistories and returns the data updated in the database.
     * @param {ListeningHistoryUpdateManyAndReturnArgs} args - Arguments to update many ListeningHistories.
     * @example
     * // Update many ListeningHistories
     * const listeningHistory = await prisma.listeningHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListeningHistories and only return the `id`
     * const listeningHistoryWithIdOnly = await prisma.listeningHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListeningHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ListeningHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListeningHistory.
     * @param {ListeningHistoryUpsertArgs} args - Arguments to update or create a ListeningHistory.
     * @example
     * // Update or create a ListeningHistory
     * const listeningHistory = await prisma.listeningHistory.upsert({
     *   create: {
     *     // ... data to create a ListeningHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListeningHistory we want to update
     *   }
     * })
     */
    upsert<T extends ListeningHistoryUpsertArgs>(args: SelectSubset<T, ListeningHistoryUpsertArgs<ExtArgs>>): Prisma__ListeningHistoryClient<$Result.GetResult<Prisma.$ListeningHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListeningHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningHistoryCountArgs} args - Arguments to filter ListeningHistories to count.
     * @example
     * // Count the number of ListeningHistories
     * const count = await prisma.listeningHistory.count({
     *   where: {
     *     // ... the filter for the ListeningHistories we want to count
     *   }
     * })
    **/
    count<T extends ListeningHistoryCountArgs>(
      args?: Subset<T, ListeningHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListeningHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListeningHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListeningHistoryAggregateArgs>(args: Subset<T, ListeningHistoryAggregateArgs>): Prisma.PrismaPromise<GetListeningHistoryAggregateType<T>>

    /**
     * Group by ListeningHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListeningHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListeningHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ListeningHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListeningHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListeningHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListeningHistory model
   */
  readonly fields: ListeningHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListeningHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListeningHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListeningHistory model
   */
  interface ListeningHistoryFieldRefs {
    readonly id: FieldRef<"ListeningHistory", 'String'>
    readonly userId: FieldRef<"ListeningHistory", 'String'>
    readonly songId: FieldRef<"ListeningHistory", 'String'>
    readonly playedAt: FieldRef<"ListeningHistory", 'DateTime'>
    readonly durationMs: FieldRef<"ListeningHistory", 'Int'>
    readonly contextType: FieldRef<"ListeningHistory", 'ContextType'>
    readonly contextId: FieldRef<"ListeningHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ListeningHistory findUnique
   */
  export type ListeningHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListeningHistory to fetch.
     */
    where: ListeningHistoryWhereUniqueInput
  }

  /**
   * ListeningHistory findUniqueOrThrow
   */
  export type ListeningHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListeningHistory to fetch.
     */
    where: ListeningHistoryWhereUniqueInput
  }

  /**
   * ListeningHistory findFirst
   */
  export type ListeningHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListeningHistory to fetch.
     */
    where?: ListeningHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningHistories to fetch.
     */
    orderBy?: ListeningHistoryOrderByWithRelationInput | ListeningHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListeningHistories.
     */
    cursor?: ListeningHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListeningHistories.
     */
    distinct?: ListeningHistoryScalarFieldEnum | ListeningHistoryScalarFieldEnum[]
  }

  /**
   * ListeningHistory findFirstOrThrow
   */
  export type ListeningHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListeningHistory to fetch.
     */
    where?: ListeningHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningHistories to fetch.
     */
    orderBy?: ListeningHistoryOrderByWithRelationInput | ListeningHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListeningHistories.
     */
    cursor?: ListeningHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListeningHistories.
     */
    distinct?: ListeningHistoryScalarFieldEnum | ListeningHistoryScalarFieldEnum[]
  }

  /**
   * ListeningHistory findMany
   */
  export type ListeningHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ListeningHistories to fetch.
     */
    where?: ListeningHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningHistories to fetch.
     */
    orderBy?: ListeningHistoryOrderByWithRelationInput | ListeningHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListeningHistories.
     */
    cursor?: ListeningHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningHistories.
     */
    skip?: number
    distinct?: ListeningHistoryScalarFieldEnum | ListeningHistoryScalarFieldEnum[]
  }

  /**
   * ListeningHistory create
   */
  export type ListeningHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ListeningHistory.
     */
    data: XOR<ListeningHistoryCreateInput, ListeningHistoryUncheckedCreateInput>
  }

  /**
   * ListeningHistory createMany
   */
  export type ListeningHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListeningHistories.
     */
    data: ListeningHistoryCreateManyInput | ListeningHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListeningHistory createManyAndReturn
   */
  export type ListeningHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ListeningHistories.
     */
    data: ListeningHistoryCreateManyInput | ListeningHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListeningHistory update
   */
  export type ListeningHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ListeningHistory.
     */
    data: XOR<ListeningHistoryUpdateInput, ListeningHistoryUncheckedUpdateInput>
    /**
     * Choose, which ListeningHistory to update.
     */
    where: ListeningHistoryWhereUniqueInput
  }

  /**
   * ListeningHistory updateMany
   */
  export type ListeningHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListeningHistories.
     */
    data: XOR<ListeningHistoryUpdateManyMutationInput, ListeningHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ListeningHistories to update
     */
    where?: ListeningHistoryWhereInput
    /**
     * Limit how many ListeningHistories to update.
     */
    limit?: number
  }

  /**
   * ListeningHistory updateManyAndReturn
   */
  export type ListeningHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ListeningHistories.
     */
    data: XOR<ListeningHistoryUpdateManyMutationInput, ListeningHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ListeningHistories to update
     */
    where?: ListeningHistoryWhereInput
    /**
     * Limit how many ListeningHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListeningHistory upsert
   */
  export type ListeningHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ListeningHistory to update in case it exists.
     */
    where: ListeningHistoryWhereUniqueInput
    /**
     * In case the ListeningHistory found by the `where` argument doesn't exist, create a new ListeningHistory with this data.
     */
    create: XOR<ListeningHistoryCreateInput, ListeningHistoryUncheckedCreateInput>
    /**
     * In case the ListeningHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListeningHistoryUpdateInput, ListeningHistoryUncheckedUpdateInput>
  }

  /**
   * ListeningHistory delete
   */
  export type ListeningHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
    /**
     * Filter which ListeningHistory to delete.
     */
    where: ListeningHistoryWhereUniqueInput
  }

  /**
   * ListeningHistory deleteMany
   */
  export type ListeningHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListeningHistories to delete
     */
    where?: ListeningHistoryWhereInput
    /**
     * Limit how many ListeningHistories to delete.
     */
    limit?: number
  }

  /**
   * ListeningHistory without action
   */
  export type ListeningHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningHistory
     */
    select?: ListeningHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListeningHistory
     */
    omit?: ListeningHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningHistoryInclude<ExtArgs> | null
  }


  /**
   * Model RecentlyPlayed
   */

  export type AggregateRecentlyPlayed = {
    _count: RecentlyPlayedCountAggregateOutputType | null
    _min: RecentlyPlayedMinAggregateOutputType | null
    _max: RecentlyPlayedMaxAggregateOutputType | null
  }

  export type RecentlyPlayedMinAggregateOutputType = {
    id: string | null
    userId: string | null
    songId: string | null
    playedAt: Date | null
    contextType: $Enums.ContextType | null
    contextId: string | null
  }

  export type RecentlyPlayedMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    songId: string | null
    playedAt: Date | null
    contextType: $Enums.ContextType | null
    contextId: string | null
  }

  export type RecentlyPlayedCountAggregateOutputType = {
    id: number
    userId: number
    songId: number
    playedAt: number
    contextType: number
    contextId: number
    _all: number
  }


  export type RecentlyPlayedMinAggregateInputType = {
    id?: true
    userId?: true
    songId?: true
    playedAt?: true
    contextType?: true
    contextId?: true
  }

  export type RecentlyPlayedMaxAggregateInputType = {
    id?: true
    userId?: true
    songId?: true
    playedAt?: true
    contextType?: true
    contextId?: true
  }

  export type RecentlyPlayedCountAggregateInputType = {
    id?: true
    userId?: true
    songId?: true
    playedAt?: true
    contextType?: true
    contextId?: true
    _all?: true
  }

  export type RecentlyPlayedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecentlyPlayed to aggregate.
     */
    where?: RecentlyPlayedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecentlyPlayeds to fetch.
     */
    orderBy?: RecentlyPlayedOrderByWithRelationInput | RecentlyPlayedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecentlyPlayedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecentlyPlayeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecentlyPlayeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecentlyPlayeds
    **/
    _count?: true | RecentlyPlayedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecentlyPlayedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecentlyPlayedMaxAggregateInputType
  }

  export type GetRecentlyPlayedAggregateType<T extends RecentlyPlayedAggregateArgs> = {
        [P in keyof T & keyof AggregateRecentlyPlayed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecentlyPlayed[P]>
      : GetScalarType<T[P], AggregateRecentlyPlayed[P]>
  }




  export type RecentlyPlayedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecentlyPlayedWhereInput
    orderBy?: RecentlyPlayedOrderByWithAggregationInput | RecentlyPlayedOrderByWithAggregationInput[]
    by: RecentlyPlayedScalarFieldEnum[] | RecentlyPlayedScalarFieldEnum
    having?: RecentlyPlayedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecentlyPlayedCountAggregateInputType | true
    _min?: RecentlyPlayedMinAggregateInputType
    _max?: RecentlyPlayedMaxAggregateInputType
  }

  export type RecentlyPlayedGroupByOutputType = {
    id: string
    userId: string
    songId: string
    playedAt: Date
    contextType: $Enums.ContextType | null
    contextId: string | null
    _count: RecentlyPlayedCountAggregateOutputType | null
    _min: RecentlyPlayedMinAggregateOutputType | null
    _max: RecentlyPlayedMaxAggregateOutputType | null
  }

  type GetRecentlyPlayedGroupByPayload<T extends RecentlyPlayedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecentlyPlayedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecentlyPlayedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecentlyPlayedGroupByOutputType[P]>
            : GetScalarType<T[P], RecentlyPlayedGroupByOutputType[P]>
        }
      >
    >


  export type RecentlyPlayedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    songId?: boolean
    playedAt?: boolean
    contextType?: boolean
    contextId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recentlyPlayed"]>

  export type RecentlyPlayedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    songId?: boolean
    playedAt?: boolean
    contextType?: boolean
    contextId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recentlyPlayed"]>

  export type RecentlyPlayedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    songId?: boolean
    playedAt?: boolean
    contextType?: boolean
    contextId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recentlyPlayed"]>

  export type RecentlyPlayedSelectScalar = {
    id?: boolean
    userId?: boolean
    songId?: boolean
    playedAt?: boolean
    contextType?: boolean
    contextId?: boolean
  }

  export type RecentlyPlayedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "songId" | "playedAt" | "contextType" | "contextId", ExtArgs["result"]["recentlyPlayed"]>
  export type RecentlyPlayedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type RecentlyPlayedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type RecentlyPlayedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }

  export type $RecentlyPlayedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecentlyPlayed"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      song: Prisma.$SongPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      songId: string
      playedAt: Date
      contextType: $Enums.ContextType | null
      contextId: string | null
    }, ExtArgs["result"]["recentlyPlayed"]>
    composites: {}
  }

  type RecentlyPlayedGetPayload<S extends boolean | null | undefined | RecentlyPlayedDefaultArgs> = $Result.GetResult<Prisma.$RecentlyPlayedPayload, S>

  type RecentlyPlayedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecentlyPlayedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecentlyPlayedCountAggregateInputType | true
    }

  export interface RecentlyPlayedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecentlyPlayed'], meta: { name: 'RecentlyPlayed' } }
    /**
     * Find zero or one RecentlyPlayed that matches the filter.
     * @param {RecentlyPlayedFindUniqueArgs} args - Arguments to find a RecentlyPlayed
     * @example
     * // Get one RecentlyPlayed
     * const recentlyPlayed = await prisma.recentlyPlayed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecentlyPlayedFindUniqueArgs>(args: SelectSubset<T, RecentlyPlayedFindUniqueArgs<ExtArgs>>): Prisma__RecentlyPlayedClient<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecentlyPlayed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecentlyPlayedFindUniqueOrThrowArgs} args - Arguments to find a RecentlyPlayed
     * @example
     * // Get one RecentlyPlayed
     * const recentlyPlayed = await prisma.recentlyPlayed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecentlyPlayedFindUniqueOrThrowArgs>(args: SelectSubset<T, RecentlyPlayedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecentlyPlayedClient<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecentlyPlayed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecentlyPlayedFindFirstArgs} args - Arguments to find a RecentlyPlayed
     * @example
     * // Get one RecentlyPlayed
     * const recentlyPlayed = await prisma.recentlyPlayed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecentlyPlayedFindFirstArgs>(args?: SelectSubset<T, RecentlyPlayedFindFirstArgs<ExtArgs>>): Prisma__RecentlyPlayedClient<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecentlyPlayed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecentlyPlayedFindFirstOrThrowArgs} args - Arguments to find a RecentlyPlayed
     * @example
     * // Get one RecentlyPlayed
     * const recentlyPlayed = await prisma.recentlyPlayed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecentlyPlayedFindFirstOrThrowArgs>(args?: SelectSubset<T, RecentlyPlayedFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecentlyPlayedClient<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecentlyPlayeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecentlyPlayedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecentlyPlayeds
     * const recentlyPlayeds = await prisma.recentlyPlayed.findMany()
     * 
     * // Get first 10 RecentlyPlayeds
     * const recentlyPlayeds = await prisma.recentlyPlayed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recentlyPlayedWithIdOnly = await prisma.recentlyPlayed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecentlyPlayedFindManyArgs>(args?: SelectSubset<T, RecentlyPlayedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecentlyPlayed.
     * @param {RecentlyPlayedCreateArgs} args - Arguments to create a RecentlyPlayed.
     * @example
     * // Create one RecentlyPlayed
     * const RecentlyPlayed = await prisma.recentlyPlayed.create({
     *   data: {
     *     // ... data to create a RecentlyPlayed
     *   }
     * })
     * 
     */
    create<T extends RecentlyPlayedCreateArgs>(args: SelectSubset<T, RecentlyPlayedCreateArgs<ExtArgs>>): Prisma__RecentlyPlayedClient<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecentlyPlayeds.
     * @param {RecentlyPlayedCreateManyArgs} args - Arguments to create many RecentlyPlayeds.
     * @example
     * // Create many RecentlyPlayeds
     * const recentlyPlayed = await prisma.recentlyPlayed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecentlyPlayedCreateManyArgs>(args?: SelectSubset<T, RecentlyPlayedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecentlyPlayeds and returns the data saved in the database.
     * @param {RecentlyPlayedCreateManyAndReturnArgs} args - Arguments to create many RecentlyPlayeds.
     * @example
     * // Create many RecentlyPlayeds
     * const recentlyPlayed = await prisma.recentlyPlayed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecentlyPlayeds and only return the `id`
     * const recentlyPlayedWithIdOnly = await prisma.recentlyPlayed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecentlyPlayedCreateManyAndReturnArgs>(args?: SelectSubset<T, RecentlyPlayedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecentlyPlayed.
     * @param {RecentlyPlayedDeleteArgs} args - Arguments to delete one RecentlyPlayed.
     * @example
     * // Delete one RecentlyPlayed
     * const RecentlyPlayed = await prisma.recentlyPlayed.delete({
     *   where: {
     *     // ... filter to delete one RecentlyPlayed
     *   }
     * })
     * 
     */
    delete<T extends RecentlyPlayedDeleteArgs>(args: SelectSubset<T, RecentlyPlayedDeleteArgs<ExtArgs>>): Prisma__RecentlyPlayedClient<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecentlyPlayed.
     * @param {RecentlyPlayedUpdateArgs} args - Arguments to update one RecentlyPlayed.
     * @example
     * // Update one RecentlyPlayed
     * const recentlyPlayed = await prisma.recentlyPlayed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecentlyPlayedUpdateArgs>(args: SelectSubset<T, RecentlyPlayedUpdateArgs<ExtArgs>>): Prisma__RecentlyPlayedClient<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecentlyPlayeds.
     * @param {RecentlyPlayedDeleteManyArgs} args - Arguments to filter RecentlyPlayeds to delete.
     * @example
     * // Delete a few RecentlyPlayeds
     * const { count } = await prisma.recentlyPlayed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecentlyPlayedDeleteManyArgs>(args?: SelectSubset<T, RecentlyPlayedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecentlyPlayeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecentlyPlayedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecentlyPlayeds
     * const recentlyPlayed = await prisma.recentlyPlayed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecentlyPlayedUpdateManyArgs>(args: SelectSubset<T, RecentlyPlayedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecentlyPlayeds and returns the data updated in the database.
     * @param {RecentlyPlayedUpdateManyAndReturnArgs} args - Arguments to update many RecentlyPlayeds.
     * @example
     * // Update many RecentlyPlayeds
     * const recentlyPlayed = await prisma.recentlyPlayed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecentlyPlayeds and only return the `id`
     * const recentlyPlayedWithIdOnly = await prisma.recentlyPlayed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecentlyPlayedUpdateManyAndReturnArgs>(args: SelectSubset<T, RecentlyPlayedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecentlyPlayed.
     * @param {RecentlyPlayedUpsertArgs} args - Arguments to update or create a RecentlyPlayed.
     * @example
     * // Update or create a RecentlyPlayed
     * const recentlyPlayed = await prisma.recentlyPlayed.upsert({
     *   create: {
     *     // ... data to create a RecentlyPlayed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecentlyPlayed we want to update
     *   }
     * })
     */
    upsert<T extends RecentlyPlayedUpsertArgs>(args: SelectSubset<T, RecentlyPlayedUpsertArgs<ExtArgs>>): Prisma__RecentlyPlayedClient<$Result.GetResult<Prisma.$RecentlyPlayedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecentlyPlayeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecentlyPlayedCountArgs} args - Arguments to filter RecentlyPlayeds to count.
     * @example
     * // Count the number of RecentlyPlayeds
     * const count = await prisma.recentlyPlayed.count({
     *   where: {
     *     // ... the filter for the RecentlyPlayeds we want to count
     *   }
     * })
    **/
    count<T extends RecentlyPlayedCountArgs>(
      args?: Subset<T, RecentlyPlayedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecentlyPlayedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecentlyPlayed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecentlyPlayedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecentlyPlayedAggregateArgs>(args: Subset<T, RecentlyPlayedAggregateArgs>): Prisma.PrismaPromise<GetRecentlyPlayedAggregateType<T>>

    /**
     * Group by RecentlyPlayed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecentlyPlayedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecentlyPlayedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecentlyPlayedGroupByArgs['orderBy'] }
        : { orderBy?: RecentlyPlayedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecentlyPlayedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecentlyPlayedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecentlyPlayed model
   */
  readonly fields: RecentlyPlayedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecentlyPlayed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecentlyPlayedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecentlyPlayed model
   */
  interface RecentlyPlayedFieldRefs {
    readonly id: FieldRef<"RecentlyPlayed", 'String'>
    readonly userId: FieldRef<"RecentlyPlayed", 'String'>
    readonly songId: FieldRef<"RecentlyPlayed", 'String'>
    readonly playedAt: FieldRef<"RecentlyPlayed", 'DateTime'>
    readonly contextType: FieldRef<"RecentlyPlayed", 'ContextType'>
    readonly contextId: FieldRef<"RecentlyPlayed", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecentlyPlayed findUnique
   */
  export type RecentlyPlayedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    /**
     * Filter, which RecentlyPlayed to fetch.
     */
    where: RecentlyPlayedWhereUniqueInput
  }

  /**
   * RecentlyPlayed findUniqueOrThrow
   */
  export type RecentlyPlayedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    /**
     * Filter, which RecentlyPlayed to fetch.
     */
    where: RecentlyPlayedWhereUniqueInput
  }

  /**
   * RecentlyPlayed findFirst
   */
  export type RecentlyPlayedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    /**
     * Filter, which RecentlyPlayed to fetch.
     */
    where?: RecentlyPlayedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecentlyPlayeds to fetch.
     */
    orderBy?: RecentlyPlayedOrderByWithRelationInput | RecentlyPlayedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecentlyPlayeds.
     */
    cursor?: RecentlyPlayedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecentlyPlayeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecentlyPlayeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecentlyPlayeds.
     */
    distinct?: RecentlyPlayedScalarFieldEnum | RecentlyPlayedScalarFieldEnum[]
  }

  /**
   * RecentlyPlayed findFirstOrThrow
   */
  export type RecentlyPlayedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    /**
     * Filter, which RecentlyPlayed to fetch.
     */
    where?: RecentlyPlayedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecentlyPlayeds to fetch.
     */
    orderBy?: RecentlyPlayedOrderByWithRelationInput | RecentlyPlayedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecentlyPlayeds.
     */
    cursor?: RecentlyPlayedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecentlyPlayeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecentlyPlayeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecentlyPlayeds.
     */
    distinct?: RecentlyPlayedScalarFieldEnum | RecentlyPlayedScalarFieldEnum[]
  }

  /**
   * RecentlyPlayed findMany
   */
  export type RecentlyPlayedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    /**
     * Filter, which RecentlyPlayeds to fetch.
     */
    where?: RecentlyPlayedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecentlyPlayeds to fetch.
     */
    orderBy?: RecentlyPlayedOrderByWithRelationInput | RecentlyPlayedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecentlyPlayeds.
     */
    cursor?: RecentlyPlayedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecentlyPlayeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecentlyPlayeds.
     */
    skip?: number
    distinct?: RecentlyPlayedScalarFieldEnum | RecentlyPlayedScalarFieldEnum[]
  }

  /**
   * RecentlyPlayed create
   */
  export type RecentlyPlayedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    /**
     * The data needed to create a RecentlyPlayed.
     */
    data: XOR<RecentlyPlayedCreateInput, RecentlyPlayedUncheckedCreateInput>
  }

  /**
   * RecentlyPlayed createMany
   */
  export type RecentlyPlayedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecentlyPlayeds.
     */
    data: RecentlyPlayedCreateManyInput | RecentlyPlayedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecentlyPlayed createManyAndReturn
   */
  export type RecentlyPlayedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * The data used to create many RecentlyPlayeds.
     */
    data: RecentlyPlayedCreateManyInput | RecentlyPlayedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecentlyPlayed update
   */
  export type RecentlyPlayedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    /**
     * The data needed to update a RecentlyPlayed.
     */
    data: XOR<RecentlyPlayedUpdateInput, RecentlyPlayedUncheckedUpdateInput>
    /**
     * Choose, which RecentlyPlayed to update.
     */
    where: RecentlyPlayedWhereUniqueInput
  }

  /**
   * RecentlyPlayed updateMany
   */
  export type RecentlyPlayedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecentlyPlayeds.
     */
    data: XOR<RecentlyPlayedUpdateManyMutationInput, RecentlyPlayedUncheckedUpdateManyInput>
    /**
     * Filter which RecentlyPlayeds to update
     */
    where?: RecentlyPlayedWhereInput
    /**
     * Limit how many RecentlyPlayeds to update.
     */
    limit?: number
  }

  /**
   * RecentlyPlayed updateManyAndReturn
   */
  export type RecentlyPlayedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * The data used to update RecentlyPlayeds.
     */
    data: XOR<RecentlyPlayedUpdateManyMutationInput, RecentlyPlayedUncheckedUpdateManyInput>
    /**
     * Filter which RecentlyPlayeds to update
     */
    where?: RecentlyPlayedWhereInput
    /**
     * Limit how many RecentlyPlayeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecentlyPlayed upsert
   */
  export type RecentlyPlayedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    /**
     * The filter to search for the RecentlyPlayed to update in case it exists.
     */
    where: RecentlyPlayedWhereUniqueInput
    /**
     * In case the RecentlyPlayed found by the `where` argument doesn't exist, create a new RecentlyPlayed with this data.
     */
    create: XOR<RecentlyPlayedCreateInput, RecentlyPlayedUncheckedCreateInput>
    /**
     * In case the RecentlyPlayed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecentlyPlayedUpdateInput, RecentlyPlayedUncheckedUpdateInput>
  }

  /**
   * RecentlyPlayed delete
   */
  export type RecentlyPlayedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
    /**
     * Filter which RecentlyPlayed to delete.
     */
    where: RecentlyPlayedWhereUniqueInput
  }

  /**
   * RecentlyPlayed deleteMany
   */
  export type RecentlyPlayedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecentlyPlayeds to delete
     */
    where?: RecentlyPlayedWhereInput
    /**
     * Limit how many RecentlyPlayeds to delete.
     */
    limit?: number
  }

  /**
   * RecentlyPlayed without action
   */
  export type RecentlyPlayedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecentlyPlayed
     */
    select?: RecentlyPlayedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecentlyPlayed
     */
    omit?: RecentlyPlayedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecentlyPlayedInclude<ExtArgs> | null
  }


  /**
   * Model PlaybackQueue
   */

  export type AggregatePlaybackQueue = {
    _count: PlaybackQueueCountAggregateOutputType | null
    _avg: PlaybackQueueAvgAggregateOutputType | null
    _sum: PlaybackQueueSumAggregateOutputType | null
    _min: PlaybackQueueMinAggregateOutputType | null
    _max: PlaybackQueueMaxAggregateOutputType | null
  }

  export type PlaybackQueueAvgAggregateOutputType = {
    position: number | null
  }

  export type PlaybackQueueSumAggregateOutputType = {
    position: number | null
  }

  export type PlaybackQueueMinAggregateOutputType = {
    id: string | null
    userId: string | null
    songId: string | null
    position: number | null
    addedAt: Date | null
  }

  export type PlaybackQueueMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    songId: string | null
    position: number | null
    addedAt: Date | null
  }

  export type PlaybackQueueCountAggregateOutputType = {
    id: number
    userId: number
    songId: number
    position: number
    addedAt: number
    _all: number
  }


  export type PlaybackQueueAvgAggregateInputType = {
    position?: true
  }

  export type PlaybackQueueSumAggregateInputType = {
    position?: true
  }

  export type PlaybackQueueMinAggregateInputType = {
    id?: true
    userId?: true
    songId?: true
    position?: true
    addedAt?: true
  }

  export type PlaybackQueueMaxAggregateInputType = {
    id?: true
    userId?: true
    songId?: true
    position?: true
    addedAt?: true
  }

  export type PlaybackQueueCountAggregateInputType = {
    id?: true
    userId?: true
    songId?: true
    position?: true
    addedAt?: true
    _all?: true
  }

  export type PlaybackQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaybackQueue to aggregate.
     */
    where?: PlaybackQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaybackQueues to fetch.
     */
    orderBy?: PlaybackQueueOrderByWithRelationInput | PlaybackQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaybackQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaybackQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaybackQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaybackQueues
    **/
    _count?: true | PlaybackQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaybackQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaybackQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaybackQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaybackQueueMaxAggregateInputType
  }

  export type GetPlaybackQueueAggregateType<T extends PlaybackQueueAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaybackQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaybackQueue[P]>
      : GetScalarType<T[P], AggregatePlaybackQueue[P]>
  }




  export type PlaybackQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaybackQueueWhereInput
    orderBy?: PlaybackQueueOrderByWithAggregationInput | PlaybackQueueOrderByWithAggregationInput[]
    by: PlaybackQueueScalarFieldEnum[] | PlaybackQueueScalarFieldEnum
    having?: PlaybackQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaybackQueueCountAggregateInputType | true
    _avg?: PlaybackQueueAvgAggregateInputType
    _sum?: PlaybackQueueSumAggregateInputType
    _min?: PlaybackQueueMinAggregateInputType
    _max?: PlaybackQueueMaxAggregateInputType
  }

  export type PlaybackQueueGroupByOutputType = {
    id: string
    userId: string
    songId: string
    position: number
    addedAt: Date
    _count: PlaybackQueueCountAggregateOutputType | null
    _avg: PlaybackQueueAvgAggregateOutputType | null
    _sum: PlaybackQueueSumAggregateOutputType | null
    _min: PlaybackQueueMinAggregateOutputType | null
    _max: PlaybackQueueMaxAggregateOutputType | null
  }

  type GetPlaybackQueueGroupByPayload<T extends PlaybackQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaybackQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaybackQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaybackQueueGroupByOutputType[P]>
            : GetScalarType<T[P], PlaybackQueueGroupByOutputType[P]>
        }
      >
    >


  export type PlaybackQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    songId?: boolean
    position?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playbackQueue"]>

  export type PlaybackQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    songId?: boolean
    position?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playbackQueue"]>

  export type PlaybackQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    songId?: boolean
    position?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playbackQueue"]>

  export type PlaybackQueueSelectScalar = {
    id?: boolean
    userId?: boolean
    songId?: boolean
    position?: boolean
    addedAt?: boolean
  }

  export type PlaybackQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "songId" | "position" | "addedAt", ExtArgs["result"]["playbackQueue"]>
  export type PlaybackQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type PlaybackQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }
  export type PlaybackQueueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    song?: boolean | SongDefaultArgs<ExtArgs>
  }

  export type $PlaybackQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaybackQueue"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      song: Prisma.$SongPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      songId: string
      position: number
      addedAt: Date
    }, ExtArgs["result"]["playbackQueue"]>
    composites: {}
  }

  type PlaybackQueueGetPayload<S extends boolean | null | undefined | PlaybackQueueDefaultArgs> = $Result.GetResult<Prisma.$PlaybackQueuePayload, S>

  type PlaybackQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaybackQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaybackQueueCountAggregateInputType | true
    }

  export interface PlaybackQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaybackQueue'], meta: { name: 'PlaybackQueue' } }
    /**
     * Find zero or one PlaybackQueue that matches the filter.
     * @param {PlaybackQueueFindUniqueArgs} args - Arguments to find a PlaybackQueue
     * @example
     * // Get one PlaybackQueue
     * const playbackQueue = await prisma.playbackQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaybackQueueFindUniqueArgs>(args: SelectSubset<T, PlaybackQueueFindUniqueArgs<ExtArgs>>): Prisma__PlaybackQueueClient<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaybackQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaybackQueueFindUniqueOrThrowArgs} args - Arguments to find a PlaybackQueue
     * @example
     * // Get one PlaybackQueue
     * const playbackQueue = await prisma.playbackQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaybackQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaybackQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaybackQueueClient<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaybackQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackQueueFindFirstArgs} args - Arguments to find a PlaybackQueue
     * @example
     * // Get one PlaybackQueue
     * const playbackQueue = await prisma.playbackQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaybackQueueFindFirstArgs>(args?: SelectSubset<T, PlaybackQueueFindFirstArgs<ExtArgs>>): Prisma__PlaybackQueueClient<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaybackQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackQueueFindFirstOrThrowArgs} args - Arguments to find a PlaybackQueue
     * @example
     * // Get one PlaybackQueue
     * const playbackQueue = await prisma.playbackQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaybackQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaybackQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaybackQueueClient<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaybackQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaybackQueues
     * const playbackQueues = await prisma.playbackQueue.findMany()
     * 
     * // Get first 10 PlaybackQueues
     * const playbackQueues = await prisma.playbackQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playbackQueueWithIdOnly = await prisma.playbackQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaybackQueueFindManyArgs>(args?: SelectSubset<T, PlaybackQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaybackQueue.
     * @param {PlaybackQueueCreateArgs} args - Arguments to create a PlaybackQueue.
     * @example
     * // Create one PlaybackQueue
     * const PlaybackQueue = await prisma.playbackQueue.create({
     *   data: {
     *     // ... data to create a PlaybackQueue
     *   }
     * })
     * 
     */
    create<T extends PlaybackQueueCreateArgs>(args: SelectSubset<T, PlaybackQueueCreateArgs<ExtArgs>>): Prisma__PlaybackQueueClient<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaybackQueues.
     * @param {PlaybackQueueCreateManyArgs} args - Arguments to create many PlaybackQueues.
     * @example
     * // Create many PlaybackQueues
     * const playbackQueue = await prisma.playbackQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaybackQueueCreateManyArgs>(args?: SelectSubset<T, PlaybackQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaybackQueues and returns the data saved in the database.
     * @param {PlaybackQueueCreateManyAndReturnArgs} args - Arguments to create many PlaybackQueues.
     * @example
     * // Create many PlaybackQueues
     * const playbackQueue = await prisma.playbackQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaybackQueues and only return the `id`
     * const playbackQueueWithIdOnly = await prisma.playbackQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaybackQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaybackQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaybackQueue.
     * @param {PlaybackQueueDeleteArgs} args - Arguments to delete one PlaybackQueue.
     * @example
     * // Delete one PlaybackQueue
     * const PlaybackQueue = await prisma.playbackQueue.delete({
     *   where: {
     *     // ... filter to delete one PlaybackQueue
     *   }
     * })
     * 
     */
    delete<T extends PlaybackQueueDeleteArgs>(args: SelectSubset<T, PlaybackQueueDeleteArgs<ExtArgs>>): Prisma__PlaybackQueueClient<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaybackQueue.
     * @param {PlaybackQueueUpdateArgs} args - Arguments to update one PlaybackQueue.
     * @example
     * // Update one PlaybackQueue
     * const playbackQueue = await prisma.playbackQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaybackQueueUpdateArgs>(args: SelectSubset<T, PlaybackQueueUpdateArgs<ExtArgs>>): Prisma__PlaybackQueueClient<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaybackQueues.
     * @param {PlaybackQueueDeleteManyArgs} args - Arguments to filter PlaybackQueues to delete.
     * @example
     * // Delete a few PlaybackQueues
     * const { count } = await prisma.playbackQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaybackQueueDeleteManyArgs>(args?: SelectSubset<T, PlaybackQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaybackQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaybackQueues
     * const playbackQueue = await prisma.playbackQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaybackQueueUpdateManyArgs>(args: SelectSubset<T, PlaybackQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaybackQueues and returns the data updated in the database.
     * @param {PlaybackQueueUpdateManyAndReturnArgs} args - Arguments to update many PlaybackQueues.
     * @example
     * // Update many PlaybackQueues
     * const playbackQueue = await prisma.playbackQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaybackQueues and only return the `id`
     * const playbackQueueWithIdOnly = await prisma.playbackQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaybackQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaybackQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaybackQueue.
     * @param {PlaybackQueueUpsertArgs} args - Arguments to update or create a PlaybackQueue.
     * @example
     * // Update or create a PlaybackQueue
     * const playbackQueue = await prisma.playbackQueue.upsert({
     *   create: {
     *     // ... data to create a PlaybackQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaybackQueue we want to update
     *   }
     * })
     */
    upsert<T extends PlaybackQueueUpsertArgs>(args: SelectSubset<T, PlaybackQueueUpsertArgs<ExtArgs>>): Prisma__PlaybackQueueClient<$Result.GetResult<Prisma.$PlaybackQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaybackQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackQueueCountArgs} args - Arguments to filter PlaybackQueues to count.
     * @example
     * // Count the number of PlaybackQueues
     * const count = await prisma.playbackQueue.count({
     *   where: {
     *     // ... the filter for the PlaybackQueues we want to count
     *   }
     * })
    **/
    count<T extends PlaybackQueueCountArgs>(
      args?: Subset<T, PlaybackQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaybackQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaybackQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaybackQueueAggregateArgs>(args: Subset<T, PlaybackQueueAggregateArgs>): Prisma.PrismaPromise<GetPlaybackQueueAggregateType<T>>

    /**
     * Group by PlaybackQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaybackQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaybackQueueGroupByArgs['orderBy'] }
        : { orderBy?: PlaybackQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaybackQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaybackQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaybackQueue model
   */
  readonly fields: PlaybackQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaybackQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaybackQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    song<T extends SongDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SongDefaultArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaybackQueue model
   */
  interface PlaybackQueueFieldRefs {
    readonly id: FieldRef<"PlaybackQueue", 'String'>
    readonly userId: FieldRef<"PlaybackQueue", 'String'>
    readonly songId: FieldRef<"PlaybackQueue", 'String'>
    readonly position: FieldRef<"PlaybackQueue", 'Int'>
    readonly addedAt: FieldRef<"PlaybackQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlaybackQueue findUnique
   */
  export type PlaybackQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackQueue to fetch.
     */
    where: PlaybackQueueWhereUniqueInput
  }

  /**
   * PlaybackQueue findUniqueOrThrow
   */
  export type PlaybackQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackQueue to fetch.
     */
    where: PlaybackQueueWhereUniqueInput
  }

  /**
   * PlaybackQueue findFirst
   */
  export type PlaybackQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackQueue to fetch.
     */
    where?: PlaybackQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaybackQueues to fetch.
     */
    orderBy?: PlaybackQueueOrderByWithRelationInput | PlaybackQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaybackQueues.
     */
    cursor?: PlaybackQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaybackQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaybackQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaybackQueues.
     */
    distinct?: PlaybackQueueScalarFieldEnum | PlaybackQueueScalarFieldEnum[]
  }

  /**
   * PlaybackQueue findFirstOrThrow
   */
  export type PlaybackQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackQueue to fetch.
     */
    where?: PlaybackQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaybackQueues to fetch.
     */
    orderBy?: PlaybackQueueOrderByWithRelationInput | PlaybackQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaybackQueues.
     */
    cursor?: PlaybackQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaybackQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaybackQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaybackQueues.
     */
    distinct?: PlaybackQueueScalarFieldEnum | PlaybackQueueScalarFieldEnum[]
  }

  /**
   * PlaybackQueue findMany
   */
  export type PlaybackQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackQueues to fetch.
     */
    where?: PlaybackQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaybackQueues to fetch.
     */
    orderBy?: PlaybackQueueOrderByWithRelationInput | PlaybackQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaybackQueues.
     */
    cursor?: PlaybackQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaybackQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaybackQueues.
     */
    skip?: number
    distinct?: PlaybackQueueScalarFieldEnum | PlaybackQueueScalarFieldEnum[]
  }

  /**
   * PlaybackQueue create
   */
  export type PlaybackQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaybackQueue.
     */
    data: XOR<PlaybackQueueCreateInput, PlaybackQueueUncheckedCreateInput>
  }

  /**
   * PlaybackQueue createMany
   */
  export type PlaybackQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaybackQueues.
     */
    data: PlaybackQueueCreateManyInput | PlaybackQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaybackQueue createManyAndReturn
   */
  export type PlaybackQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * The data used to create many PlaybackQueues.
     */
    data: PlaybackQueueCreateManyInput | PlaybackQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaybackQueue update
   */
  export type PlaybackQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaybackQueue.
     */
    data: XOR<PlaybackQueueUpdateInput, PlaybackQueueUncheckedUpdateInput>
    /**
     * Choose, which PlaybackQueue to update.
     */
    where: PlaybackQueueWhereUniqueInput
  }

  /**
   * PlaybackQueue updateMany
   */
  export type PlaybackQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaybackQueues.
     */
    data: XOR<PlaybackQueueUpdateManyMutationInput, PlaybackQueueUncheckedUpdateManyInput>
    /**
     * Filter which PlaybackQueues to update
     */
    where?: PlaybackQueueWhereInput
    /**
     * Limit how many PlaybackQueues to update.
     */
    limit?: number
  }

  /**
   * PlaybackQueue updateManyAndReturn
   */
  export type PlaybackQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * The data used to update PlaybackQueues.
     */
    data: XOR<PlaybackQueueUpdateManyMutationInput, PlaybackQueueUncheckedUpdateManyInput>
    /**
     * Filter which PlaybackQueues to update
     */
    where?: PlaybackQueueWhereInput
    /**
     * Limit how many PlaybackQueues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaybackQueue upsert
   */
  export type PlaybackQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaybackQueue to update in case it exists.
     */
    where: PlaybackQueueWhereUniqueInput
    /**
     * In case the PlaybackQueue found by the `where` argument doesn't exist, create a new PlaybackQueue with this data.
     */
    create: XOR<PlaybackQueueCreateInput, PlaybackQueueUncheckedCreateInput>
    /**
     * In case the PlaybackQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaybackQueueUpdateInput, PlaybackQueueUncheckedUpdateInput>
  }

  /**
   * PlaybackQueue delete
   */
  export type PlaybackQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
    /**
     * Filter which PlaybackQueue to delete.
     */
    where: PlaybackQueueWhereUniqueInput
  }

  /**
   * PlaybackQueue deleteMany
   */
  export type PlaybackQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaybackQueues to delete
     */
    where?: PlaybackQueueWhereInput
    /**
     * Limit how many PlaybackQueues to delete.
     */
    limit?: number
  }

  /**
   * PlaybackQueue without action
   */
  export type PlaybackQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackQueue
     */
    select?: PlaybackQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackQueue
     */
    omit?: PlaybackQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackQueueInclude<ExtArgs> | null
  }


  /**
   * Model PlaybackState
   */

  export type AggregatePlaybackState = {
    _count: PlaybackStateCountAggregateOutputType | null
    _avg: PlaybackStateAvgAggregateOutputType | null
    _sum: PlaybackStateSumAggregateOutputType | null
    _min: PlaybackStateMinAggregateOutputType | null
    _max: PlaybackStateMaxAggregateOutputType | null
  }

  export type PlaybackStateAvgAggregateOutputType = {
    progressMs: number | null
    volume: number | null
  }

  export type PlaybackStateSumAggregateOutputType = {
    progressMs: number | null
    volume: number | null
  }

  export type PlaybackStateMinAggregateOutputType = {
    userId: string | null
    currentSongId: string | null
    progressMs: number | null
    isPlaying: boolean | null
    shuffleMode: $Enums.ShuffleMode | null
    repeatMode: $Enums.RepeatMode | null
    volume: number | null
    contextType: $Enums.ContextType | null
    contextId: string | null
    activeDeviceId: string | null
    updatedAt: Date | null
  }

  export type PlaybackStateMaxAggregateOutputType = {
    userId: string | null
    currentSongId: string | null
    progressMs: number | null
    isPlaying: boolean | null
    shuffleMode: $Enums.ShuffleMode | null
    repeatMode: $Enums.RepeatMode | null
    volume: number | null
    contextType: $Enums.ContextType | null
    contextId: string | null
    activeDeviceId: string | null
    updatedAt: Date | null
  }

  export type PlaybackStateCountAggregateOutputType = {
    userId: number
    currentSongId: number
    progressMs: number
    isPlaying: number
    shuffleMode: number
    repeatMode: number
    volume: number
    contextType: number
    contextId: number
    activeDeviceId: number
    updatedAt: number
    _all: number
  }


  export type PlaybackStateAvgAggregateInputType = {
    progressMs?: true
    volume?: true
  }

  export type PlaybackStateSumAggregateInputType = {
    progressMs?: true
    volume?: true
  }

  export type PlaybackStateMinAggregateInputType = {
    userId?: true
    currentSongId?: true
    progressMs?: true
    isPlaying?: true
    shuffleMode?: true
    repeatMode?: true
    volume?: true
    contextType?: true
    contextId?: true
    activeDeviceId?: true
    updatedAt?: true
  }

  export type PlaybackStateMaxAggregateInputType = {
    userId?: true
    currentSongId?: true
    progressMs?: true
    isPlaying?: true
    shuffleMode?: true
    repeatMode?: true
    volume?: true
    contextType?: true
    contextId?: true
    activeDeviceId?: true
    updatedAt?: true
  }

  export type PlaybackStateCountAggregateInputType = {
    userId?: true
    currentSongId?: true
    progressMs?: true
    isPlaying?: true
    shuffleMode?: true
    repeatMode?: true
    volume?: true
    contextType?: true
    contextId?: true
    activeDeviceId?: true
    updatedAt?: true
    _all?: true
  }

  export type PlaybackStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaybackState to aggregate.
     */
    where?: PlaybackStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaybackStates to fetch.
     */
    orderBy?: PlaybackStateOrderByWithRelationInput | PlaybackStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaybackStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaybackStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaybackStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaybackStates
    **/
    _count?: true | PlaybackStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaybackStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaybackStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaybackStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaybackStateMaxAggregateInputType
  }

  export type GetPlaybackStateAggregateType<T extends PlaybackStateAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaybackState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaybackState[P]>
      : GetScalarType<T[P], AggregatePlaybackState[P]>
  }




  export type PlaybackStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaybackStateWhereInput
    orderBy?: PlaybackStateOrderByWithAggregationInput | PlaybackStateOrderByWithAggregationInput[]
    by: PlaybackStateScalarFieldEnum[] | PlaybackStateScalarFieldEnum
    having?: PlaybackStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaybackStateCountAggregateInputType | true
    _avg?: PlaybackStateAvgAggregateInputType
    _sum?: PlaybackStateSumAggregateInputType
    _min?: PlaybackStateMinAggregateInputType
    _max?: PlaybackStateMaxAggregateInputType
  }

  export type PlaybackStateGroupByOutputType = {
    userId: string
    currentSongId: string | null
    progressMs: number
    isPlaying: boolean
    shuffleMode: $Enums.ShuffleMode
    repeatMode: $Enums.RepeatMode
    volume: number
    contextType: $Enums.ContextType | null
    contextId: string | null
    activeDeviceId: string | null
    updatedAt: Date
    _count: PlaybackStateCountAggregateOutputType | null
    _avg: PlaybackStateAvgAggregateOutputType | null
    _sum: PlaybackStateSumAggregateOutputType | null
    _min: PlaybackStateMinAggregateOutputType | null
    _max: PlaybackStateMaxAggregateOutputType | null
  }

  type GetPlaybackStateGroupByPayload<T extends PlaybackStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaybackStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaybackStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaybackStateGroupByOutputType[P]>
            : GetScalarType<T[P], PlaybackStateGroupByOutputType[P]>
        }
      >
    >


  export type PlaybackStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    currentSongId?: boolean
    progressMs?: boolean
    isPlaying?: boolean
    shuffleMode?: boolean
    repeatMode?: boolean
    volume?: boolean
    contextType?: boolean
    contextId?: boolean
    activeDeviceId?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentSong?: boolean | PlaybackState$currentSongArgs<ExtArgs>
    activeDevice?: boolean | PlaybackState$activeDeviceArgs<ExtArgs>
  }, ExtArgs["result"]["playbackState"]>

  export type PlaybackStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    currentSongId?: boolean
    progressMs?: boolean
    isPlaying?: boolean
    shuffleMode?: boolean
    repeatMode?: boolean
    volume?: boolean
    contextType?: boolean
    contextId?: boolean
    activeDeviceId?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentSong?: boolean | PlaybackState$currentSongArgs<ExtArgs>
    activeDevice?: boolean | PlaybackState$activeDeviceArgs<ExtArgs>
  }, ExtArgs["result"]["playbackState"]>

  export type PlaybackStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    currentSongId?: boolean
    progressMs?: boolean
    isPlaying?: boolean
    shuffleMode?: boolean
    repeatMode?: boolean
    volume?: boolean
    contextType?: boolean
    contextId?: boolean
    activeDeviceId?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentSong?: boolean | PlaybackState$currentSongArgs<ExtArgs>
    activeDevice?: boolean | PlaybackState$activeDeviceArgs<ExtArgs>
  }, ExtArgs["result"]["playbackState"]>

  export type PlaybackStateSelectScalar = {
    userId?: boolean
    currentSongId?: boolean
    progressMs?: boolean
    isPlaying?: boolean
    shuffleMode?: boolean
    repeatMode?: boolean
    volume?: boolean
    contextType?: boolean
    contextId?: boolean
    activeDeviceId?: boolean
    updatedAt?: boolean
  }

  export type PlaybackStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "currentSongId" | "progressMs" | "isPlaying" | "shuffleMode" | "repeatMode" | "volume" | "contextType" | "contextId" | "activeDeviceId" | "updatedAt", ExtArgs["result"]["playbackState"]>
  export type PlaybackStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentSong?: boolean | PlaybackState$currentSongArgs<ExtArgs>
    activeDevice?: boolean | PlaybackState$activeDeviceArgs<ExtArgs>
  }
  export type PlaybackStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentSong?: boolean | PlaybackState$currentSongArgs<ExtArgs>
    activeDevice?: boolean | PlaybackState$activeDeviceArgs<ExtArgs>
  }
  export type PlaybackStateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    currentSong?: boolean | PlaybackState$currentSongArgs<ExtArgs>
    activeDevice?: boolean | PlaybackState$activeDeviceArgs<ExtArgs>
  }

  export type $PlaybackStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaybackState"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      currentSong: Prisma.$SongPayload<ExtArgs> | null
      activeDevice: Prisma.$UserDevicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      currentSongId: string | null
      progressMs: number
      isPlaying: boolean
      shuffleMode: $Enums.ShuffleMode
      repeatMode: $Enums.RepeatMode
      volume: number
      contextType: $Enums.ContextType | null
      contextId: string | null
      activeDeviceId: string | null
      updatedAt: Date
    }, ExtArgs["result"]["playbackState"]>
    composites: {}
  }

  type PlaybackStateGetPayload<S extends boolean | null | undefined | PlaybackStateDefaultArgs> = $Result.GetResult<Prisma.$PlaybackStatePayload, S>

  type PlaybackStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaybackStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaybackStateCountAggregateInputType | true
    }

  export interface PlaybackStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaybackState'], meta: { name: 'PlaybackState' } }
    /**
     * Find zero or one PlaybackState that matches the filter.
     * @param {PlaybackStateFindUniqueArgs} args - Arguments to find a PlaybackState
     * @example
     * // Get one PlaybackState
     * const playbackState = await prisma.playbackState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaybackStateFindUniqueArgs>(args: SelectSubset<T, PlaybackStateFindUniqueArgs<ExtArgs>>): Prisma__PlaybackStateClient<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaybackState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaybackStateFindUniqueOrThrowArgs} args - Arguments to find a PlaybackState
     * @example
     * // Get one PlaybackState
     * const playbackState = await prisma.playbackState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaybackStateFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaybackStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaybackStateClient<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaybackState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackStateFindFirstArgs} args - Arguments to find a PlaybackState
     * @example
     * // Get one PlaybackState
     * const playbackState = await prisma.playbackState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaybackStateFindFirstArgs>(args?: SelectSubset<T, PlaybackStateFindFirstArgs<ExtArgs>>): Prisma__PlaybackStateClient<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaybackState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackStateFindFirstOrThrowArgs} args - Arguments to find a PlaybackState
     * @example
     * // Get one PlaybackState
     * const playbackState = await prisma.playbackState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaybackStateFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaybackStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaybackStateClient<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaybackStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaybackStates
     * const playbackStates = await prisma.playbackState.findMany()
     * 
     * // Get first 10 PlaybackStates
     * const playbackStates = await prisma.playbackState.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const playbackStateWithUserIdOnly = await prisma.playbackState.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends PlaybackStateFindManyArgs>(args?: SelectSubset<T, PlaybackStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaybackState.
     * @param {PlaybackStateCreateArgs} args - Arguments to create a PlaybackState.
     * @example
     * // Create one PlaybackState
     * const PlaybackState = await prisma.playbackState.create({
     *   data: {
     *     // ... data to create a PlaybackState
     *   }
     * })
     * 
     */
    create<T extends PlaybackStateCreateArgs>(args: SelectSubset<T, PlaybackStateCreateArgs<ExtArgs>>): Prisma__PlaybackStateClient<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaybackStates.
     * @param {PlaybackStateCreateManyArgs} args - Arguments to create many PlaybackStates.
     * @example
     * // Create many PlaybackStates
     * const playbackState = await prisma.playbackState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaybackStateCreateManyArgs>(args?: SelectSubset<T, PlaybackStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaybackStates and returns the data saved in the database.
     * @param {PlaybackStateCreateManyAndReturnArgs} args - Arguments to create many PlaybackStates.
     * @example
     * // Create many PlaybackStates
     * const playbackState = await prisma.playbackState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaybackStates and only return the `userId`
     * const playbackStateWithUserIdOnly = await prisma.playbackState.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaybackStateCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaybackStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaybackState.
     * @param {PlaybackStateDeleteArgs} args - Arguments to delete one PlaybackState.
     * @example
     * // Delete one PlaybackState
     * const PlaybackState = await prisma.playbackState.delete({
     *   where: {
     *     // ... filter to delete one PlaybackState
     *   }
     * })
     * 
     */
    delete<T extends PlaybackStateDeleteArgs>(args: SelectSubset<T, PlaybackStateDeleteArgs<ExtArgs>>): Prisma__PlaybackStateClient<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaybackState.
     * @param {PlaybackStateUpdateArgs} args - Arguments to update one PlaybackState.
     * @example
     * // Update one PlaybackState
     * const playbackState = await prisma.playbackState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaybackStateUpdateArgs>(args: SelectSubset<T, PlaybackStateUpdateArgs<ExtArgs>>): Prisma__PlaybackStateClient<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaybackStates.
     * @param {PlaybackStateDeleteManyArgs} args - Arguments to filter PlaybackStates to delete.
     * @example
     * // Delete a few PlaybackStates
     * const { count } = await prisma.playbackState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaybackStateDeleteManyArgs>(args?: SelectSubset<T, PlaybackStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaybackStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaybackStates
     * const playbackState = await prisma.playbackState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaybackStateUpdateManyArgs>(args: SelectSubset<T, PlaybackStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaybackStates and returns the data updated in the database.
     * @param {PlaybackStateUpdateManyAndReturnArgs} args - Arguments to update many PlaybackStates.
     * @example
     * // Update many PlaybackStates
     * const playbackState = await prisma.playbackState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaybackStates and only return the `userId`
     * const playbackStateWithUserIdOnly = await prisma.playbackState.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaybackStateUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaybackStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaybackState.
     * @param {PlaybackStateUpsertArgs} args - Arguments to update or create a PlaybackState.
     * @example
     * // Update or create a PlaybackState
     * const playbackState = await prisma.playbackState.upsert({
     *   create: {
     *     // ... data to create a PlaybackState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaybackState we want to update
     *   }
     * })
     */
    upsert<T extends PlaybackStateUpsertArgs>(args: SelectSubset<T, PlaybackStateUpsertArgs<ExtArgs>>): Prisma__PlaybackStateClient<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaybackStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackStateCountArgs} args - Arguments to filter PlaybackStates to count.
     * @example
     * // Count the number of PlaybackStates
     * const count = await prisma.playbackState.count({
     *   where: {
     *     // ... the filter for the PlaybackStates we want to count
     *   }
     * })
    **/
    count<T extends PlaybackStateCountArgs>(
      args?: Subset<T, PlaybackStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaybackStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaybackState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaybackStateAggregateArgs>(args: Subset<T, PlaybackStateAggregateArgs>): Prisma.PrismaPromise<GetPlaybackStateAggregateType<T>>

    /**
     * Group by PlaybackState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaybackStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaybackStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaybackStateGroupByArgs['orderBy'] }
        : { orderBy?: PlaybackStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaybackStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaybackStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaybackState model
   */
  readonly fields: PlaybackStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaybackState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaybackStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currentSong<T extends PlaybackState$currentSongArgs<ExtArgs> = {}>(args?: Subset<T, PlaybackState$currentSongArgs<ExtArgs>>): Prisma__SongClient<$Result.GetResult<Prisma.$SongPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activeDevice<T extends PlaybackState$activeDeviceArgs<ExtArgs> = {}>(args?: Subset<T, PlaybackState$activeDeviceArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaybackState model
   */
  interface PlaybackStateFieldRefs {
    readonly userId: FieldRef<"PlaybackState", 'String'>
    readonly currentSongId: FieldRef<"PlaybackState", 'String'>
    readonly progressMs: FieldRef<"PlaybackState", 'Int'>
    readonly isPlaying: FieldRef<"PlaybackState", 'Boolean'>
    readonly shuffleMode: FieldRef<"PlaybackState", 'ShuffleMode'>
    readonly repeatMode: FieldRef<"PlaybackState", 'RepeatMode'>
    readonly volume: FieldRef<"PlaybackState", 'Int'>
    readonly contextType: FieldRef<"PlaybackState", 'ContextType'>
    readonly contextId: FieldRef<"PlaybackState", 'String'>
    readonly activeDeviceId: FieldRef<"PlaybackState", 'String'>
    readonly updatedAt: FieldRef<"PlaybackState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlaybackState findUnique
   */
  export type PlaybackStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackState to fetch.
     */
    where: PlaybackStateWhereUniqueInput
  }

  /**
   * PlaybackState findUniqueOrThrow
   */
  export type PlaybackStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackState to fetch.
     */
    where: PlaybackStateWhereUniqueInput
  }

  /**
   * PlaybackState findFirst
   */
  export type PlaybackStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackState to fetch.
     */
    where?: PlaybackStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaybackStates to fetch.
     */
    orderBy?: PlaybackStateOrderByWithRelationInput | PlaybackStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaybackStates.
     */
    cursor?: PlaybackStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaybackStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaybackStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaybackStates.
     */
    distinct?: PlaybackStateScalarFieldEnum | PlaybackStateScalarFieldEnum[]
  }

  /**
   * PlaybackState findFirstOrThrow
   */
  export type PlaybackStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackState to fetch.
     */
    where?: PlaybackStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaybackStates to fetch.
     */
    orderBy?: PlaybackStateOrderByWithRelationInput | PlaybackStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaybackStates.
     */
    cursor?: PlaybackStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaybackStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaybackStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaybackStates.
     */
    distinct?: PlaybackStateScalarFieldEnum | PlaybackStateScalarFieldEnum[]
  }

  /**
   * PlaybackState findMany
   */
  export type PlaybackStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    /**
     * Filter, which PlaybackStates to fetch.
     */
    where?: PlaybackStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaybackStates to fetch.
     */
    orderBy?: PlaybackStateOrderByWithRelationInput | PlaybackStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaybackStates.
     */
    cursor?: PlaybackStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaybackStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaybackStates.
     */
    skip?: number
    distinct?: PlaybackStateScalarFieldEnum | PlaybackStateScalarFieldEnum[]
  }

  /**
   * PlaybackState create
   */
  export type PlaybackStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaybackState.
     */
    data: XOR<PlaybackStateCreateInput, PlaybackStateUncheckedCreateInput>
  }

  /**
   * PlaybackState createMany
   */
  export type PlaybackStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaybackStates.
     */
    data: PlaybackStateCreateManyInput | PlaybackStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaybackState createManyAndReturn
   */
  export type PlaybackStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * The data used to create many PlaybackStates.
     */
    data: PlaybackStateCreateManyInput | PlaybackStateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaybackState update
   */
  export type PlaybackStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaybackState.
     */
    data: XOR<PlaybackStateUpdateInput, PlaybackStateUncheckedUpdateInput>
    /**
     * Choose, which PlaybackState to update.
     */
    where: PlaybackStateWhereUniqueInput
  }

  /**
   * PlaybackState updateMany
   */
  export type PlaybackStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaybackStates.
     */
    data: XOR<PlaybackStateUpdateManyMutationInput, PlaybackStateUncheckedUpdateManyInput>
    /**
     * Filter which PlaybackStates to update
     */
    where?: PlaybackStateWhereInput
    /**
     * Limit how many PlaybackStates to update.
     */
    limit?: number
  }

  /**
   * PlaybackState updateManyAndReturn
   */
  export type PlaybackStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * The data used to update PlaybackStates.
     */
    data: XOR<PlaybackStateUpdateManyMutationInput, PlaybackStateUncheckedUpdateManyInput>
    /**
     * Filter which PlaybackStates to update
     */
    where?: PlaybackStateWhereInput
    /**
     * Limit how many PlaybackStates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaybackState upsert
   */
  export type PlaybackStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaybackState to update in case it exists.
     */
    where: PlaybackStateWhereUniqueInput
    /**
     * In case the PlaybackState found by the `where` argument doesn't exist, create a new PlaybackState with this data.
     */
    create: XOR<PlaybackStateCreateInput, PlaybackStateUncheckedCreateInput>
    /**
     * In case the PlaybackState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaybackStateUpdateInput, PlaybackStateUncheckedUpdateInput>
  }

  /**
   * PlaybackState delete
   */
  export type PlaybackStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    /**
     * Filter which PlaybackState to delete.
     */
    where: PlaybackStateWhereUniqueInput
  }

  /**
   * PlaybackState deleteMany
   */
  export type PlaybackStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaybackStates to delete
     */
    where?: PlaybackStateWhereInput
    /**
     * Limit how many PlaybackStates to delete.
     */
    limit?: number
  }

  /**
   * PlaybackState.currentSong
   */
  export type PlaybackState$currentSongArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Song
     */
    select?: SongSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Song
     */
    omit?: SongOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SongInclude<ExtArgs> | null
    where?: SongWhereInput
  }

  /**
   * PlaybackState.activeDevice
   */
  export type PlaybackState$activeDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    where?: UserDeviceWhereInput
  }

  /**
   * PlaybackState without action
   */
  export type PlaybackStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
  }


  /**
   * Model UserOAuthAccount
   */

  export type AggregateUserOAuthAccount = {
    _count: UserOAuthAccountCountAggregateOutputType | null
    _min: UserOAuthAccountMinAggregateOutputType | null
    _max: UserOAuthAccountMaxAggregateOutputType | null
  }

  export type UserOAuthAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerUserId: string | null
    email: string | null
    name: string | null
    avatarUrl: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserOAuthAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerUserId: string | null
    email: string | null
    name: string | null
    avatarUrl: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserOAuthAccountCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerUserId: number
    email: number
    name: number
    avatarUrl: number
    accessToken: number
    refreshToken: number
    tokenExpiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserOAuthAccountMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerUserId?: true
    email?: true
    name?: true
    avatarUrl?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserOAuthAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerUserId?: true
    email?: true
    name?: true
    avatarUrl?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserOAuthAccountCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerUserId?: true
    email?: true
    name?: true
    avatarUrl?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserOAuthAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOAuthAccount to aggregate.
     */
    where?: UserOAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOAuthAccounts to fetch.
     */
    orderBy?: UserOAuthAccountOrderByWithRelationInput | UserOAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOAuthAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOAuthAccounts
    **/
    _count?: true | UserOAuthAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOAuthAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOAuthAccountMaxAggregateInputType
  }

  export type GetUserOAuthAccountAggregateType<T extends UserOAuthAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOAuthAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOAuthAccount[P]>
      : GetScalarType<T[P], AggregateUserOAuthAccount[P]>
  }




  export type UserOAuthAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOAuthAccountWhereInput
    orderBy?: UserOAuthAccountOrderByWithAggregationInput | UserOAuthAccountOrderByWithAggregationInput[]
    by: UserOAuthAccountScalarFieldEnum[] | UserOAuthAccountScalarFieldEnum
    having?: UserOAuthAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOAuthAccountCountAggregateInputType | true
    _min?: UserOAuthAccountMinAggregateInputType
    _max?: UserOAuthAccountMaxAggregateInputType
  }

  export type UserOAuthAccountGroupByOutputType = {
    id: string
    userId: string
    provider: string
    providerUserId: string
    email: string | null
    name: string | null
    avatarUrl: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserOAuthAccountCountAggregateOutputType | null
    _min: UserOAuthAccountMinAggregateOutputType | null
    _max: UserOAuthAccountMaxAggregateOutputType | null
  }

  type GetUserOAuthAccountGroupByPayload<T extends UserOAuthAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOAuthAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOAuthAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOAuthAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserOAuthAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserOAuthAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerUserId?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOAuthAccount"]>

  export type UserOAuthAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerUserId?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOAuthAccount"]>

  export type UserOAuthAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerUserId?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOAuthAccount"]>

  export type UserOAuthAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerUserId?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOAuthAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "providerUserId" | "email" | "name" | "avatarUrl" | "accessToken" | "refreshToken" | "tokenExpiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userOAuthAccount"]>
  export type UserOAuthAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserOAuthAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserOAuthAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserOAuthAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOAuthAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      providerUserId: string
      email: string | null
      name: string | null
      avatarUrl: string | null
      accessToken: string | null
      refreshToken: string | null
      tokenExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userOAuthAccount"]>
    composites: {}
  }

  type UserOAuthAccountGetPayload<S extends boolean | null | undefined | UserOAuthAccountDefaultArgs> = $Result.GetResult<Prisma.$UserOAuthAccountPayload, S>

  type UserOAuthAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserOAuthAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserOAuthAccountCountAggregateInputType | true
    }

  export interface UserOAuthAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOAuthAccount'], meta: { name: 'UserOAuthAccount' } }
    /**
     * Find zero or one UserOAuthAccount that matches the filter.
     * @param {UserOAuthAccountFindUniqueArgs} args - Arguments to find a UserOAuthAccount
     * @example
     * // Get one UserOAuthAccount
     * const userOAuthAccount = await prisma.userOAuthAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserOAuthAccountFindUniqueArgs>(args: SelectSubset<T, UserOAuthAccountFindUniqueArgs<ExtArgs>>): Prisma__UserOAuthAccountClient<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserOAuthAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserOAuthAccountFindUniqueOrThrowArgs} args - Arguments to find a UserOAuthAccount
     * @example
     * // Get one UserOAuthAccount
     * const userOAuthAccount = await prisma.userOAuthAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserOAuthAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, UserOAuthAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserOAuthAccountClient<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserOAuthAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOAuthAccountFindFirstArgs} args - Arguments to find a UserOAuthAccount
     * @example
     * // Get one UserOAuthAccount
     * const userOAuthAccount = await prisma.userOAuthAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserOAuthAccountFindFirstArgs>(args?: SelectSubset<T, UserOAuthAccountFindFirstArgs<ExtArgs>>): Prisma__UserOAuthAccountClient<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserOAuthAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOAuthAccountFindFirstOrThrowArgs} args - Arguments to find a UserOAuthAccount
     * @example
     * // Get one UserOAuthAccount
     * const userOAuthAccount = await prisma.userOAuthAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserOAuthAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, UserOAuthAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserOAuthAccountClient<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserOAuthAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOAuthAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOAuthAccounts
     * const userOAuthAccounts = await prisma.userOAuthAccount.findMany()
     * 
     * // Get first 10 UserOAuthAccounts
     * const userOAuthAccounts = await prisma.userOAuthAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userOAuthAccountWithIdOnly = await prisma.userOAuthAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserOAuthAccountFindManyArgs>(args?: SelectSubset<T, UserOAuthAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserOAuthAccount.
     * @param {UserOAuthAccountCreateArgs} args - Arguments to create a UserOAuthAccount.
     * @example
     * // Create one UserOAuthAccount
     * const UserOAuthAccount = await prisma.userOAuthAccount.create({
     *   data: {
     *     // ... data to create a UserOAuthAccount
     *   }
     * })
     * 
     */
    create<T extends UserOAuthAccountCreateArgs>(args: SelectSubset<T, UserOAuthAccountCreateArgs<ExtArgs>>): Prisma__UserOAuthAccountClient<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserOAuthAccounts.
     * @param {UserOAuthAccountCreateManyArgs} args - Arguments to create many UserOAuthAccounts.
     * @example
     * // Create many UserOAuthAccounts
     * const userOAuthAccount = await prisma.userOAuthAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserOAuthAccountCreateManyArgs>(args?: SelectSubset<T, UserOAuthAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserOAuthAccounts and returns the data saved in the database.
     * @param {UserOAuthAccountCreateManyAndReturnArgs} args - Arguments to create many UserOAuthAccounts.
     * @example
     * // Create many UserOAuthAccounts
     * const userOAuthAccount = await prisma.userOAuthAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserOAuthAccounts and only return the `id`
     * const userOAuthAccountWithIdOnly = await prisma.userOAuthAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserOAuthAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, UserOAuthAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserOAuthAccount.
     * @param {UserOAuthAccountDeleteArgs} args - Arguments to delete one UserOAuthAccount.
     * @example
     * // Delete one UserOAuthAccount
     * const UserOAuthAccount = await prisma.userOAuthAccount.delete({
     *   where: {
     *     // ... filter to delete one UserOAuthAccount
     *   }
     * })
     * 
     */
    delete<T extends UserOAuthAccountDeleteArgs>(args: SelectSubset<T, UserOAuthAccountDeleteArgs<ExtArgs>>): Prisma__UserOAuthAccountClient<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserOAuthAccount.
     * @param {UserOAuthAccountUpdateArgs} args - Arguments to update one UserOAuthAccount.
     * @example
     * // Update one UserOAuthAccount
     * const userOAuthAccount = await prisma.userOAuthAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserOAuthAccountUpdateArgs>(args: SelectSubset<T, UserOAuthAccountUpdateArgs<ExtArgs>>): Prisma__UserOAuthAccountClient<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserOAuthAccounts.
     * @param {UserOAuthAccountDeleteManyArgs} args - Arguments to filter UserOAuthAccounts to delete.
     * @example
     * // Delete a few UserOAuthAccounts
     * const { count } = await prisma.userOAuthAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserOAuthAccountDeleteManyArgs>(args?: SelectSubset<T, UserOAuthAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOAuthAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOAuthAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOAuthAccounts
     * const userOAuthAccount = await prisma.userOAuthAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserOAuthAccountUpdateManyArgs>(args: SelectSubset<T, UserOAuthAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOAuthAccounts and returns the data updated in the database.
     * @param {UserOAuthAccountUpdateManyAndReturnArgs} args - Arguments to update many UserOAuthAccounts.
     * @example
     * // Update many UserOAuthAccounts
     * const userOAuthAccount = await prisma.userOAuthAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserOAuthAccounts and only return the `id`
     * const userOAuthAccountWithIdOnly = await prisma.userOAuthAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserOAuthAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, UserOAuthAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserOAuthAccount.
     * @param {UserOAuthAccountUpsertArgs} args - Arguments to update or create a UserOAuthAccount.
     * @example
     * // Update or create a UserOAuthAccount
     * const userOAuthAccount = await prisma.userOAuthAccount.upsert({
     *   create: {
     *     // ... data to create a UserOAuthAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOAuthAccount we want to update
     *   }
     * })
     */
    upsert<T extends UserOAuthAccountUpsertArgs>(args: SelectSubset<T, UserOAuthAccountUpsertArgs<ExtArgs>>): Prisma__UserOAuthAccountClient<$Result.GetResult<Prisma.$UserOAuthAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserOAuthAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOAuthAccountCountArgs} args - Arguments to filter UserOAuthAccounts to count.
     * @example
     * // Count the number of UserOAuthAccounts
     * const count = await prisma.userOAuthAccount.count({
     *   where: {
     *     // ... the filter for the UserOAuthAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserOAuthAccountCountArgs>(
      args?: Subset<T, UserOAuthAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOAuthAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOAuthAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOAuthAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOAuthAccountAggregateArgs>(args: Subset<T, UserOAuthAccountAggregateArgs>): Prisma.PrismaPromise<GetUserOAuthAccountAggregateType<T>>

    /**
     * Group by UserOAuthAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOAuthAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOAuthAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOAuthAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserOAuthAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOAuthAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOAuthAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOAuthAccount model
   */
  readonly fields: UserOAuthAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOAuthAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOAuthAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserOAuthAccount model
   */
  interface UserOAuthAccountFieldRefs {
    readonly id: FieldRef<"UserOAuthAccount", 'String'>
    readonly userId: FieldRef<"UserOAuthAccount", 'String'>
    readonly provider: FieldRef<"UserOAuthAccount", 'String'>
    readonly providerUserId: FieldRef<"UserOAuthAccount", 'String'>
    readonly email: FieldRef<"UserOAuthAccount", 'String'>
    readonly name: FieldRef<"UserOAuthAccount", 'String'>
    readonly avatarUrl: FieldRef<"UserOAuthAccount", 'String'>
    readonly accessToken: FieldRef<"UserOAuthAccount", 'String'>
    readonly refreshToken: FieldRef<"UserOAuthAccount", 'String'>
    readonly tokenExpiresAt: FieldRef<"UserOAuthAccount", 'DateTime'>
    readonly createdAt: FieldRef<"UserOAuthAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"UserOAuthAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserOAuthAccount findUnique
   */
  export type UserOAuthAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserOAuthAccount to fetch.
     */
    where: UserOAuthAccountWhereUniqueInput
  }

  /**
   * UserOAuthAccount findUniqueOrThrow
   */
  export type UserOAuthAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserOAuthAccount to fetch.
     */
    where: UserOAuthAccountWhereUniqueInput
  }

  /**
   * UserOAuthAccount findFirst
   */
  export type UserOAuthAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserOAuthAccount to fetch.
     */
    where?: UserOAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOAuthAccounts to fetch.
     */
    orderBy?: UserOAuthAccountOrderByWithRelationInput | UserOAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOAuthAccounts.
     */
    cursor?: UserOAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOAuthAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOAuthAccounts.
     */
    distinct?: UserOAuthAccountScalarFieldEnum | UserOAuthAccountScalarFieldEnum[]
  }

  /**
   * UserOAuthAccount findFirstOrThrow
   */
  export type UserOAuthAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserOAuthAccount to fetch.
     */
    where?: UserOAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOAuthAccounts to fetch.
     */
    orderBy?: UserOAuthAccountOrderByWithRelationInput | UserOAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOAuthAccounts.
     */
    cursor?: UserOAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOAuthAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOAuthAccounts.
     */
    distinct?: UserOAuthAccountScalarFieldEnum | UserOAuthAccountScalarFieldEnum[]
  }

  /**
   * UserOAuthAccount findMany
   */
  export type UserOAuthAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserOAuthAccounts to fetch.
     */
    where?: UserOAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOAuthAccounts to fetch.
     */
    orderBy?: UserOAuthAccountOrderByWithRelationInput | UserOAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOAuthAccounts.
     */
    cursor?: UserOAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOAuthAccounts.
     */
    skip?: number
    distinct?: UserOAuthAccountScalarFieldEnum | UserOAuthAccountScalarFieldEnum[]
  }

  /**
   * UserOAuthAccount create
   */
  export type UserOAuthAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOAuthAccount.
     */
    data: XOR<UserOAuthAccountCreateInput, UserOAuthAccountUncheckedCreateInput>
  }

  /**
   * UserOAuthAccount createMany
   */
  export type UserOAuthAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOAuthAccounts.
     */
    data: UserOAuthAccountCreateManyInput | UserOAuthAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserOAuthAccount createManyAndReturn
   */
  export type UserOAuthAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * The data used to create many UserOAuthAccounts.
     */
    data: UserOAuthAccountCreateManyInput | UserOAuthAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOAuthAccount update
   */
  export type UserOAuthAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOAuthAccount.
     */
    data: XOR<UserOAuthAccountUpdateInput, UserOAuthAccountUncheckedUpdateInput>
    /**
     * Choose, which UserOAuthAccount to update.
     */
    where: UserOAuthAccountWhereUniqueInput
  }

  /**
   * UserOAuthAccount updateMany
   */
  export type UserOAuthAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOAuthAccounts.
     */
    data: XOR<UserOAuthAccountUpdateManyMutationInput, UserOAuthAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserOAuthAccounts to update
     */
    where?: UserOAuthAccountWhereInput
    /**
     * Limit how many UserOAuthAccounts to update.
     */
    limit?: number
  }

  /**
   * UserOAuthAccount updateManyAndReturn
   */
  export type UserOAuthAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * The data used to update UserOAuthAccounts.
     */
    data: XOR<UserOAuthAccountUpdateManyMutationInput, UserOAuthAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserOAuthAccounts to update
     */
    where?: UserOAuthAccountWhereInput
    /**
     * Limit how many UserOAuthAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOAuthAccount upsert
   */
  export type UserOAuthAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOAuthAccount to update in case it exists.
     */
    where: UserOAuthAccountWhereUniqueInput
    /**
     * In case the UserOAuthAccount found by the `where` argument doesn't exist, create a new UserOAuthAccount with this data.
     */
    create: XOR<UserOAuthAccountCreateInput, UserOAuthAccountUncheckedCreateInput>
    /**
     * In case the UserOAuthAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOAuthAccountUpdateInput, UserOAuthAccountUncheckedUpdateInput>
  }

  /**
   * UserOAuthAccount delete
   */
  export type UserOAuthAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
    /**
     * Filter which UserOAuthAccount to delete.
     */
    where: UserOAuthAccountWhereUniqueInput
  }

  /**
   * UserOAuthAccount deleteMany
   */
  export type UserOAuthAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOAuthAccounts to delete
     */
    where?: UserOAuthAccountWhereInput
    /**
     * Limit how many UserOAuthAccounts to delete.
     */
    limit?: number
  }

  /**
   * UserOAuthAccount without action
   */
  export type UserOAuthAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOAuthAccount
     */
    select?: UserOAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOAuthAccount
     */
    omit?: UserOAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOAuthAccountInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceId: string | null
    tokenHash: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    lastActivityAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceId: string | null
    tokenHash: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    lastActivityAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    deviceId: number
    tokenHash: number
    ipAddress: number
    userAgent: number
    isActive: number
    expiresAt: number
    createdAt: number
    lastActivityAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    tokenHash?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    lastActivityAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    tokenHash?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    lastActivityAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    tokenHash?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    lastActivityAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    deviceId: string | null
    tokenHash: string
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean
    expiresAt: Date
    createdAt: Date
    lastActivityAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    tokenHash?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActivityAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    device?: boolean | UserSession$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    tokenHash?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActivityAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    device?: boolean | UserSession$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    tokenHash?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActivityAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    device?: boolean | UserSession$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    tokenHash?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    lastActivityAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceId" | "tokenHash" | "ipAddress" | "userAgent" | "isActive" | "expiresAt" | "createdAt" | "lastActivityAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    device?: boolean | UserSession$deviceArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    device?: boolean | UserSession$deviceArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    device?: boolean | UserSession$deviceArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      device: Prisma.$UserDevicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceId: string | null
      tokenHash: string
      ipAddress: string | null
      userAgent: string | null
      isActive: boolean
      expiresAt: Date
      createdAt: Date
      lastActivityAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    device<T extends UserSession$deviceArgs<ExtArgs> = {}>(args?: Subset<T, UserSession$deviceArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly deviceId: FieldRef<"UserSession", 'String'>
    readonly tokenHash: FieldRef<"UserSession", 'String'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly isActive: FieldRef<"UserSession", 'Boolean'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly lastActivityAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession.device
   */
  export type UserSession$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    where?: UserDeviceWhereInput
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model UserDevice
   */

  export type AggregateUserDevice = {
    _count: UserDeviceCountAggregateOutputType | null
    _min: UserDeviceMinAggregateOutputType | null
    _max: UserDeviceMaxAggregateOutputType | null
  }

  export type UserDeviceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceType: $Enums.DeviceType | null
    deviceName: string | null
    deviceToken: string | null
    appVersion: string | null
    osVersion: string | null
    isActive: boolean | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDeviceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceType: $Enums.DeviceType | null
    deviceName: string | null
    deviceToken: string | null
    appVersion: string | null
    osVersion: string | null
    isActive: boolean | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDeviceCountAggregateOutputType = {
    id: number
    userId: number
    deviceType: number
    deviceName: number
    deviceToken: number
    appVersion: number
    osVersion: number
    isActive: number
    lastSyncAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserDeviceMinAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceName?: true
    deviceToken?: true
    appVersion?: true
    osVersion?: true
    isActive?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDeviceMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceName?: true
    deviceToken?: true
    appVersion?: true
    osVersion?: true
    isActive?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDeviceCountAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceName?: true
    deviceToken?: true
    appVersion?: true
    osVersion?: true
    isActive?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserDeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDevice to aggregate.
     */
    where?: UserDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDevices to fetch.
     */
    orderBy?: UserDeviceOrderByWithRelationInput | UserDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDevices
    **/
    _count?: true | UserDeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDeviceMaxAggregateInputType
  }

  export type GetUserDeviceAggregateType<T extends UserDeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDevice[P]>
      : GetScalarType<T[P], AggregateUserDevice[P]>
  }




  export type UserDeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDeviceWhereInput
    orderBy?: UserDeviceOrderByWithAggregationInput | UserDeviceOrderByWithAggregationInput[]
    by: UserDeviceScalarFieldEnum[] | UserDeviceScalarFieldEnum
    having?: UserDeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDeviceCountAggregateInputType | true
    _min?: UserDeviceMinAggregateInputType
    _max?: UserDeviceMaxAggregateInputType
  }

  export type UserDeviceGroupByOutputType = {
    id: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName: string | null
    deviceToken: string | null
    appVersion: string | null
    osVersion: string | null
    isActive: boolean
    lastSyncAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserDeviceCountAggregateOutputType | null
    _min: UserDeviceMinAggregateOutputType | null
    _max: UserDeviceMaxAggregateOutputType | null
  }

  type GetUserDeviceGroupByPayload<T extends UserDeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDeviceGroupByOutputType[P]>
            : GetScalarType<T[P], UserDeviceGroupByOutputType[P]>
        }
      >
    >


  export type UserDeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceName?: boolean
    deviceToken?: boolean
    appVersion?: boolean
    osVersion?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | UserDevice$sessionsArgs<ExtArgs>
    playbackStates?: boolean | UserDevice$playbackStatesArgs<ExtArgs>
    syncStates?: boolean | UserDevice$syncStatesArgs<ExtArgs>
    syncLogs?: boolean | UserDevice$syncLogsArgs<ExtArgs>
    transfersFrom?: boolean | UserDevice$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | UserDevice$transfersToArgs<ExtArgs>
    adImpressions?: boolean | UserDevice$adImpressionsArgs<ExtArgs>
    _count?: boolean | UserDeviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDevice"]>

  export type UserDeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceName?: boolean
    deviceToken?: boolean
    appVersion?: boolean
    osVersion?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDevice"]>

  export type UserDeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceName?: boolean
    deviceToken?: boolean
    appVersion?: boolean
    osVersion?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDevice"]>

  export type UserDeviceSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceName?: boolean
    deviceToken?: boolean
    appVersion?: boolean
    osVersion?: boolean
    isActive?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserDeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceType" | "deviceName" | "deviceToken" | "appVersion" | "osVersion" | "isActive" | "lastSyncAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userDevice"]>
  export type UserDeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | UserDevice$sessionsArgs<ExtArgs>
    playbackStates?: boolean | UserDevice$playbackStatesArgs<ExtArgs>
    syncStates?: boolean | UserDevice$syncStatesArgs<ExtArgs>
    syncLogs?: boolean | UserDevice$syncLogsArgs<ExtArgs>
    transfersFrom?: boolean | UserDevice$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | UserDevice$transfersToArgs<ExtArgs>
    adImpressions?: boolean | UserDevice$adImpressionsArgs<ExtArgs>
    _count?: boolean | UserDeviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserDeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserDevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDevice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      playbackStates: Prisma.$PlaybackStatePayload<ExtArgs>[]
      syncStates: Prisma.$DeviceSyncStatePayload<ExtArgs>[]
      syncLogs: Prisma.$SyncLogPayload<ExtArgs>[]
      transfersFrom: Prisma.$DeviceTransferPayload<ExtArgs>[]
      transfersTo: Prisma.$DeviceTransferPayload<ExtArgs>[]
      adImpressions: Prisma.$AdImpressionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceType: $Enums.DeviceType
      deviceName: string | null
      deviceToken: string | null
      appVersion: string | null
      osVersion: string | null
      isActive: boolean
      lastSyncAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userDevice"]>
    composites: {}
  }

  type UserDeviceGetPayload<S extends boolean | null | undefined | UserDeviceDefaultArgs> = $Result.GetResult<Prisma.$UserDevicePayload, S>

  type UserDeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserDeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserDeviceCountAggregateInputType | true
    }

  export interface UserDeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDevice'], meta: { name: 'UserDevice' } }
    /**
     * Find zero or one UserDevice that matches the filter.
     * @param {UserDeviceFindUniqueArgs} args - Arguments to find a UserDevice
     * @example
     * // Get one UserDevice
     * const userDevice = await prisma.userDevice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDeviceFindUniqueArgs>(args: SelectSubset<T, UserDeviceFindUniqueArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserDevice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserDeviceFindUniqueOrThrowArgs} args - Arguments to find a UserDevice
     * @example
     * // Get one UserDevice
     * const userDevice = await prisma.userDevice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDevice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFindFirstArgs} args - Arguments to find a UserDevice
     * @example
     * // Get one UserDevice
     * const userDevice = await prisma.userDevice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDeviceFindFirstArgs>(args?: SelectSubset<T, UserDeviceFindFirstArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDevice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFindFirstOrThrowArgs} args - Arguments to find a UserDevice
     * @example
     * // Get one UserDevice
     * const userDevice = await prisma.userDevice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserDevices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDevices
     * const userDevices = await prisma.userDevice.findMany()
     * 
     * // Get first 10 UserDevices
     * const userDevices = await prisma.userDevice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDeviceWithIdOnly = await prisma.userDevice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserDeviceFindManyArgs>(args?: SelectSubset<T, UserDeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserDevice.
     * @param {UserDeviceCreateArgs} args - Arguments to create a UserDevice.
     * @example
     * // Create one UserDevice
     * const UserDevice = await prisma.userDevice.create({
     *   data: {
     *     // ... data to create a UserDevice
     *   }
     * })
     * 
     */
    create<T extends UserDeviceCreateArgs>(args: SelectSubset<T, UserDeviceCreateArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserDevices.
     * @param {UserDeviceCreateManyArgs} args - Arguments to create many UserDevices.
     * @example
     * // Create many UserDevices
     * const userDevice = await prisma.userDevice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDeviceCreateManyArgs>(args?: SelectSubset<T, UserDeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDevices and returns the data saved in the database.
     * @param {UserDeviceCreateManyAndReturnArgs} args - Arguments to create many UserDevices.
     * @example
     * // Create many UserDevices
     * const userDevice = await prisma.userDevice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDevices and only return the `id`
     * const userDeviceWithIdOnly = await prisma.userDevice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserDevice.
     * @param {UserDeviceDeleteArgs} args - Arguments to delete one UserDevice.
     * @example
     * // Delete one UserDevice
     * const UserDevice = await prisma.userDevice.delete({
     *   where: {
     *     // ... filter to delete one UserDevice
     *   }
     * })
     * 
     */
    delete<T extends UserDeviceDeleteArgs>(args: SelectSubset<T, UserDeviceDeleteArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserDevice.
     * @param {UserDeviceUpdateArgs} args - Arguments to update one UserDevice.
     * @example
     * // Update one UserDevice
     * const userDevice = await prisma.userDevice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDeviceUpdateArgs>(args: SelectSubset<T, UserDeviceUpdateArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserDevices.
     * @param {UserDeviceDeleteManyArgs} args - Arguments to filter UserDevices to delete.
     * @example
     * // Delete a few UserDevices
     * const { count } = await prisma.userDevice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeviceDeleteManyArgs>(args?: SelectSubset<T, UserDeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDevices
     * const userDevice = await prisma.userDevice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDeviceUpdateManyArgs>(args: SelectSubset<T, UserDeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDevices and returns the data updated in the database.
     * @param {UserDeviceUpdateManyAndReturnArgs} args - Arguments to update many UserDevices.
     * @example
     * // Update many UserDevices
     * const userDevice = await prisma.userDevice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserDevices and only return the `id`
     * const userDeviceWithIdOnly = await prisma.userDevice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserDeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserDeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserDevice.
     * @param {UserDeviceUpsertArgs} args - Arguments to update or create a UserDevice.
     * @example
     * // Update or create a UserDevice
     * const userDevice = await prisma.userDevice.upsert({
     *   create: {
     *     // ... data to create a UserDevice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDevice we want to update
     *   }
     * })
     */
    upsert<T extends UserDeviceUpsertArgs>(args: SelectSubset<T, UserDeviceUpsertArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceCountArgs} args - Arguments to filter UserDevices to count.
     * @example
     * // Count the number of UserDevices
     * const count = await prisma.userDevice.count({
     *   where: {
     *     // ... the filter for the UserDevices we want to count
     *   }
     * })
    **/
    count<T extends UserDeviceCountArgs>(
      args?: Subset<T, UserDeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDeviceAggregateArgs>(args: Subset<T, UserDeviceAggregateArgs>): Prisma.PrismaPromise<GetUserDeviceAggregateType<T>>

    /**
     * Group by UserDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDeviceGroupByArgs['orderBy'] }
        : { orderBy?: UserDeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDevice model
   */
  readonly fields: UserDeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDevice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends UserDevice$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, UserDevice$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playbackStates<T extends UserDevice$playbackStatesArgs<ExtArgs> = {}>(args?: Subset<T, UserDevice$playbackStatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaybackStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    syncStates<T extends UserDevice$syncStatesArgs<ExtArgs> = {}>(args?: Subset<T, UserDevice$syncStatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    syncLogs<T extends UserDevice$syncLogsArgs<ExtArgs> = {}>(args?: Subset<T, UserDevice$syncLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersFrom<T extends UserDevice$transfersFromArgs<ExtArgs> = {}>(args?: Subset<T, UserDevice$transfersFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersTo<T extends UserDevice$transfersToArgs<ExtArgs> = {}>(args?: Subset<T, UserDevice$transfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adImpressions<T extends UserDevice$adImpressionsArgs<ExtArgs> = {}>(args?: Subset<T, UserDevice$adImpressionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDevice model
   */
  interface UserDeviceFieldRefs {
    readonly id: FieldRef<"UserDevice", 'String'>
    readonly userId: FieldRef<"UserDevice", 'String'>
    readonly deviceType: FieldRef<"UserDevice", 'DeviceType'>
    readonly deviceName: FieldRef<"UserDevice", 'String'>
    readonly deviceToken: FieldRef<"UserDevice", 'String'>
    readonly appVersion: FieldRef<"UserDevice", 'String'>
    readonly osVersion: FieldRef<"UserDevice", 'String'>
    readonly isActive: FieldRef<"UserDevice", 'Boolean'>
    readonly lastSyncAt: FieldRef<"UserDevice", 'DateTime'>
    readonly createdAt: FieldRef<"UserDevice", 'DateTime'>
    readonly updatedAt: FieldRef<"UserDevice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserDevice findUnique
   */
  export type UserDeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    /**
     * Filter, which UserDevice to fetch.
     */
    where: UserDeviceWhereUniqueInput
  }

  /**
   * UserDevice findUniqueOrThrow
   */
  export type UserDeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    /**
     * Filter, which UserDevice to fetch.
     */
    where: UserDeviceWhereUniqueInput
  }

  /**
   * UserDevice findFirst
   */
  export type UserDeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    /**
     * Filter, which UserDevice to fetch.
     */
    where?: UserDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDevices to fetch.
     */
    orderBy?: UserDeviceOrderByWithRelationInput | UserDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDevices.
     */
    cursor?: UserDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDevices.
     */
    distinct?: UserDeviceScalarFieldEnum | UserDeviceScalarFieldEnum[]
  }

  /**
   * UserDevice findFirstOrThrow
   */
  export type UserDeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    /**
     * Filter, which UserDevice to fetch.
     */
    where?: UserDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDevices to fetch.
     */
    orderBy?: UserDeviceOrderByWithRelationInput | UserDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDevices.
     */
    cursor?: UserDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDevices.
     */
    distinct?: UserDeviceScalarFieldEnum | UserDeviceScalarFieldEnum[]
  }

  /**
   * UserDevice findMany
   */
  export type UserDeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    /**
     * Filter, which UserDevices to fetch.
     */
    where?: UserDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDevices to fetch.
     */
    orderBy?: UserDeviceOrderByWithRelationInput | UserDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDevices.
     */
    cursor?: UserDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDevices.
     */
    skip?: number
    distinct?: UserDeviceScalarFieldEnum | UserDeviceScalarFieldEnum[]
  }

  /**
   * UserDevice create
   */
  export type UserDeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDevice.
     */
    data: XOR<UserDeviceCreateInput, UserDeviceUncheckedCreateInput>
  }

  /**
   * UserDevice createMany
   */
  export type UserDeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDevices.
     */
    data: UserDeviceCreateManyInput | UserDeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDevice createManyAndReturn
   */
  export type UserDeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * The data used to create many UserDevices.
     */
    data: UserDeviceCreateManyInput | UserDeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDevice update
   */
  export type UserDeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDevice.
     */
    data: XOR<UserDeviceUpdateInput, UserDeviceUncheckedUpdateInput>
    /**
     * Choose, which UserDevice to update.
     */
    where: UserDeviceWhereUniqueInput
  }

  /**
   * UserDevice updateMany
   */
  export type UserDeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDevices.
     */
    data: XOR<UserDeviceUpdateManyMutationInput, UserDeviceUncheckedUpdateManyInput>
    /**
     * Filter which UserDevices to update
     */
    where?: UserDeviceWhereInput
    /**
     * Limit how many UserDevices to update.
     */
    limit?: number
  }

  /**
   * UserDevice updateManyAndReturn
   */
  export type UserDeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * The data used to update UserDevices.
     */
    data: XOR<UserDeviceUpdateManyMutationInput, UserDeviceUncheckedUpdateManyInput>
    /**
     * Filter which UserDevices to update
     */
    where?: UserDeviceWhereInput
    /**
     * Limit how many UserDevices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDevice upsert
   */
  export type UserDeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDevice to update in case it exists.
     */
    where: UserDeviceWhereUniqueInput
    /**
     * In case the UserDevice found by the `where` argument doesn't exist, create a new UserDevice with this data.
     */
    create: XOR<UserDeviceCreateInput, UserDeviceUncheckedCreateInput>
    /**
     * In case the UserDevice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDeviceUpdateInput, UserDeviceUncheckedUpdateInput>
  }

  /**
   * UserDevice delete
   */
  export type UserDeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    /**
     * Filter which UserDevice to delete.
     */
    where: UserDeviceWhereUniqueInput
  }

  /**
   * UserDevice deleteMany
   */
  export type UserDeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDevices to delete
     */
    where?: UserDeviceWhereInput
    /**
     * Limit how many UserDevices to delete.
     */
    limit?: number
  }

  /**
   * UserDevice.sessions
   */
  export type UserDevice$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserDevice.playbackStates
   */
  export type UserDevice$playbackStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaybackState
     */
    select?: PlaybackStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaybackState
     */
    omit?: PlaybackStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaybackStateInclude<ExtArgs> | null
    where?: PlaybackStateWhereInput
    orderBy?: PlaybackStateOrderByWithRelationInput | PlaybackStateOrderByWithRelationInput[]
    cursor?: PlaybackStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaybackStateScalarFieldEnum | PlaybackStateScalarFieldEnum[]
  }

  /**
   * UserDevice.syncStates
   */
  export type UserDevice$syncStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    where?: DeviceSyncStateWhereInput
    orderBy?: DeviceSyncStateOrderByWithRelationInput | DeviceSyncStateOrderByWithRelationInput[]
    cursor?: DeviceSyncStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceSyncStateScalarFieldEnum | DeviceSyncStateScalarFieldEnum[]
  }

  /**
   * UserDevice.syncLogs
   */
  export type UserDevice$syncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    cursor?: SyncLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * UserDevice.transfersFrom
   */
  export type UserDevice$transfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    where?: DeviceTransferWhereInput
    orderBy?: DeviceTransferOrderByWithRelationInput | DeviceTransferOrderByWithRelationInput[]
    cursor?: DeviceTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceTransferScalarFieldEnum | DeviceTransferScalarFieldEnum[]
  }

  /**
   * UserDevice.transfersTo
   */
  export type UserDevice$transfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    where?: DeviceTransferWhereInput
    orderBy?: DeviceTransferOrderByWithRelationInput | DeviceTransferOrderByWithRelationInput[]
    cursor?: DeviceTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceTransferScalarFieldEnum | DeviceTransferScalarFieldEnum[]
  }

  /**
   * UserDevice.adImpressions
   */
  export type UserDevice$adImpressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    where?: AdImpressionWhereInput
    orderBy?: AdImpressionOrderByWithRelationInput | AdImpressionOrderByWithRelationInput[]
    cursor?: AdImpressionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdImpressionScalarFieldEnum | AdImpressionScalarFieldEnum[]
  }

  /**
   * UserDevice without action
   */
  export type UserDeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
  }


  /**
   * Model DeviceSyncState
   */

  export type AggregateDeviceSyncState = {
    _count: DeviceSyncStateCountAggregateOutputType | null
    _avg: DeviceSyncStateAvgAggregateOutputType | null
    _sum: DeviceSyncStateSumAggregateOutputType | null
    _min: DeviceSyncStateMinAggregateOutputType | null
    _max: DeviceSyncStateMaxAggregateOutputType | null
  }

  export type DeviceSyncStateAvgAggregateOutputType = {
    lastSyncVersion: number | null
    pendingChanges: number | null
  }

  export type DeviceSyncStateSumAggregateOutputType = {
    lastSyncVersion: bigint | null
    pendingChanges: number | null
  }

  export type DeviceSyncStateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceId: string | null
    syncType: $Enums.SyncType | null
    lastSyncVersion: bigint | null
    lastSyncAt: Date | null
    pendingChanges: number | null
  }

  export type DeviceSyncStateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceId: string | null
    syncType: $Enums.SyncType | null
    lastSyncVersion: bigint | null
    lastSyncAt: Date | null
    pendingChanges: number | null
  }

  export type DeviceSyncStateCountAggregateOutputType = {
    id: number
    userId: number
    deviceId: number
    syncType: number
    lastSyncVersion: number
    lastSyncAt: number
    pendingChanges: number
    _all: number
  }


  export type DeviceSyncStateAvgAggregateInputType = {
    lastSyncVersion?: true
    pendingChanges?: true
  }

  export type DeviceSyncStateSumAggregateInputType = {
    lastSyncVersion?: true
    pendingChanges?: true
  }

  export type DeviceSyncStateMinAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    syncType?: true
    lastSyncVersion?: true
    lastSyncAt?: true
    pendingChanges?: true
  }

  export type DeviceSyncStateMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    syncType?: true
    lastSyncVersion?: true
    lastSyncAt?: true
    pendingChanges?: true
  }

  export type DeviceSyncStateCountAggregateInputType = {
    id?: true
    userId?: true
    deviceId?: true
    syncType?: true
    lastSyncVersion?: true
    lastSyncAt?: true
    pendingChanges?: true
    _all?: true
  }

  export type DeviceSyncStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceSyncState to aggregate.
     */
    where?: DeviceSyncStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceSyncStates to fetch.
     */
    orderBy?: DeviceSyncStateOrderByWithRelationInput | DeviceSyncStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceSyncStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceSyncStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceSyncStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceSyncStates
    **/
    _count?: true | DeviceSyncStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceSyncStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSyncStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceSyncStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceSyncStateMaxAggregateInputType
  }

  export type GetDeviceSyncStateAggregateType<T extends DeviceSyncStateAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceSyncState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceSyncState[P]>
      : GetScalarType<T[P], AggregateDeviceSyncState[P]>
  }




  export type DeviceSyncStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceSyncStateWhereInput
    orderBy?: DeviceSyncStateOrderByWithAggregationInput | DeviceSyncStateOrderByWithAggregationInput[]
    by: DeviceSyncStateScalarFieldEnum[] | DeviceSyncStateScalarFieldEnum
    having?: DeviceSyncStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceSyncStateCountAggregateInputType | true
    _avg?: DeviceSyncStateAvgAggregateInputType
    _sum?: DeviceSyncStateSumAggregateInputType
    _min?: DeviceSyncStateMinAggregateInputType
    _max?: DeviceSyncStateMaxAggregateInputType
  }

  export type DeviceSyncStateGroupByOutputType = {
    id: string
    userId: string
    deviceId: string
    syncType: $Enums.SyncType
    lastSyncVersion: bigint
    lastSyncAt: Date | null
    pendingChanges: number
    _count: DeviceSyncStateCountAggregateOutputType | null
    _avg: DeviceSyncStateAvgAggregateOutputType | null
    _sum: DeviceSyncStateSumAggregateOutputType | null
    _min: DeviceSyncStateMinAggregateOutputType | null
    _max: DeviceSyncStateMaxAggregateOutputType | null
  }

  type GetDeviceSyncStateGroupByPayload<T extends DeviceSyncStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceSyncStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceSyncStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceSyncStateGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceSyncStateGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSyncStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    syncType?: boolean
    lastSyncVersion?: boolean
    lastSyncAt?: boolean
    pendingChanges?: boolean
    device?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceSyncState"]>

  export type DeviceSyncStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    syncType?: boolean
    lastSyncVersion?: boolean
    lastSyncAt?: boolean
    pendingChanges?: boolean
    device?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceSyncState"]>

  export type DeviceSyncStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    syncType?: boolean
    lastSyncVersion?: boolean
    lastSyncAt?: boolean
    pendingChanges?: boolean
    device?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceSyncState"]>

  export type DeviceSyncStateSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceId?: boolean
    syncType?: boolean
    lastSyncVersion?: boolean
    lastSyncAt?: boolean
    pendingChanges?: boolean
  }

  export type DeviceSyncStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceId" | "syncType" | "lastSyncVersion" | "lastSyncAt" | "pendingChanges", ExtArgs["result"]["deviceSyncState"]>
  export type DeviceSyncStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }
  export type DeviceSyncStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }
  export type DeviceSyncStateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }

  export type $DeviceSyncStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceSyncState"
    objects: {
      device: Prisma.$UserDevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceId: string
      syncType: $Enums.SyncType
      lastSyncVersion: bigint
      lastSyncAt: Date | null
      pendingChanges: number
    }, ExtArgs["result"]["deviceSyncState"]>
    composites: {}
  }

  type DeviceSyncStateGetPayload<S extends boolean | null | undefined | DeviceSyncStateDefaultArgs> = $Result.GetResult<Prisma.$DeviceSyncStatePayload, S>

  type DeviceSyncStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceSyncStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceSyncStateCountAggregateInputType | true
    }

  export interface DeviceSyncStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceSyncState'], meta: { name: 'DeviceSyncState' } }
    /**
     * Find zero or one DeviceSyncState that matches the filter.
     * @param {DeviceSyncStateFindUniqueArgs} args - Arguments to find a DeviceSyncState
     * @example
     * // Get one DeviceSyncState
     * const deviceSyncState = await prisma.deviceSyncState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceSyncStateFindUniqueArgs>(args: SelectSubset<T, DeviceSyncStateFindUniqueArgs<ExtArgs>>): Prisma__DeviceSyncStateClient<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceSyncState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceSyncStateFindUniqueOrThrowArgs} args - Arguments to find a DeviceSyncState
     * @example
     * // Get one DeviceSyncState
     * const deviceSyncState = await prisma.deviceSyncState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceSyncStateFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceSyncStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceSyncStateClient<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceSyncState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSyncStateFindFirstArgs} args - Arguments to find a DeviceSyncState
     * @example
     * // Get one DeviceSyncState
     * const deviceSyncState = await prisma.deviceSyncState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceSyncStateFindFirstArgs>(args?: SelectSubset<T, DeviceSyncStateFindFirstArgs<ExtArgs>>): Prisma__DeviceSyncStateClient<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceSyncState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSyncStateFindFirstOrThrowArgs} args - Arguments to find a DeviceSyncState
     * @example
     * // Get one DeviceSyncState
     * const deviceSyncState = await prisma.deviceSyncState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceSyncStateFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceSyncStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceSyncStateClient<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceSyncStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSyncStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceSyncStates
     * const deviceSyncStates = await prisma.deviceSyncState.findMany()
     * 
     * // Get first 10 DeviceSyncStates
     * const deviceSyncStates = await prisma.deviceSyncState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceSyncStateWithIdOnly = await prisma.deviceSyncState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceSyncStateFindManyArgs>(args?: SelectSubset<T, DeviceSyncStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceSyncState.
     * @param {DeviceSyncStateCreateArgs} args - Arguments to create a DeviceSyncState.
     * @example
     * // Create one DeviceSyncState
     * const DeviceSyncState = await prisma.deviceSyncState.create({
     *   data: {
     *     // ... data to create a DeviceSyncState
     *   }
     * })
     * 
     */
    create<T extends DeviceSyncStateCreateArgs>(args: SelectSubset<T, DeviceSyncStateCreateArgs<ExtArgs>>): Prisma__DeviceSyncStateClient<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceSyncStates.
     * @param {DeviceSyncStateCreateManyArgs} args - Arguments to create many DeviceSyncStates.
     * @example
     * // Create many DeviceSyncStates
     * const deviceSyncState = await prisma.deviceSyncState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceSyncStateCreateManyArgs>(args?: SelectSubset<T, DeviceSyncStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceSyncStates and returns the data saved in the database.
     * @param {DeviceSyncStateCreateManyAndReturnArgs} args - Arguments to create many DeviceSyncStates.
     * @example
     * // Create many DeviceSyncStates
     * const deviceSyncState = await prisma.deviceSyncState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceSyncStates and only return the `id`
     * const deviceSyncStateWithIdOnly = await prisma.deviceSyncState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceSyncStateCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceSyncStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceSyncState.
     * @param {DeviceSyncStateDeleteArgs} args - Arguments to delete one DeviceSyncState.
     * @example
     * // Delete one DeviceSyncState
     * const DeviceSyncState = await prisma.deviceSyncState.delete({
     *   where: {
     *     // ... filter to delete one DeviceSyncState
     *   }
     * })
     * 
     */
    delete<T extends DeviceSyncStateDeleteArgs>(args: SelectSubset<T, DeviceSyncStateDeleteArgs<ExtArgs>>): Prisma__DeviceSyncStateClient<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceSyncState.
     * @param {DeviceSyncStateUpdateArgs} args - Arguments to update one DeviceSyncState.
     * @example
     * // Update one DeviceSyncState
     * const deviceSyncState = await prisma.deviceSyncState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceSyncStateUpdateArgs>(args: SelectSubset<T, DeviceSyncStateUpdateArgs<ExtArgs>>): Prisma__DeviceSyncStateClient<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceSyncStates.
     * @param {DeviceSyncStateDeleteManyArgs} args - Arguments to filter DeviceSyncStates to delete.
     * @example
     * // Delete a few DeviceSyncStates
     * const { count } = await prisma.deviceSyncState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceSyncStateDeleteManyArgs>(args?: SelectSubset<T, DeviceSyncStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceSyncStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSyncStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceSyncStates
     * const deviceSyncState = await prisma.deviceSyncState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceSyncStateUpdateManyArgs>(args: SelectSubset<T, DeviceSyncStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceSyncStates and returns the data updated in the database.
     * @param {DeviceSyncStateUpdateManyAndReturnArgs} args - Arguments to update many DeviceSyncStates.
     * @example
     * // Update many DeviceSyncStates
     * const deviceSyncState = await prisma.deviceSyncState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceSyncStates and only return the `id`
     * const deviceSyncStateWithIdOnly = await prisma.deviceSyncState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceSyncStateUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceSyncStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceSyncState.
     * @param {DeviceSyncStateUpsertArgs} args - Arguments to update or create a DeviceSyncState.
     * @example
     * // Update or create a DeviceSyncState
     * const deviceSyncState = await prisma.deviceSyncState.upsert({
     *   create: {
     *     // ... data to create a DeviceSyncState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceSyncState we want to update
     *   }
     * })
     */
    upsert<T extends DeviceSyncStateUpsertArgs>(args: SelectSubset<T, DeviceSyncStateUpsertArgs<ExtArgs>>): Prisma__DeviceSyncStateClient<$Result.GetResult<Prisma.$DeviceSyncStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceSyncStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSyncStateCountArgs} args - Arguments to filter DeviceSyncStates to count.
     * @example
     * // Count the number of DeviceSyncStates
     * const count = await prisma.deviceSyncState.count({
     *   where: {
     *     // ... the filter for the DeviceSyncStates we want to count
     *   }
     * })
    **/
    count<T extends DeviceSyncStateCountArgs>(
      args?: Subset<T, DeviceSyncStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceSyncStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceSyncState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSyncStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceSyncStateAggregateArgs>(args: Subset<T, DeviceSyncStateAggregateArgs>): Prisma.PrismaPromise<GetDeviceSyncStateAggregateType<T>>

    /**
     * Group by DeviceSyncState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceSyncStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceSyncStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceSyncStateGroupByArgs['orderBy'] }
        : { orderBy?: DeviceSyncStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceSyncStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceSyncStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceSyncState model
   */
  readonly fields: DeviceSyncStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceSyncState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceSyncStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends UserDeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDeviceDefaultArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceSyncState model
   */
  interface DeviceSyncStateFieldRefs {
    readonly id: FieldRef<"DeviceSyncState", 'String'>
    readonly userId: FieldRef<"DeviceSyncState", 'String'>
    readonly deviceId: FieldRef<"DeviceSyncState", 'String'>
    readonly syncType: FieldRef<"DeviceSyncState", 'SyncType'>
    readonly lastSyncVersion: FieldRef<"DeviceSyncState", 'BigInt'>
    readonly lastSyncAt: FieldRef<"DeviceSyncState", 'DateTime'>
    readonly pendingChanges: FieldRef<"DeviceSyncState", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeviceSyncState findUnique
   */
  export type DeviceSyncStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSyncState to fetch.
     */
    where: DeviceSyncStateWhereUniqueInput
  }

  /**
   * DeviceSyncState findUniqueOrThrow
   */
  export type DeviceSyncStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSyncState to fetch.
     */
    where: DeviceSyncStateWhereUniqueInput
  }

  /**
   * DeviceSyncState findFirst
   */
  export type DeviceSyncStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSyncState to fetch.
     */
    where?: DeviceSyncStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceSyncStates to fetch.
     */
    orderBy?: DeviceSyncStateOrderByWithRelationInput | DeviceSyncStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceSyncStates.
     */
    cursor?: DeviceSyncStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceSyncStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceSyncStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceSyncStates.
     */
    distinct?: DeviceSyncStateScalarFieldEnum | DeviceSyncStateScalarFieldEnum[]
  }

  /**
   * DeviceSyncState findFirstOrThrow
   */
  export type DeviceSyncStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSyncState to fetch.
     */
    where?: DeviceSyncStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceSyncStates to fetch.
     */
    orderBy?: DeviceSyncStateOrderByWithRelationInput | DeviceSyncStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceSyncStates.
     */
    cursor?: DeviceSyncStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceSyncStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceSyncStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceSyncStates.
     */
    distinct?: DeviceSyncStateScalarFieldEnum | DeviceSyncStateScalarFieldEnum[]
  }

  /**
   * DeviceSyncState findMany
   */
  export type DeviceSyncStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    /**
     * Filter, which DeviceSyncStates to fetch.
     */
    where?: DeviceSyncStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceSyncStates to fetch.
     */
    orderBy?: DeviceSyncStateOrderByWithRelationInput | DeviceSyncStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceSyncStates.
     */
    cursor?: DeviceSyncStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceSyncStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceSyncStates.
     */
    skip?: number
    distinct?: DeviceSyncStateScalarFieldEnum | DeviceSyncStateScalarFieldEnum[]
  }

  /**
   * DeviceSyncState create
   */
  export type DeviceSyncStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceSyncState.
     */
    data: XOR<DeviceSyncStateCreateInput, DeviceSyncStateUncheckedCreateInput>
  }

  /**
   * DeviceSyncState createMany
   */
  export type DeviceSyncStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceSyncStates.
     */
    data: DeviceSyncStateCreateManyInput | DeviceSyncStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceSyncState createManyAndReturn
   */
  export type DeviceSyncStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceSyncStates.
     */
    data: DeviceSyncStateCreateManyInput | DeviceSyncStateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceSyncState update
   */
  export type DeviceSyncStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceSyncState.
     */
    data: XOR<DeviceSyncStateUpdateInput, DeviceSyncStateUncheckedUpdateInput>
    /**
     * Choose, which DeviceSyncState to update.
     */
    where: DeviceSyncStateWhereUniqueInput
  }

  /**
   * DeviceSyncState updateMany
   */
  export type DeviceSyncStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceSyncStates.
     */
    data: XOR<DeviceSyncStateUpdateManyMutationInput, DeviceSyncStateUncheckedUpdateManyInput>
    /**
     * Filter which DeviceSyncStates to update
     */
    where?: DeviceSyncStateWhereInput
    /**
     * Limit how many DeviceSyncStates to update.
     */
    limit?: number
  }

  /**
   * DeviceSyncState updateManyAndReturn
   */
  export type DeviceSyncStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * The data used to update DeviceSyncStates.
     */
    data: XOR<DeviceSyncStateUpdateManyMutationInput, DeviceSyncStateUncheckedUpdateManyInput>
    /**
     * Filter which DeviceSyncStates to update
     */
    where?: DeviceSyncStateWhereInput
    /**
     * Limit how many DeviceSyncStates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceSyncState upsert
   */
  export type DeviceSyncStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceSyncState to update in case it exists.
     */
    where: DeviceSyncStateWhereUniqueInput
    /**
     * In case the DeviceSyncState found by the `where` argument doesn't exist, create a new DeviceSyncState with this data.
     */
    create: XOR<DeviceSyncStateCreateInput, DeviceSyncStateUncheckedCreateInput>
    /**
     * In case the DeviceSyncState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceSyncStateUpdateInput, DeviceSyncStateUncheckedUpdateInput>
  }

  /**
   * DeviceSyncState delete
   */
  export type DeviceSyncStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
    /**
     * Filter which DeviceSyncState to delete.
     */
    where: DeviceSyncStateWhereUniqueInput
  }

  /**
   * DeviceSyncState deleteMany
   */
  export type DeviceSyncStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceSyncStates to delete
     */
    where?: DeviceSyncStateWhereInput
    /**
     * Limit how many DeviceSyncStates to delete.
     */
    limit?: number
  }

  /**
   * DeviceSyncState without action
   */
  export type DeviceSyncStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceSyncState
     */
    select?: DeviceSyncStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceSyncState
     */
    omit?: DeviceSyncStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceSyncStateInclude<ExtArgs> | null
  }


  /**
   * Model SyncLog
   */

  export type AggregateSyncLog = {
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  export type SyncLogAvgAggregateOutputType = {
    version: number | null
  }

  export type SyncLogSumAggregateOutputType = {
    version: bigint | null
  }

  export type SyncLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    entityType: string | null
    entityId: string | null
    action: $Enums.SyncAction | null
    version: bigint | null
    sourceDeviceId: string | null
    createdAt: Date | null
  }

  export type SyncLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    entityType: string | null
    entityId: string | null
    action: $Enums.SyncAction | null
    version: bigint | null
    sourceDeviceId: string | null
    createdAt: Date | null
  }

  export type SyncLogCountAggregateOutputType = {
    id: number
    userId: number
    entityType: number
    entityId: number
    action: number
    version: number
    payload: number
    sourceDeviceId: number
    createdAt: number
    _all: number
  }


  export type SyncLogAvgAggregateInputType = {
    version?: true
  }

  export type SyncLogSumAggregateInputType = {
    version?: true
  }

  export type SyncLogMinAggregateInputType = {
    id?: true
    userId?: true
    entityType?: true
    entityId?: true
    action?: true
    version?: true
    sourceDeviceId?: true
    createdAt?: true
  }

  export type SyncLogMaxAggregateInputType = {
    id?: true
    userId?: true
    entityType?: true
    entityId?: true
    action?: true
    version?: true
    sourceDeviceId?: true
    createdAt?: true
  }

  export type SyncLogCountAggregateInputType = {
    id?: true
    userId?: true
    entityType?: true
    entityId?: true
    action?: true
    version?: true
    payload?: true
    sourceDeviceId?: true
    createdAt?: true
    _all?: true
  }

  export type SyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLog to aggregate.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncLogs
    **/
    _count?: true | SyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncLogMaxAggregateInputType
  }

  export type GetSyncLogAggregateType<T extends SyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncLog[P]>
      : GetScalarType<T[P], AggregateSyncLog[P]>
  }




  export type SyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithAggregationInput | SyncLogOrderByWithAggregationInput[]
    by: SyncLogScalarFieldEnum[] | SyncLogScalarFieldEnum
    having?: SyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncLogCountAggregateInputType | true
    _avg?: SyncLogAvgAggregateInputType
    _sum?: SyncLogSumAggregateInputType
    _min?: SyncLogMinAggregateInputType
    _max?: SyncLogMaxAggregateInputType
  }

  export type SyncLogGroupByOutputType = {
    id: string
    userId: string
    entityType: string
    entityId: string
    action: $Enums.SyncAction
    version: bigint
    payload: JsonValue | null
    sourceDeviceId: string | null
    createdAt: Date
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  type GetSyncLogGroupByPayload<T extends SyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
        }
      >
    >


  export type SyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    version?: boolean
    payload?: boolean
    sourceDeviceId?: boolean
    createdAt?: boolean
    sourceDevice?: boolean | SyncLog$sourceDeviceArgs<ExtArgs>
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    version?: boolean
    payload?: boolean
    sourceDeviceId?: boolean
    createdAt?: boolean
    sourceDevice?: boolean | SyncLog$sourceDeviceArgs<ExtArgs>
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    version?: boolean
    payload?: boolean
    sourceDeviceId?: boolean
    createdAt?: boolean
    sourceDevice?: boolean | SyncLog$sourceDeviceArgs<ExtArgs>
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectScalar = {
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    version?: boolean
    payload?: boolean
    sourceDeviceId?: boolean
    createdAt?: boolean
  }

  export type SyncLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "entityType" | "entityId" | "action" | "version" | "payload" | "sourceDeviceId" | "createdAt", ExtArgs["result"]["syncLog"]>
  export type SyncLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceDevice?: boolean | SyncLog$sourceDeviceArgs<ExtArgs>
  }
  export type SyncLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceDevice?: boolean | SyncLog$sourceDeviceArgs<ExtArgs>
  }
  export type SyncLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceDevice?: boolean | SyncLog$sourceDeviceArgs<ExtArgs>
  }

  export type $SyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncLog"
    objects: {
      sourceDevice: Prisma.$UserDevicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      entityType: string
      entityId: string
      action: $Enums.SyncAction
      version: bigint
      payload: Prisma.JsonValue | null
      sourceDeviceId: string | null
      createdAt: Date
    }, ExtArgs["result"]["syncLog"]>
    composites: {}
  }

  type SyncLogGetPayload<S extends boolean | null | undefined | SyncLogDefaultArgs> = $Result.GetResult<Prisma.$SyncLogPayload, S>

  type SyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncLogCountAggregateInputType | true
    }

  export interface SyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncLog'], meta: { name: 'SyncLog' } }
    /**
     * Find zero or one SyncLog that matches the filter.
     * @param {SyncLogFindUniqueArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncLogFindUniqueArgs>(args: SelectSubset<T, SyncLogFindUniqueArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncLogFindUniqueOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncLogFindFirstArgs>(args?: SelectSubset<T, SyncLogFindFirstArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncLogs
     * const syncLogs = await prisma.syncLog.findMany()
     * 
     * // Get first 10 SyncLogs
     * const syncLogs = await prisma.syncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncLogFindManyArgs>(args?: SelectSubset<T, SyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncLog.
     * @param {SyncLogCreateArgs} args - Arguments to create a SyncLog.
     * @example
     * // Create one SyncLog
     * const SyncLog = await prisma.syncLog.create({
     *   data: {
     *     // ... data to create a SyncLog
     *   }
     * })
     * 
     */
    create<T extends SyncLogCreateArgs>(args: SelectSubset<T, SyncLogCreateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncLogs.
     * @param {SyncLogCreateManyArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncLogCreateManyArgs>(args?: SelectSubset<T, SyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncLogs and returns the data saved in the database.
     * @param {SyncLogCreateManyAndReturnArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncLog.
     * @param {SyncLogDeleteArgs} args - Arguments to delete one SyncLog.
     * @example
     * // Delete one SyncLog
     * const SyncLog = await prisma.syncLog.delete({
     *   where: {
     *     // ... filter to delete one SyncLog
     *   }
     * })
     * 
     */
    delete<T extends SyncLogDeleteArgs>(args: SelectSubset<T, SyncLogDeleteArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncLog.
     * @param {SyncLogUpdateArgs} args - Arguments to update one SyncLog.
     * @example
     * // Update one SyncLog
     * const syncLog = await prisma.syncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncLogUpdateArgs>(args: SelectSubset<T, SyncLogUpdateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncLogs.
     * @param {SyncLogDeleteManyArgs} args - Arguments to filter SyncLogs to delete.
     * @example
     * // Delete a few SyncLogs
     * const { count } = await prisma.syncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncLogDeleteManyArgs>(args?: SelectSubset<T, SyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncLogUpdateManyArgs>(args: SelectSubset<T, SyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs and returns the data updated in the database.
     * @param {SyncLogUpdateManyAndReturnArgs} args - Arguments to update many SyncLogs.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncLog.
     * @param {SyncLogUpsertArgs} args - Arguments to update or create a SyncLog.
     * @example
     * // Update or create a SyncLog
     * const syncLog = await prisma.syncLog.upsert({
     *   create: {
     *     // ... data to create a SyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncLog we want to update
     *   }
     * })
     */
    upsert<T extends SyncLogUpsertArgs>(args: SelectSubset<T, SyncLogUpsertArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogCountArgs} args - Arguments to filter SyncLogs to count.
     * @example
     * // Count the number of SyncLogs
     * const count = await prisma.syncLog.count({
     *   where: {
     *     // ... the filter for the SyncLogs we want to count
     *   }
     * })
    **/
    count<T extends SyncLogCountArgs>(
      args?: Subset<T, SyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncLogAggregateArgs>(args: Subset<T, SyncLogAggregateArgs>): Prisma.PrismaPromise<GetSyncLogAggregateType<T>>

    /**
     * Group by SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncLogGroupByArgs['orderBy'] }
        : { orderBy?: SyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncLog model
   */
  readonly fields: SyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceDevice<T extends SyncLog$sourceDeviceArgs<ExtArgs> = {}>(args?: Subset<T, SyncLog$sourceDeviceArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncLog model
   */
  interface SyncLogFieldRefs {
    readonly id: FieldRef<"SyncLog", 'String'>
    readonly userId: FieldRef<"SyncLog", 'String'>
    readonly entityType: FieldRef<"SyncLog", 'String'>
    readonly entityId: FieldRef<"SyncLog", 'String'>
    readonly action: FieldRef<"SyncLog", 'SyncAction'>
    readonly version: FieldRef<"SyncLog", 'BigInt'>
    readonly payload: FieldRef<"SyncLog", 'Json'>
    readonly sourceDeviceId: FieldRef<"SyncLog", 'String'>
    readonly createdAt: FieldRef<"SyncLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncLog findUnique
   */
  export type SyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findUniqueOrThrow
   */
  export type SyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findFirst
   */
  export type SyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findFirstOrThrow
   */
  export type SyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findMany
   */
  export type SyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLogs to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog create
   */
  export type SyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SyncLog.
     */
    data: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
  }

  /**
   * SyncLog createMany
   */
  export type SyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncLog createManyAndReturn
   */
  export type SyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyncLog update
   */
  export type SyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SyncLog.
     */
    data: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
    /**
     * Choose, which SyncLog to update.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog updateMany
   */
  export type SyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to update.
     */
    limit?: number
  }

  /**
   * SyncLog updateManyAndReturn
   */
  export type SyncLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyncLog upsert
   */
  export type SyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SyncLog to update in case it exists.
     */
    where: SyncLogWhereUniqueInput
    /**
     * In case the SyncLog found by the `where` argument doesn't exist, create a new SyncLog with this data.
     */
    create: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
    /**
     * In case the SyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
  }

  /**
   * SyncLog delete
   */
  export type SyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter which SyncLog to delete.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog deleteMany
   */
  export type SyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLogs to delete
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to delete.
     */
    limit?: number
  }

  /**
   * SyncLog.sourceDevice
   */
  export type SyncLog$sourceDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    where?: UserDeviceWhereInput
  }

  /**
   * SyncLog without action
   */
  export type SyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
  }


  /**
   * Model DeviceTransfer
   */

  export type AggregateDeviceTransfer = {
    _count: DeviceTransferCountAggregateOutputType | null
    _min: DeviceTransferMinAggregateOutputType | null
    _max: DeviceTransferMaxAggregateOutputType | null
  }

  export type DeviceTransferMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fromDeviceId: string | null
    toDeviceId: string | null
    status: $Enums.TransferStatus | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type DeviceTransferMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fromDeviceId: string | null
    toDeviceId: string | null
    status: $Enums.TransferStatus | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type DeviceTransferCountAggregateOutputType = {
    id: number
    userId: number
    fromDeviceId: number
    toDeviceId: number
    status: number
    transferData: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type DeviceTransferMinAggregateInputType = {
    id?: true
    userId?: true
    fromDeviceId?: true
    toDeviceId?: true
    status?: true
    createdAt?: true
    expiresAt?: true
  }

  export type DeviceTransferMaxAggregateInputType = {
    id?: true
    userId?: true
    fromDeviceId?: true
    toDeviceId?: true
    status?: true
    createdAt?: true
    expiresAt?: true
  }

  export type DeviceTransferCountAggregateInputType = {
    id?: true
    userId?: true
    fromDeviceId?: true
    toDeviceId?: true
    status?: true
    transferData?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type DeviceTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTransfer to aggregate.
     */
    where?: DeviceTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTransfers to fetch.
     */
    orderBy?: DeviceTransferOrderByWithRelationInput | DeviceTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTransfers
    **/
    _count?: true | DeviceTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTransferMaxAggregateInputType
  }

  export type GetDeviceTransferAggregateType<T extends DeviceTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceTransfer[P]>
      : GetScalarType<T[P], AggregateDeviceTransfer[P]>
  }




  export type DeviceTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTransferWhereInput
    orderBy?: DeviceTransferOrderByWithAggregationInput | DeviceTransferOrderByWithAggregationInput[]
    by: DeviceTransferScalarFieldEnum[] | DeviceTransferScalarFieldEnum
    having?: DeviceTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTransferCountAggregateInputType | true
    _min?: DeviceTransferMinAggregateInputType
    _max?: DeviceTransferMaxAggregateInputType
  }

  export type DeviceTransferGroupByOutputType = {
    id: string
    userId: string
    fromDeviceId: string
    toDeviceId: string
    status: $Enums.TransferStatus
    transferData: JsonValue | null
    createdAt: Date
    expiresAt: Date
    _count: DeviceTransferCountAggregateOutputType | null
    _min: DeviceTransferMinAggregateOutputType | null
    _max: DeviceTransferMaxAggregateOutputType | null
  }

  type GetDeviceTransferGroupByPayload<T extends DeviceTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTransferGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTransferGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fromDeviceId?: boolean
    toDeviceId?: boolean
    status?: boolean
    transferData?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    fromDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
    toDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceTransfer"]>

  export type DeviceTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fromDeviceId?: boolean
    toDeviceId?: boolean
    status?: boolean
    transferData?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    fromDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
    toDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceTransfer"]>

  export type DeviceTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fromDeviceId?: boolean
    toDeviceId?: boolean
    status?: boolean
    transferData?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    fromDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
    toDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceTransfer"]>

  export type DeviceTransferSelectScalar = {
    id?: boolean
    userId?: boolean
    fromDeviceId?: boolean
    toDeviceId?: boolean
    status?: boolean
    transferData?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type DeviceTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fromDeviceId" | "toDeviceId" | "status" | "transferData" | "createdAt" | "expiresAt", ExtArgs["result"]["deviceTransfer"]>
  export type DeviceTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
    toDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }
  export type DeviceTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
    toDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }
  export type DeviceTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
    toDevice?: boolean | UserDeviceDefaultArgs<ExtArgs>
  }

  export type $DeviceTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceTransfer"
    objects: {
      fromDevice: Prisma.$UserDevicePayload<ExtArgs>
      toDevice: Prisma.$UserDevicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fromDeviceId: string
      toDeviceId: string
      status: $Enums.TransferStatus
      transferData: Prisma.JsonValue | null
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["deviceTransfer"]>
    composites: {}
  }

  type DeviceTransferGetPayload<S extends boolean | null | undefined | DeviceTransferDefaultArgs> = $Result.GetResult<Prisma.$DeviceTransferPayload, S>

  type DeviceTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceTransferCountAggregateInputType | true
    }

  export interface DeviceTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceTransfer'], meta: { name: 'DeviceTransfer' } }
    /**
     * Find zero or one DeviceTransfer that matches the filter.
     * @param {DeviceTransferFindUniqueArgs} args - Arguments to find a DeviceTransfer
     * @example
     * // Get one DeviceTransfer
     * const deviceTransfer = await prisma.deviceTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTransferFindUniqueArgs>(args: SelectSubset<T, DeviceTransferFindUniqueArgs<ExtArgs>>): Prisma__DeviceTransferClient<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceTransferFindUniqueOrThrowArgs} args - Arguments to find a DeviceTransfer
     * @example
     * // Get one DeviceTransfer
     * const deviceTransfer = await prisma.deviceTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTransferClient<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTransferFindFirstArgs} args - Arguments to find a DeviceTransfer
     * @example
     * // Get one DeviceTransfer
     * const deviceTransfer = await prisma.deviceTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTransferFindFirstArgs>(args?: SelectSubset<T, DeviceTransferFindFirstArgs<ExtArgs>>): Prisma__DeviceTransferClient<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTransferFindFirstOrThrowArgs} args - Arguments to find a DeviceTransfer
     * @example
     * // Get one DeviceTransfer
     * const deviceTransfer = await prisma.deviceTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTransferClient<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTransfers
     * const deviceTransfers = await prisma.deviceTransfer.findMany()
     * 
     * // Get first 10 DeviceTransfers
     * const deviceTransfers = await prisma.deviceTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTransferWithIdOnly = await prisma.deviceTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTransferFindManyArgs>(args?: SelectSubset<T, DeviceTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceTransfer.
     * @param {DeviceTransferCreateArgs} args - Arguments to create a DeviceTransfer.
     * @example
     * // Create one DeviceTransfer
     * const DeviceTransfer = await prisma.deviceTransfer.create({
     *   data: {
     *     // ... data to create a DeviceTransfer
     *   }
     * })
     * 
     */
    create<T extends DeviceTransferCreateArgs>(args: SelectSubset<T, DeviceTransferCreateArgs<ExtArgs>>): Prisma__DeviceTransferClient<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceTransfers.
     * @param {DeviceTransferCreateManyArgs} args - Arguments to create many DeviceTransfers.
     * @example
     * // Create many DeviceTransfers
     * const deviceTransfer = await prisma.deviceTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTransferCreateManyArgs>(args?: SelectSubset<T, DeviceTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTransfers and returns the data saved in the database.
     * @param {DeviceTransferCreateManyAndReturnArgs} args - Arguments to create many DeviceTransfers.
     * @example
     * // Create many DeviceTransfers
     * const deviceTransfer = await prisma.deviceTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTransfers and only return the `id`
     * const deviceTransferWithIdOnly = await prisma.deviceTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceTransfer.
     * @param {DeviceTransferDeleteArgs} args - Arguments to delete one DeviceTransfer.
     * @example
     * // Delete one DeviceTransfer
     * const DeviceTransfer = await prisma.deviceTransfer.delete({
     *   where: {
     *     // ... filter to delete one DeviceTransfer
     *   }
     * })
     * 
     */
    delete<T extends DeviceTransferDeleteArgs>(args: SelectSubset<T, DeviceTransferDeleteArgs<ExtArgs>>): Prisma__DeviceTransferClient<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceTransfer.
     * @param {DeviceTransferUpdateArgs} args - Arguments to update one DeviceTransfer.
     * @example
     * // Update one DeviceTransfer
     * const deviceTransfer = await prisma.deviceTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTransferUpdateArgs>(args: SelectSubset<T, DeviceTransferUpdateArgs<ExtArgs>>): Prisma__DeviceTransferClient<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceTransfers.
     * @param {DeviceTransferDeleteManyArgs} args - Arguments to filter DeviceTransfers to delete.
     * @example
     * // Delete a few DeviceTransfers
     * const { count } = await prisma.deviceTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTransferDeleteManyArgs>(args?: SelectSubset<T, DeviceTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTransfers
     * const deviceTransfer = await prisma.deviceTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTransferUpdateManyArgs>(args: SelectSubset<T, DeviceTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTransfers and returns the data updated in the database.
     * @param {DeviceTransferUpdateManyAndReturnArgs} args - Arguments to update many DeviceTransfers.
     * @example
     * // Update many DeviceTransfers
     * const deviceTransfer = await prisma.deviceTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceTransfers and only return the `id`
     * const deviceTransferWithIdOnly = await prisma.deviceTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceTransfer.
     * @param {DeviceTransferUpsertArgs} args - Arguments to update or create a DeviceTransfer.
     * @example
     * // Update or create a DeviceTransfer
     * const deviceTransfer = await prisma.deviceTransfer.upsert({
     *   create: {
     *     // ... data to create a DeviceTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceTransfer we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTransferUpsertArgs>(args: SelectSubset<T, DeviceTransferUpsertArgs<ExtArgs>>): Prisma__DeviceTransferClient<$Result.GetResult<Prisma.$DeviceTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTransferCountArgs} args - Arguments to filter DeviceTransfers to count.
     * @example
     * // Count the number of DeviceTransfers
     * const count = await prisma.deviceTransfer.count({
     *   where: {
     *     // ... the filter for the DeviceTransfers we want to count
     *   }
     * })
    **/
    count<T extends DeviceTransferCountArgs>(
      args?: Subset<T, DeviceTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTransferAggregateArgs>(args: Subset<T, DeviceTransferAggregateArgs>): Prisma.PrismaPromise<GetDeviceTransferAggregateType<T>>

    /**
     * Group by DeviceTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTransferGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceTransfer model
   */
  readonly fields: DeviceTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromDevice<T extends UserDeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDeviceDefaultArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toDevice<T extends UserDeviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDeviceDefaultArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceTransfer model
   */
  interface DeviceTransferFieldRefs {
    readonly id: FieldRef<"DeviceTransfer", 'String'>
    readonly userId: FieldRef<"DeviceTransfer", 'String'>
    readonly fromDeviceId: FieldRef<"DeviceTransfer", 'String'>
    readonly toDeviceId: FieldRef<"DeviceTransfer", 'String'>
    readonly status: FieldRef<"DeviceTransfer", 'TransferStatus'>
    readonly transferData: FieldRef<"DeviceTransfer", 'Json'>
    readonly createdAt: FieldRef<"DeviceTransfer", 'DateTime'>
    readonly expiresAt: FieldRef<"DeviceTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceTransfer findUnique
   */
  export type DeviceTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTransfer to fetch.
     */
    where: DeviceTransferWhereUniqueInput
  }

  /**
   * DeviceTransfer findUniqueOrThrow
   */
  export type DeviceTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTransfer to fetch.
     */
    where: DeviceTransferWhereUniqueInput
  }

  /**
   * DeviceTransfer findFirst
   */
  export type DeviceTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTransfer to fetch.
     */
    where?: DeviceTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTransfers to fetch.
     */
    orderBy?: DeviceTransferOrderByWithRelationInput | DeviceTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTransfers.
     */
    cursor?: DeviceTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTransfers.
     */
    distinct?: DeviceTransferScalarFieldEnum | DeviceTransferScalarFieldEnum[]
  }

  /**
   * DeviceTransfer findFirstOrThrow
   */
  export type DeviceTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTransfer to fetch.
     */
    where?: DeviceTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTransfers to fetch.
     */
    orderBy?: DeviceTransferOrderByWithRelationInput | DeviceTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTransfers.
     */
    cursor?: DeviceTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTransfers.
     */
    distinct?: DeviceTransferScalarFieldEnum | DeviceTransferScalarFieldEnum[]
  }

  /**
   * DeviceTransfer findMany
   */
  export type DeviceTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTransfers to fetch.
     */
    where?: DeviceTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTransfers to fetch.
     */
    orderBy?: DeviceTransferOrderByWithRelationInput | DeviceTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTransfers.
     */
    cursor?: DeviceTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTransfers.
     */
    skip?: number
    distinct?: DeviceTransferScalarFieldEnum | DeviceTransferScalarFieldEnum[]
  }

  /**
   * DeviceTransfer create
   */
  export type DeviceTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceTransfer.
     */
    data: XOR<DeviceTransferCreateInput, DeviceTransferUncheckedCreateInput>
  }

  /**
   * DeviceTransfer createMany
   */
  export type DeviceTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTransfers.
     */
    data: DeviceTransferCreateManyInput | DeviceTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceTransfer createManyAndReturn
   */
  export type DeviceTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceTransfers.
     */
    data: DeviceTransferCreateManyInput | DeviceTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceTransfer update
   */
  export type DeviceTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceTransfer.
     */
    data: XOR<DeviceTransferUpdateInput, DeviceTransferUncheckedUpdateInput>
    /**
     * Choose, which DeviceTransfer to update.
     */
    where: DeviceTransferWhereUniqueInput
  }

  /**
   * DeviceTransfer updateMany
   */
  export type DeviceTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTransfers.
     */
    data: XOR<DeviceTransferUpdateManyMutationInput, DeviceTransferUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTransfers to update
     */
    where?: DeviceTransferWhereInput
    /**
     * Limit how many DeviceTransfers to update.
     */
    limit?: number
  }

  /**
   * DeviceTransfer updateManyAndReturn
   */
  export type DeviceTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * The data used to update DeviceTransfers.
     */
    data: XOR<DeviceTransferUpdateManyMutationInput, DeviceTransferUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTransfers to update
     */
    where?: DeviceTransferWhereInput
    /**
     * Limit how many DeviceTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceTransfer upsert
   */
  export type DeviceTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceTransfer to update in case it exists.
     */
    where: DeviceTransferWhereUniqueInput
    /**
     * In case the DeviceTransfer found by the `where` argument doesn't exist, create a new DeviceTransfer with this data.
     */
    create: XOR<DeviceTransferCreateInput, DeviceTransferUncheckedCreateInput>
    /**
     * In case the DeviceTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTransferUpdateInput, DeviceTransferUncheckedUpdateInput>
  }

  /**
   * DeviceTransfer delete
   */
  export type DeviceTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
    /**
     * Filter which DeviceTransfer to delete.
     */
    where: DeviceTransferWhereUniqueInput
  }

  /**
   * DeviceTransfer deleteMany
   */
  export type DeviceTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTransfers to delete
     */
    where?: DeviceTransferWhereInput
    /**
     * Limit how many DeviceTransfers to delete.
     */
    limit?: number
  }

  /**
   * DeviceTransfer without action
   */
  export type DeviceTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceTransfer
     */
    select?: DeviceTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceTransfer
     */
    omit?: DeviceTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTransferInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  export type SubscriptionPlanAvgAggregateOutputType = {
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    maxDevices: number | null
    skipLimit: number | null
  }

  export type SubscriptionPlanSumAggregateOutputType = {
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    maxDevices: number | null
    skipLimit: number | null
  }

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    currency: string | null
    maxDevices: number | null
    hasAds: boolean | null
    canDownload: boolean | null
    audioQuality: $Enums.AudioQuality | null
    smartShuffle: boolean | null
    skipLimit: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    currency: string | null
    maxDevices: number | null
    hasAds: boolean | null
    canDownload: boolean | null
    audioQuality: $Enums.AudioQuality | null
    smartShuffle: boolean | null
    skipLimit: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    priceMonthly: number
    priceYearly: number
    currency: number
    maxDevices: number
    hasAds: number
    canDownload: number
    audioQuality: number
    smartShuffle: number
    skipLimit: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type SubscriptionPlanAvgAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
    maxDevices?: true
    skipLimit?: true
  }

  export type SubscriptionPlanSumAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
    maxDevices?: true
    skipLimit?: true
  }

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    currency?: true
    maxDevices?: true
    hasAds?: true
    canDownload?: true
    audioQuality?: true
    smartShuffle?: true
    skipLimit?: true
    isActive?: true
    createdAt?: true
  }

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    currency?: true
    maxDevices?: true
    hasAds?: true
    canDownload?: true
    audioQuality?: true
    smartShuffle?: true
    skipLimit?: true
    isActive?: true
    createdAt?: true
  }

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    currency?: true
    maxDevices?: true
    hasAds?: true
    canDownload?: true
    audioQuality?: true
    smartShuffle?: true
    skipLimit?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type SubscriptionPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPlans
    **/
    _count?: true | SubscriptionPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type GetSubscriptionPlanAggregateType<T extends SubscriptionPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
  }




  export type SubscriptionPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPlanWhereInput
    orderBy?: SubscriptionPlanOrderByWithAggregationInput | SubscriptionPlanOrderByWithAggregationInput[]
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum
    having?: SubscriptionPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPlanCountAggregateInputType | true
    _avg?: SubscriptionPlanAvgAggregateInputType
    _sum?: SubscriptionPlanSumAggregateInputType
    _min?: SubscriptionPlanMinAggregateInputType
    _max?: SubscriptionPlanMaxAggregateInputType
  }

  export type SubscriptionPlanGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    priceMonthly: Decimal
    priceYearly: Decimal
    currency: string
    maxDevices: number
    hasAds: boolean
    canDownload: boolean
    audioQuality: $Enums.AudioQuality
    smartShuffle: boolean
    skipLimit: number | null
    isActive: boolean
    createdAt: Date
    _count: SubscriptionPlanCountAggregateOutputType | null
    _avg: SubscriptionPlanAvgAggregateOutputType | null
    _sum: SubscriptionPlanSumAggregateOutputType | null
    _min: SubscriptionPlanMinAggregateOutputType | null
    _max: SubscriptionPlanMaxAggregateOutputType | null
  }

  type GetSubscriptionPlanGroupByPayload<T extends SubscriptionPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    currency?: boolean
    maxDevices?: boolean
    hasAds?: boolean
    canDownload?: boolean
    audioQuality?: boolean
    smartShuffle?: boolean
    skipLimit?: boolean
    isActive?: boolean
    createdAt?: boolean
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    currency?: boolean
    maxDevices?: boolean
    hasAds?: boolean
    canDownload?: boolean
    audioQuality?: boolean
    smartShuffle?: boolean
    skipLimit?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    currency?: boolean
    maxDevices?: boolean
    hasAds?: boolean
    canDownload?: boolean
    audioQuality?: boolean
    smartShuffle?: boolean
    skipLimit?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["subscriptionPlan"]>

  export type SubscriptionPlanSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    currency?: boolean
    maxDevices?: boolean
    hasAds?: boolean
    canDownload?: boolean
    audioQuality?: boolean
    smartShuffle?: boolean
    skipLimit?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type SubscriptionPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "priceMonthly" | "priceYearly" | "currency" | "maxDevices" | "hasAds" | "canDownload" | "audioQuality" | "smartShuffle" | "skipLimit" | "isActive" | "createdAt", ExtArgs["result"]["subscriptionPlan"]>
  export type SubscriptionPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | SubscriptionPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SubscriptionPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPlan"
    objects: {
      subscriptions: Prisma.$UserSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      priceMonthly: Prisma.Decimal
      priceYearly: Prisma.Decimal
      currency: string
      maxDevices: number
      hasAds: boolean
      canDownload: boolean
      audioQuality: $Enums.AudioQuality
      smartShuffle: boolean
      skipLimit: number | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["subscriptionPlan"]>
    composites: {}
  }

  type SubscriptionPlanGetPayload<S extends boolean | null | undefined | SubscriptionPlanDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>

  type SubscriptionPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionPlanCountAggregateInputType | true
    }

  export interface SubscriptionPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'], meta: { name: 'SubscriptionPlan' } }
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     * 
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPlanCreateArgs>(args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPlanDeleteArgs>(args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPlanUpdateArgs>(args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPlans and returns the data updated in the database.
     * @param {SubscriptionPlanUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionPlans.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(args: Subset<T, SubscriptionPlanAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPlan model
   */
  readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends SubscriptionPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPlan model
   */
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<"SubscriptionPlan", 'String'>
    readonly name: FieldRef<"SubscriptionPlan", 'String'>
    readonly slug: FieldRef<"SubscriptionPlan", 'String'>
    readonly description: FieldRef<"SubscriptionPlan", 'String'>
    readonly priceMonthly: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly priceYearly: FieldRef<"SubscriptionPlan", 'Decimal'>
    readonly currency: FieldRef<"SubscriptionPlan", 'String'>
    readonly maxDevices: FieldRef<"SubscriptionPlan", 'Int'>
    readonly hasAds: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly canDownload: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly audioQuality: FieldRef<"SubscriptionPlan", 'AudioQuality'>
    readonly smartShuffle: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly skipLimit: FieldRef<"SubscriptionPlan", 'Int'>
    readonly isActive: FieldRef<"SubscriptionPlan", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriptionPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?: SubscriptionPlanOrderByWithRelationInput | SubscriptionPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number
    distinct?: SubscriptionPlanScalarFieldEnum | SubscriptionPlanScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
  }

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan updateManyAndReturn
   */
  export type SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<SubscriptionPlanUpdateManyMutationInput, SubscriptionPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<SubscriptionPlanCreateInput, SubscriptionPlanUncheckedCreateInput>
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPlanUpdateInput, SubscriptionPlanUncheckedUpdateInput>
  }

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput
  }

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput
    /**
     * Limit how many SubscriptionPlans to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionPlan.subscriptions
   */
  export type SubscriptionPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    cursor?: UserSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPlanInclude<ExtArgs> | null
  }


  /**
   * Model UserSubscription
   */

  export type AggregateUserSubscription = {
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  export type UserSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    billingCycle: $Enums.BillingCycle | null
    startDate: Date | null
    endDate: Date | null
    nextBillingDate: Date | null
    cancelledAt: Date | null
    paymentMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    billingCycle: $Enums.BillingCycle | null
    startDate: Date | null
    endDate: Date | null
    nextBillingDate: Date | null
    cancelledAt: Date | null
    paymentMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    status: number
    billingCycle: number
    startDate: number
    endDate: number
    nextBillingDate: number
    cancelledAt: number
    paymentMethod: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    billingCycle?: true
    startDate?: true
    endDate?: true
    nextBillingDate?: true
    cancelledAt?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    billingCycle?: true
    startDate?: true
    endDate?: true
    nextBillingDate?: true
    cancelledAt?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    billingCycle?: true
    startDate?: true
    endDate?: true
    nextBillingDate?: true
    cancelledAt?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscription to aggregate.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubscriptions
    **/
    _count?: true | UserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type GetUserSubscriptionAggregateType<T extends UserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubscription[P]>
      : GetScalarType<T[P], AggregateUserSubscription[P]>
  }




  export type UserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithAggregationInput | UserSubscriptionOrderByWithAggregationInput[]
    by: UserSubscriptionScalarFieldEnum[] | UserSubscriptionScalarFieldEnum
    having?: UserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubscriptionCountAggregateInputType | true
    _min?: UserSubscriptionMinAggregateInputType
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type UserSubscriptionGroupByOutputType = {
    id: string
    userId: string
    planId: string
    status: $Enums.SubscriptionStatus
    billingCycle: $Enums.BillingCycle
    startDate: Date
    endDate: Date | null
    nextBillingDate: Date | null
    cancelledAt: Date | null
    paymentMethod: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  type GetUserSubscriptionGroupByPayload<T extends UserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    billingCycle?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    cancelledAt?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    billingCycle?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    cancelledAt?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    billingCycle?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    cancelledAt?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    billingCycle?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    cancelledAt?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "planId" | "status" | "billingCycle" | "startDate" | "endDate" | "nextBillingDate" | "cancelledAt" | "paymentMethod" | "createdAt" | "updatedAt", ExtArgs["result"]["userSubscription"]>
  export type UserSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | SubscriptionPlanDefaultArgs<ExtArgs>
  }

  export type $UserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$SubscriptionPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planId: string
      status: $Enums.SubscriptionStatus
      billingCycle: $Enums.BillingCycle
      startDate: Date
      endDate: Date | null
      nextBillingDate: Date | null
      cancelledAt: Date | null
      paymentMethod: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSubscription"]>
    composites: {}
  }

  type UserSubscriptionGetPayload<S extends boolean | null | undefined | UserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$UserSubscriptionPayload, S>

  type UserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSubscriptionCountAggregateInputType | true
    }

  export interface UserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubscription'], meta: { name: 'UserSubscription' } }
    /**
     * Find zero or one UserSubscription that matches the filter.
     * @param {UserSubscriptionFindUniqueArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubscriptionFindUniqueArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubscriptionFindFirstArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany()
     * 
     * // Get first 10 UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSubscriptionFindManyArgs>(args?: SelectSubset<T, UserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSubscription.
     * @param {UserSubscriptionCreateArgs} args - Arguments to create a UserSubscription.
     * @example
     * // Create one UserSubscription
     * const UserSubscription = await prisma.userSubscription.create({
     *   data: {
     *     // ... data to create a UserSubscription
     *   }
     * })
     * 
     */
    create<T extends UserSubscriptionCreateArgs>(args: SelectSubset<T, UserSubscriptionCreateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSubscriptions.
     * @param {UserSubscriptionCreateManyArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubscriptionCreateManyArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubscriptions and returns the data saved in the database.
     * @param {UserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSubscription.
     * @param {UserSubscriptionDeleteArgs} args - Arguments to delete one UserSubscription.
     * @example
     * // Delete one UserSubscription
     * const UserSubscription = await prisma.userSubscription.delete({
     *   where: {
     *     // ... filter to delete one UserSubscription
     *   }
     * })
     * 
     */
    delete<T extends UserSubscriptionDeleteArgs>(args: SelectSubset<T, UserSubscriptionDeleteArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSubscription.
     * @param {UserSubscriptionUpdateArgs} args - Arguments to update one UserSubscription.
     * @example
     * // Update one UserSubscription
     * const userSubscription = await prisma.userSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubscriptionUpdateArgs>(args: SelectSubset<T, UserSubscriptionUpdateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSubscriptions.
     * @param {UserSubscriptionDeleteManyArgs} args - Arguments to filter UserSubscriptions to delete.
     * @example
     * // Delete a few UserSubscriptions
     * const { count } = await prisma.userSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, UserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubscriptionUpdateManyArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions and returns the data updated in the database.
     * @param {UserSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many UserSubscriptions.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSubscriptions and only return the `id`
     * const userSubscriptionWithIdOnly = await prisma.userSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSubscription.
     * @param {UserSubscriptionUpsertArgs} args - Arguments to update or create a UserSubscription.
     * @example
     * // Update or create a UserSubscription
     * const userSubscription = await prisma.userSubscription.upsert({
     *   create: {
     *     // ... data to create a UserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends UserSubscriptionUpsertArgs>(args: SelectSubset<T, UserSubscriptionUpsertArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionCountArgs} args - Arguments to filter UserSubscriptions to count.
     * @example
     * // Count the number of UserSubscriptions
     * const count = await prisma.userSubscription.count({
     *   where: {
     *     // ... the filter for the UserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends UserSubscriptionCountArgs>(
      args?: Subset<T, UserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubscriptionAggregateArgs>(args: Subset<T, UserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetUserSubscriptionAggregateType<T>>

    /**
     * Group by UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubscription model
   */
  readonly fields: UserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma__SubscriptionPlanClient<$Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubscription model
   */
  interface UserSubscriptionFieldRefs {
    readonly id: FieldRef<"UserSubscription", 'String'>
    readonly userId: FieldRef<"UserSubscription", 'String'>
    readonly planId: FieldRef<"UserSubscription", 'String'>
    readonly status: FieldRef<"UserSubscription", 'SubscriptionStatus'>
    readonly billingCycle: FieldRef<"UserSubscription", 'BillingCycle'>
    readonly startDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly endDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly nextBillingDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly cancelledAt: FieldRef<"UserSubscription", 'DateTime'>
    readonly paymentMethod: FieldRef<"UserSubscription", 'String'>
    readonly createdAt: FieldRef<"UserSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSubscription findUnique
   */
  export type UserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findUniqueOrThrow
   */
  export type UserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findFirst
   */
  export type UserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findFirstOrThrow
   */
  export type UserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findMany
   */
  export type UserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscriptions to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription create
   */
  export type UserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSubscription.
     */
    data: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
  }

  /**
   * UserSubscription createMany
   */
  export type UserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription createManyAndReturn
   */
  export type UserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription update
   */
  export type UserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSubscription.
     */
    data: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which UserSubscription to update.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription updateMany
   */
  export type UserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
  }

  /**
   * UserSubscription updateManyAndReturn
   */
  export type UserSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription upsert
   */
  export type UserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSubscription to update in case it exists.
     */
    where: UserSubscriptionWhereUniqueInput
    /**
     * In case the UserSubscription found by the `where` argument doesn't exist, create a new UserSubscription with this data.
     */
    create: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
    /**
     * In case the UserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
  }

  /**
   * UserSubscription delete
   */
  export type UserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which UserSubscription to delete.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription deleteMany
   */
  export type UserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscriptions to delete
     */
    where?: UserSubscriptionWhereInput
    /**
     * Limit how many UserSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * UserSubscription without action
   */
  export type UserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Advertisement
   */

  export type AggregateAdvertisement = {
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  export type AdvertisementAvgAggregateOutputType = {
    durationMs: number | null
    targetAgeMin: number | null
    targetAgeMax: number | null
    priority: number | null
    budget: Decimal | null
    costPerImpression: Decimal | null
    costPerClick: Decimal | null
    totalImpressions: number | null
    totalClicks: number | null
  }

  export type AdvertisementSumAggregateOutputType = {
    durationMs: number | null
    targetAgeMin: number | null
    targetAgeMax: number | null
    priority: number | null
    budget: Decimal | null
    costPerImpression: Decimal | null
    costPerClick: Decimal | null
    totalImpressions: bigint | null
    totalClicks: bigint | null
  }

  export type AdvertisementMinAggregateOutputType = {
    id: string | null
    name: string | null
    advertiser: string | null
    adType: $Enums.AdType | null
    mediaUrl: string | null
    clickUrl: string | null
    durationMs: number | null
    targetAgeMin: number | null
    targetAgeMax: number | null
    priority: number | null
    budget: Decimal | null
    costPerImpression: Decimal | null
    costPerClick: Decimal | null
    totalImpressions: bigint | null
    totalClicks: bigint | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvertisementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    advertiser: string | null
    adType: $Enums.AdType | null
    mediaUrl: string | null
    clickUrl: string | null
    durationMs: number | null
    targetAgeMin: number | null
    targetAgeMax: number | null
    priority: number | null
    budget: Decimal | null
    costPerImpression: Decimal | null
    costPerClick: Decimal | null
    totalImpressions: bigint | null
    totalClicks: bigint | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvertisementCountAggregateOutputType = {
    id: number
    name: number
    advertiser: number
    adType: number
    mediaUrl: number
    clickUrl: number
    durationMs: number
    targetCountries: number
    targetAgeMin: number
    targetAgeMax: number
    targetGenres: number
    priority: number
    budget: number
    costPerImpression: number
    costPerClick: number
    totalImpressions: number
    totalClicks: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdvertisementAvgAggregateInputType = {
    durationMs?: true
    targetAgeMin?: true
    targetAgeMax?: true
    priority?: true
    budget?: true
    costPerImpression?: true
    costPerClick?: true
    totalImpressions?: true
    totalClicks?: true
  }

  export type AdvertisementSumAggregateInputType = {
    durationMs?: true
    targetAgeMin?: true
    targetAgeMax?: true
    priority?: true
    budget?: true
    costPerImpression?: true
    costPerClick?: true
    totalImpressions?: true
    totalClicks?: true
  }

  export type AdvertisementMinAggregateInputType = {
    id?: true
    name?: true
    advertiser?: true
    adType?: true
    mediaUrl?: true
    clickUrl?: true
    durationMs?: true
    targetAgeMin?: true
    targetAgeMax?: true
    priority?: true
    budget?: true
    costPerImpression?: true
    costPerClick?: true
    totalImpressions?: true
    totalClicks?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvertisementMaxAggregateInputType = {
    id?: true
    name?: true
    advertiser?: true
    adType?: true
    mediaUrl?: true
    clickUrl?: true
    durationMs?: true
    targetAgeMin?: true
    targetAgeMax?: true
    priority?: true
    budget?: true
    costPerImpression?: true
    costPerClick?: true
    totalImpressions?: true
    totalClicks?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvertisementCountAggregateInputType = {
    id?: true
    name?: true
    advertiser?: true
    adType?: true
    mediaUrl?: true
    clickUrl?: true
    durationMs?: true
    targetCountries?: true
    targetAgeMin?: true
    targetAgeMax?: true
    targetGenres?: true
    priority?: true
    budget?: true
    costPerImpression?: true
    costPerClick?: true
    totalImpressions?: true
    totalClicks?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdvertisementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisement to aggregate.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advertisements
    **/
    _count?: true | AdvertisementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvertisementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvertisementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvertisementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvertisementMaxAggregateInputType
  }

  export type GetAdvertisementAggregateType<T extends AdvertisementAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvertisement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertisement[P]>
      : GetScalarType<T[P], AggregateAdvertisement[P]>
  }




  export type AdvertisementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithAggregationInput | AdvertisementOrderByWithAggregationInput[]
    by: AdvertisementScalarFieldEnum[] | AdvertisementScalarFieldEnum
    having?: AdvertisementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvertisementCountAggregateInputType | true
    _avg?: AdvertisementAvgAggregateInputType
    _sum?: AdvertisementSumAggregateInputType
    _min?: AdvertisementMinAggregateInputType
    _max?: AdvertisementMaxAggregateInputType
  }

  export type AdvertisementGroupByOutputType = {
    id: string
    name: string
    advertiser: string
    adType: $Enums.AdType
    mediaUrl: string
    clickUrl: string | null
    durationMs: number | null
    targetCountries: string[]
    targetAgeMin: number | null
    targetAgeMax: number | null
    targetGenres: string[]
    priority: number
    budget: Decimal | null
    costPerImpression: Decimal | null
    costPerClick: Decimal | null
    totalImpressions: bigint
    totalClicks: bigint
    startDate: Date | null
    endDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  type GetAdvertisementGroupByPayload<T extends AdvertisementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvertisementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvertisementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
            : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
        }
      >
    >


  export type AdvertisementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    advertiser?: boolean
    adType?: boolean
    mediaUrl?: boolean
    clickUrl?: boolean
    durationMs?: boolean
    targetCountries?: boolean
    targetAgeMin?: boolean
    targetAgeMax?: boolean
    targetGenres?: boolean
    priority?: boolean
    budget?: boolean
    costPerImpression?: boolean
    costPerClick?: boolean
    totalImpressions?: boolean
    totalClicks?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    impressions?: boolean | Advertisement$impressionsArgs<ExtArgs>
    _count?: boolean | AdvertisementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advertisement"]>

  export type AdvertisementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    advertiser?: boolean
    adType?: boolean
    mediaUrl?: boolean
    clickUrl?: boolean
    durationMs?: boolean
    targetCountries?: boolean
    targetAgeMin?: boolean
    targetAgeMax?: boolean
    targetGenres?: boolean
    priority?: boolean
    budget?: boolean
    costPerImpression?: boolean
    costPerClick?: boolean
    totalImpressions?: boolean
    totalClicks?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["advertisement"]>

  export type AdvertisementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    advertiser?: boolean
    adType?: boolean
    mediaUrl?: boolean
    clickUrl?: boolean
    durationMs?: boolean
    targetCountries?: boolean
    targetAgeMin?: boolean
    targetAgeMax?: boolean
    targetGenres?: boolean
    priority?: boolean
    budget?: boolean
    costPerImpression?: boolean
    costPerClick?: boolean
    totalImpressions?: boolean
    totalClicks?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["advertisement"]>

  export type AdvertisementSelectScalar = {
    id?: boolean
    name?: boolean
    advertiser?: boolean
    adType?: boolean
    mediaUrl?: boolean
    clickUrl?: boolean
    durationMs?: boolean
    targetCountries?: boolean
    targetAgeMin?: boolean
    targetAgeMax?: boolean
    targetGenres?: boolean
    priority?: boolean
    budget?: boolean
    costPerImpression?: boolean
    costPerClick?: boolean
    totalImpressions?: boolean
    totalClicks?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdvertisementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "advertiser" | "adType" | "mediaUrl" | "clickUrl" | "durationMs" | "targetCountries" | "targetAgeMin" | "targetAgeMax" | "targetGenres" | "priority" | "budget" | "costPerImpression" | "costPerClick" | "totalImpressions" | "totalClicks" | "startDate" | "endDate" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["advertisement"]>
  export type AdvertisementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impressions?: boolean | Advertisement$impressionsArgs<ExtArgs>
    _count?: boolean | AdvertisementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdvertisementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdvertisementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdvertisementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Advertisement"
    objects: {
      impressions: Prisma.$AdImpressionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      advertiser: string
      adType: $Enums.AdType
      mediaUrl: string
      clickUrl: string | null
      durationMs: number | null
      targetCountries: string[]
      targetAgeMin: number | null
      targetAgeMax: number | null
      targetGenres: string[]
      priority: number
      budget: Prisma.Decimal | null
      costPerImpression: Prisma.Decimal | null
      costPerClick: Prisma.Decimal | null
      totalImpressions: bigint
      totalClicks: bigint
      startDate: Date | null
      endDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["advertisement"]>
    composites: {}
  }

  type AdvertisementGetPayload<S extends boolean | null | undefined | AdvertisementDefaultArgs> = $Result.GetResult<Prisma.$AdvertisementPayload, S>

  type AdvertisementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdvertisementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdvertisementCountAggregateInputType | true
    }

  export interface AdvertisementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advertisement'], meta: { name: 'Advertisement' } }
    /**
     * Find zero or one Advertisement that matches the filter.
     * @param {AdvertisementFindUniqueArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvertisementFindUniqueArgs>(args: SelectSubset<T, AdvertisementFindUniqueArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Advertisement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdvertisementFindUniqueOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvertisementFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvertisementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Advertisement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvertisementFindFirstArgs>(args?: SelectSubset<T, AdvertisementFindFirstArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Advertisement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvertisementFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvertisementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Advertisements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advertisements
     * const advertisements = await prisma.advertisement.findMany()
     * 
     * // Get first 10 Advertisements
     * const advertisements = await prisma.advertisement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advertisementWithIdOnly = await prisma.advertisement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvertisementFindManyArgs>(args?: SelectSubset<T, AdvertisementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Advertisement.
     * @param {AdvertisementCreateArgs} args - Arguments to create a Advertisement.
     * @example
     * // Create one Advertisement
     * const Advertisement = await prisma.advertisement.create({
     *   data: {
     *     // ... data to create a Advertisement
     *   }
     * })
     * 
     */
    create<T extends AdvertisementCreateArgs>(args: SelectSubset<T, AdvertisementCreateArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Advertisements.
     * @param {AdvertisementCreateManyArgs} args - Arguments to create many Advertisements.
     * @example
     * // Create many Advertisements
     * const advertisement = await prisma.advertisement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvertisementCreateManyArgs>(args?: SelectSubset<T, AdvertisementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Advertisements and returns the data saved in the database.
     * @param {AdvertisementCreateManyAndReturnArgs} args - Arguments to create many Advertisements.
     * @example
     * // Create many Advertisements
     * const advertisement = await prisma.advertisement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Advertisements and only return the `id`
     * const advertisementWithIdOnly = await prisma.advertisement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvertisementCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvertisementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Advertisement.
     * @param {AdvertisementDeleteArgs} args - Arguments to delete one Advertisement.
     * @example
     * // Delete one Advertisement
     * const Advertisement = await prisma.advertisement.delete({
     *   where: {
     *     // ... filter to delete one Advertisement
     *   }
     * })
     * 
     */
    delete<T extends AdvertisementDeleteArgs>(args: SelectSubset<T, AdvertisementDeleteArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Advertisement.
     * @param {AdvertisementUpdateArgs} args - Arguments to update one Advertisement.
     * @example
     * // Update one Advertisement
     * const advertisement = await prisma.advertisement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvertisementUpdateArgs>(args: SelectSubset<T, AdvertisementUpdateArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Advertisements.
     * @param {AdvertisementDeleteManyArgs} args - Arguments to filter Advertisements to delete.
     * @example
     * // Delete a few Advertisements
     * const { count } = await prisma.advertisement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvertisementDeleteManyArgs>(args?: SelectSubset<T, AdvertisementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advertisements
     * const advertisement = await prisma.advertisement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvertisementUpdateManyArgs>(args: SelectSubset<T, AdvertisementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advertisements and returns the data updated in the database.
     * @param {AdvertisementUpdateManyAndReturnArgs} args - Arguments to update many Advertisements.
     * @example
     * // Update many Advertisements
     * const advertisement = await prisma.advertisement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Advertisements and only return the `id`
     * const advertisementWithIdOnly = await prisma.advertisement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdvertisementUpdateManyAndReturnArgs>(args: SelectSubset<T, AdvertisementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Advertisement.
     * @param {AdvertisementUpsertArgs} args - Arguments to update or create a Advertisement.
     * @example
     * // Update or create a Advertisement
     * const advertisement = await prisma.advertisement.upsert({
     *   create: {
     *     // ... data to create a Advertisement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advertisement we want to update
     *   }
     * })
     */
    upsert<T extends AdvertisementUpsertArgs>(args: SelectSubset<T, AdvertisementUpsertArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementCountArgs} args - Arguments to filter Advertisements to count.
     * @example
     * // Count the number of Advertisements
     * const count = await prisma.advertisement.count({
     *   where: {
     *     // ... the filter for the Advertisements we want to count
     *   }
     * })
    **/
    count<T extends AdvertisementCountArgs>(
      args?: Subset<T, AdvertisementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvertisementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvertisementAggregateArgs>(args: Subset<T, AdvertisementAggregateArgs>): Prisma.PrismaPromise<GetAdvertisementAggregateType<T>>

    /**
     * Group by Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvertisementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvertisementGroupByArgs['orderBy'] }
        : { orderBy?: AdvertisementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvertisementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvertisementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advertisement model
   */
  readonly fields: AdvertisementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advertisement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvertisementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    impressions<T extends Advertisement$impressionsArgs<ExtArgs> = {}>(args?: Subset<T, Advertisement$impressionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Advertisement model
   */
  interface AdvertisementFieldRefs {
    readonly id: FieldRef<"Advertisement", 'String'>
    readonly name: FieldRef<"Advertisement", 'String'>
    readonly advertiser: FieldRef<"Advertisement", 'String'>
    readonly adType: FieldRef<"Advertisement", 'AdType'>
    readonly mediaUrl: FieldRef<"Advertisement", 'String'>
    readonly clickUrl: FieldRef<"Advertisement", 'String'>
    readonly durationMs: FieldRef<"Advertisement", 'Int'>
    readonly targetCountries: FieldRef<"Advertisement", 'String[]'>
    readonly targetAgeMin: FieldRef<"Advertisement", 'Int'>
    readonly targetAgeMax: FieldRef<"Advertisement", 'Int'>
    readonly targetGenres: FieldRef<"Advertisement", 'String[]'>
    readonly priority: FieldRef<"Advertisement", 'Int'>
    readonly budget: FieldRef<"Advertisement", 'Decimal'>
    readonly costPerImpression: FieldRef<"Advertisement", 'Decimal'>
    readonly costPerClick: FieldRef<"Advertisement", 'Decimal'>
    readonly totalImpressions: FieldRef<"Advertisement", 'BigInt'>
    readonly totalClicks: FieldRef<"Advertisement", 'BigInt'>
    readonly startDate: FieldRef<"Advertisement", 'DateTime'>
    readonly endDate: FieldRef<"Advertisement", 'DateTime'>
    readonly isActive: FieldRef<"Advertisement", 'Boolean'>
    readonly createdAt: FieldRef<"Advertisement", 'DateTime'>
    readonly updatedAt: FieldRef<"Advertisement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Advertisement findUnique
   */
  export type AdvertisementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }

  /**
   * Advertisement findUniqueOrThrow
   */
  export type AdvertisementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }

  /**
   * Advertisement findFirst
   */
  export type AdvertisementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }

  /**
   * Advertisement findFirstOrThrow
   */
  export type AdvertisementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }

  /**
   * Advertisement findMany
   */
  export type AdvertisementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisements to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }

  /**
   * Advertisement create
   */
  export type AdvertisementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The data needed to create a Advertisement.
     */
    data: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
  }

  /**
   * Advertisement createMany
   */
  export type AdvertisementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advertisements.
     */
    data: AdvertisementCreateManyInput | AdvertisementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Advertisement createManyAndReturn
   */
  export type AdvertisementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * The data used to create many Advertisements.
     */
    data: AdvertisementCreateManyInput | AdvertisementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Advertisement update
   */
  export type AdvertisementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The data needed to update a Advertisement.
     */
    data: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
    /**
     * Choose, which Advertisement to update.
     */
    where: AdvertisementWhereUniqueInput
  }

  /**
   * Advertisement updateMany
   */
  export type AdvertisementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advertisements.
     */
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyInput>
    /**
     * Filter which Advertisements to update
     */
    where?: AdvertisementWhereInput
    /**
     * Limit how many Advertisements to update.
     */
    limit?: number
  }

  /**
   * Advertisement updateManyAndReturn
   */
  export type AdvertisementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * The data used to update Advertisements.
     */
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyInput>
    /**
     * Filter which Advertisements to update
     */
    where?: AdvertisementWhereInput
    /**
     * Limit how many Advertisements to update.
     */
    limit?: number
  }

  /**
   * Advertisement upsert
   */
  export type AdvertisementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The filter to search for the Advertisement to update in case it exists.
     */
    where: AdvertisementWhereUniqueInput
    /**
     * In case the Advertisement found by the `where` argument doesn't exist, create a new Advertisement with this data.
     */
    create: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
    /**
     * In case the Advertisement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
  }

  /**
   * Advertisement delete
   */
  export type AdvertisementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter which Advertisement to delete.
     */
    where: AdvertisementWhereUniqueInput
  }

  /**
   * Advertisement deleteMany
   */
  export type AdvertisementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisements to delete
     */
    where?: AdvertisementWhereInput
    /**
     * Limit how many Advertisements to delete.
     */
    limit?: number
  }

  /**
   * Advertisement.impressions
   */
  export type Advertisement$impressionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    where?: AdImpressionWhereInput
    orderBy?: AdImpressionOrderByWithRelationInput | AdImpressionOrderByWithRelationInput[]
    cursor?: AdImpressionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdImpressionScalarFieldEnum | AdImpressionScalarFieldEnum[]
  }

  /**
   * Advertisement without action
   */
  export type AdvertisementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisementInclude<ExtArgs> | null
  }


  /**
   * Model AdImpression
   */

  export type AggregateAdImpression = {
    _count: AdImpressionCountAggregateOutputType | null
    _avg: AdImpressionAvgAggregateOutputType | null
    _sum: AdImpressionSumAggregateOutputType | null
    _min: AdImpressionMinAggregateOutputType | null
    _max: AdImpressionMaxAggregateOutputType | null
  }

  export type AdImpressionAvgAggregateOutputType = {
    revenue: Decimal | null
  }

  export type AdImpressionSumAggregateOutputType = {
    revenue: Decimal | null
  }

  export type AdImpressionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    adId: string | null
    deviceId: string | null
    impressionType: $Enums.ImpressionType | null
    contextType: $Enums.AdContextType | null
    revenue: Decimal | null
    createdAt: Date | null
  }

  export type AdImpressionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    adId: string | null
    deviceId: string | null
    impressionType: $Enums.ImpressionType | null
    contextType: $Enums.AdContextType | null
    revenue: Decimal | null
    createdAt: Date | null
  }

  export type AdImpressionCountAggregateOutputType = {
    id: number
    userId: number
    adId: number
    deviceId: number
    impressionType: number
    contextType: number
    revenue: number
    createdAt: number
    _all: number
  }


  export type AdImpressionAvgAggregateInputType = {
    revenue?: true
  }

  export type AdImpressionSumAggregateInputType = {
    revenue?: true
  }

  export type AdImpressionMinAggregateInputType = {
    id?: true
    userId?: true
    adId?: true
    deviceId?: true
    impressionType?: true
    contextType?: true
    revenue?: true
    createdAt?: true
  }

  export type AdImpressionMaxAggregateInputType = {
    id?: true
    userId?: true
    adId?: true
    deviceId?: true
    impressionType?: true
    contextType?: true
    revenue?: true
    createdAt?: true
  }

  export type AdImpressionCountAggregateInputType = {
    id?: true
    userId?: true
    adId?: true
    deviceId?: true
    impressionType?: true
    contextType?: true
    revenue?: true
    createdAt?: true
    _all?: true
  }

  export type AdImpressionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdImpression to aggregate.
     */
    where?: AdImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdImpressions to fetch.
     */
    orderBy?: AdImpressionOrderByWithRelationInput | AdImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdImpressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdImpressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdImpressions
    **/
    _count?: true | AdImpressionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdImpressionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdImpressionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdImpressionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdImpressionMaxAggregateInputType
  }

  export type GetAdImpressionAggregateType<T extends AdImpressionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdImpression]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdImpression[P]>
      : GetScalarType<T[P], AggregateAdImpression[P]>
  }




  export type AdImpressionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdImpressionWhereInput
    orderBy?: AdImpressionOrderByWithAggregationInput | AdImpressionOrderByWithAggregationInput[]
    by: AdImpressionScalarFieldEnum[] | AdImpressionScalarFieldEnum
    having?: AdImpressionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdImpressionCountAggregateInputType | true
    _avg?: AdImpressionAvgAggregateInputType
    _sum?: AdImpressionSumAggregateInputType
    _min?: AdImpressionMinAggregateInputType
    _max?: AdImpressionMaxAggregateInputType
  }

  export type AdImpressionGroupByOutputType = {
    id: string
    userId: string
    adId: string
    deviceId: string | null
    impressionType: $Enums.ImpressionType
    contextType: $Enums.AdContextType | null
    revenue: Decimal
    createdAt: Date
    _count: AdImpressionCountAggregateOutputType | null
    _avg: AdImpressionAvgAggregateOutputType | null
    _sum: AdImpressionSumAggregateOutputType | null
    _min: AdImpressionMinAggregateOutputType | null
    _max: AdImpressionMaxAggregateOutputType | null
  }

  type GetAdImpressionGroupByPayload<T extends AdImpressionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdImpressionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdImpressionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdImpressionGroupByOutputType[P]>
            : GetScalarType<T[P], AdImpressionGroupByOutputType[P]>
        }
      >
    >


  export type AdImpressionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adId?: boolean
    deviceId?: boolean
    impressionType?: boolean
    contextType?: boolean
    revenue?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | AdvertisementDefaultArgs<ExtArgs>
    device?: boolean | AdImpression$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["adImpression"]>

  export type AdImpressionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adId?: boolean
    deviceId?: boolean
    impressionType?: boolean
    contextType?: boolean
    revenue?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | AdvertisementDefaultArgs<ExtArgs>
    device?: boolean | AdImpression$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["adImpression"]>

  export type AdImpressionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adId?: boolean
    deviceId?: boolean
    impressionType?: boolean
    contextType?: boolean
    revenue?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | AdvertisementDefaultArgs<ExtArgs>
    device?: boolean | AdImpression$deviceArgs<ExtArgs>
  }, ExtArgs["result"]["adImpression"]>

  export type AdImpressionSelectScalar = {
    id?: boolean
    userId?: boolean
    adId?: boolean
    deviceId?: boolean
    impressionType?: boolean
    contextType?: boolean
    revenue?: boolean
    createdAt?: boolean
  }

  export type AdImpressionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "adId" | "deviceId" | "impressionType" | "contextType" | "revenue" | "createdAt", ExtArgs["result"]["adImpression"]>
  export type AdImpressionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | AdvertisementDefaultArgs<ExtArgs>
    device?: boolean | AdImpression$deviceArgs<ExtArgs>
  }
  export type AdImpressionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | AdvertisementDefaultArgs<ExtArgs>
    device?: boolean | AdImpression$deviceArgs<ExtArgs>
  }
  export type AdImpressionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | AdvertisementDefaultArgs<ExtArgs>
    device?: boolean | AdImpression$deviceArgs<ExtArgs>
  }

  export type $AdImpressionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdImpression"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ad: Prisma.$AdvertisementPayload<ExtArgs>
      device: Prisma.$UserDevicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      adId: string
      deviceId: string | null
      impressionType: $Enums.ImpressionType
      contextType: $Enums.AdContextType | null
      revenue: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["adImpression"]>
    composites: {}
  }

  type AdImpressionGetPayload<S extends boolean | null | undefined | AdImpressionDefaultArgs> = $Result.GetResult<Prisma.$AdImpressionPayload, S>

  type AdImpressionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdImpressionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdImpressionCountAggregateInputType | true
    }

  export interface AdImpressionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdImpression'], meta: { name: 'AdImpression' } }
    /**
     * Find zero or one AdImpression that matches the filter.
     * @param {AdImpressionFindUniqueArgs} args - Arguments to find a AdImpression
     * @example
     * // Get one AdImpression
     * const adImpression = await prisma.adImpression.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdImpressionFindUniqueArgs>(args: SelectSubset<T, AdImpressionFindUniqueArgs<ExtArgs>>): Prisma__AdImpressionClient<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdImpression that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdImpressionFindUniqueOrThrowArgs} args - Arguments to find a AdImpression
     * @example
     * // Get one AdImpression
     * const adImpression = await prisma.adImpression.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdImpressionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdImpressionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdImpressionClient<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdImpression that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdImpressionFindFirstArgs} args - Arguments to find a AdImpression
     * @example
     * // Get one AdImpression
     * const adImpression = await prisma.adImpression.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdImpressionFindFirstArgs>(args?: SelectSubset<T, AdImpressionFindFirstArgs<ExtArgs>>): Prisma__AdImpressionClient<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdImpression that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdImpressionFindFirstOrThrowArgs} args - Arguments to find a AdImpression
     * @example
     * // Get one AdImpression
     * const adImpression = await prisma.adImpression.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdImpressionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdImpressionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdImpressionClient<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdImpressions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdImpressionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdImpressions
     * const adImpressions = await prisma.adImpression.findMany()
     * 
     * // Get first 10 AdImpressions
     * const adImpressions = await prisma.adImpression.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adImpressionWithIdOnly = await prisma.adImpression.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdImpressionFindManyArgs>(args?: SelectSubset<T, AdImpressionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdImpression.
     * @param {AdImpressionCreateArgs} args - Arguments to create a AdImpression.
     * @example
     * // Create one AdImpression
     * const AdImpression = await prisma.adImpression.create({
     *   data: {
     *     // ... data to create a AdImpression
     *   }
     * })
     * 
     */
    create<T extends AdImpressionCreateArgs>(args: SelectSubset<T, AdImpressionCreateArgs<ExtArgs>>): Prisma__AdImpressionClient<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdImpressions.
     * @param {AdImpressionCreateManyArgs} args - Arguments to create many AdImpressions.
     * @example
     * // Create many AdImpressions
     * const adImpression = await prisma.adImpression.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdImpressionCreateManyArgs>(args?: SelectSubset<T, AdImpressionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdImpressions and returns the data saved in the database.
     * @param {AdImpressionCreateManyAndReturnArgs} args - Arguments to create many AdImpressions.
     * @example
     * // Create many AdImpressions
     * const adImpression = await prisma.adImpression.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdImpressions and only return the `id`
     * const adImpressionWithIdOnly = await prisma.adImpression.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdImpressionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdImpressionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdImpression.
     * @param {AdImpressionDeleteArgs} args - Arguments to delete one AdImpression.
     * @example
     * // Delete one AdImpression
     * const AdImpression = await prisma.adImpression.delete({
     *   where: {
     *     // ... filter to delete one AdImpression
     *   }
     * })
     * 
     */
    delete<T extends AdImpressionDeleteArgs>(args: SelectSubset<T, AdImpressionDeleteArgs<ExtArgs>>): Prisma__AdImpressionClient<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdImpression.
     * @param {AdImpressionUpdateArgs} args - Arguments to update one AdImpression.
     * @example
     * // Update one AdImpression
     * const adImpression = await prisma.adImpression.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdImpressionUpdateArgs>(args: SelectSubset<T, AdImpressionUpdateArgs<ExtArgs>>): Prisma__AdImpressionClient<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdImpressions.
     * @param {AdImpressionDeleteManyArgs} args - Arguments to filter AdImpressions to delete.
     * @example
     * // Delete a few AdImpressions
     * const { count } = await prisma.adImpression.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdImpressionDeleteManyArgs>(args?: SelectSubset<T, AdImpressionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdImpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdImpressionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdImpressions
     * const adImpression = await prisma.adImpression.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdImpressionUpdateManyArgs>(args: SelectSubset<T, AdImpressionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdImpressions and returns the data updated in the database.
     * @param {AdImpressionUpdateManyAndReturnArgs} args - Arguments to update many AdImpressions.
     * @example
     * // Update many AdImpressions
     * const adImpression = await prisma.adImpression.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdImpressions and only return the `id`
     * const adImpressionWithIdOnly = await prisma.adImpression.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdImpressionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdImpressionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdImpression.
     * @param {AdImpressionUpsertArgs} args - Arguments to update or create a AdImpression.
     * @example
     * // Update or create a AdImpression
     * const adImpression = await prisma.adImpression.upsert({
     *   create: {
     *     // ... data to create a AdImpression
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdImpression we want to update
     *   }
     * })
     */
    upsert<T extends AdImpressionUpsertArgs>(args: SelectSubset<T, AdImpressionUpsertArgs<ExtArgs>>): Prisma__AdImpressionClient<$Result.GetResult<Prisma.$AdImpressionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdImpressions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdImpressionCountArgs} args - Arguments to filter AdImpressions to count.
     * @example
     * // Count the number of AdImpressions
     * const count = await prisma.adImpression.count({
     *   where: {
     *     // ... the filter for the AdImpressions we want to count
     *   }
     * })
    **/
    count<T extends AdImpressionCountArgs>(
      args?: Subset<T, AdImpressionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdImpressionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdImpression.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdImpressionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdImpressionAggregateArgs>(args: Subset<T, AdImpressionAggregateArgs>): Prisma.PrismaPromise<GetAdImpressionAggregateType<T>>

    /**
     * Group by AdImpression.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdImpressionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdImpressionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdImpressionGroupByArgs['orderBy'] }
        : { orderBy?: AdImpressionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdImpressionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdImpressionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdImpression model
   */
  readonly fields: AdImpressionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdImpression.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdImpressionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ad<T extends AdvertisementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvertisementDefaultArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    device<T extends AdImpression$deviceArgs<ExtArgs> = {}>(args?: Subset<T, AdImpression$deviceArgs<ExtArgs>>): Prisma__UserDeviceClient<$Result.GetResult<Prisma.$UserDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdImpression model
   */
  interface AdImpressionFieldRefs {
    readonly id: FieldRef<"AdImpression", 'String'>
    readonly userId: FieldRef<"AdImpression", 'String'>
    readonly adId: FieldRef<"AdImpression", 'String'>
    readonly deviceId: FieldRef<"AdImpression", 'String'>
    readonly impressionType: FieldRef<"AdImpression", 'ImpressionType'>
    readonly contextType: FieldRef<"AdImpression", 'AdContextType'>
    readonly revenue: FieldRef<"AdImpression", 'Decimal'>
    readonly createdAt: FieldRef<"AdImpression", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdImpression findUnique
   */
  export type AdImpressionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    /**
     * Filter, which AdImpression to fetch.
     */
    where: AdImpressionWhereUniqueInput
  }

  /**
   * AdImpression findUniqueOrThrow
   */
  export type AdImpressionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    /**
     * Filter, which AdImpression to fetch.
     */
    where: AdImpressionWhereUniqueInput
  }

  /**
   * AdImpression findFirst
   */
  export type AdImpressionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    /**
     * Filter, which AdImpression to fetch.
     */
    where?: AdImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdImpressions to fetch.
     */
    orderBy?: AdImpressionOrderByWithRelationInput | AdImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdImpressions.
     */
    cursor?: AdImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdImpressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdImpressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdImpressions.
     */
    distinct?: AdImpressionScalarFieldEnum | AdImpressionScalarFieldEnum[]
  }

  /**
   * AdImpression findFirstOrThrow
   */
  export type AdImpressionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    /**
     * Filter, which AdImpression to fetch.
     */
    where?: AdImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdImpressions to fetch.
     */
    orderBy?: AdImpressionOrderByWithRelationInput | AdImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdImpressions.
     */
    cursor?: AdImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdImpressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdImpressions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdImpressions.
     */
    distinct?: AdImpressionScalarFieldEnum | AdImpressionScalarFieldEnum[]
  }

  /**
   * AdImpression findMany
   */
  export type AdImpressionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    /**
     * Filter, which AdImpressions to fetch.
     */
    where?: AdImpressionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdImpressions to fetch.
     */
    orderBy?: AdImpressionOrderByWithRelationInput | AdImpressionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdImpressions.
     */
    cursor?: AdImpressionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdImpressions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdImpressions.
     */
    skip?: number
    distinct?: AdImpressionScalarFieldEnum | AdImpressionScalarFieldEnum[]
  }

  /**
   * AdImpression create
   */
  export type AdImpressionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdImpression.
     */
    data: XOR<AdImpressionCreateInput, AdImpressionUncheckedCreateInput>
  }

  /**
   * AdImpression createMany
   */
  export type AdImpressionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdImpressions.
     */
    data: AdImpressionCreateManyInput | AdImpressionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdImpression createManyAndReturn
   */
  export type AdImpressionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * The data used to create many AdImpressions.
     */
    data: AdImpressionCreateManyInput | AdImpressionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdImpression update
   */
  export type AdImpressionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdImpression.
     */
    data: XOR<AdImpressionUpdateInput, AdImpressionUncheckedUpdateInput>
    /**
     * Choose, which AdImpression to update.
     */
    where: AdImpressionWhereUniqueInput
  }

  /**
   * AdImpression updateMany
   */
  export type AdImpressionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdImpressions.
     */
    data: XOR<AdImpressionUpdateManyMutationInput, AdImpressionUncheckedUpdateManyInput>
    /**
     * Filter which AdImpressions to update
     */
    where?: AdImpressionWhereInput
    /**
     * Limit how many AdImpressions to update.
     */
    limit?: number
  }

  /**
   * AdImpression updateManyAndReturn
   */
  export type AdImpressionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * The data used to update AdImpressions.
     */
    data: XOR<AdImpressionUpdateManyMutationInput, AdImpressionUncheckedUpdateManyInput>
    /**
     * Filter which AdImpressions to update
     */
    where?: AdImpressionWhereInput
    /**
     * Limit how many AdImpressions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdImpression upsert
   */
  export type AdImpressionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdImpression to update in case it exists.
     */
    where: AdImpressionWhereUniqueInput
    /**
     * In case the AdImpression found by the `where` argument doesn't exist, create a new AdImpression with this data.
     */
    create: XOR<AdImpressionCreateInput, AdImpressionUncheckedCreateInput>
    /**
     * In case the AdImpression was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdImpressionUpdateInput, AdImpressionUncheckedUpdateInput>
  }

  /**
   * AdImpression delete
   */
  export type AdImpressionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
    /**
     * Filter which AdImpression to delete.
     */
    where: AdImpressionWhereUniqueInput
  }

  /**
   * AdImpression deleteMany
   */
  export type AdImpressionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdImpressions to delete
     */
    where?: AdImpressionWhereInput
    /**
     * Limit how many AdImpressions to delete.
     */
    limit?: number
  }

  /**
   * AdImpression.device
   */
  export type AdImpression$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDevice
     */
    select?: UserDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDevice
     */
    omit?: UserDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDeviceInclude<ExtArgs> | null
    where?: UserDeviceWhereInput
  }

  /**
   * AdImpression without action
   */
  export type AdImpressionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdImpression
     */
    select?: AdImpressionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdImpression
     */
    omit?: AdImpressionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdImpressionInclude<ExtArgs> | null
  }


  /**
   * Model UserAdSettings
   */

  export type AggregateUserAdSettings = {
    _count: UserAdSettingsCountAggregateOutputType | null
    _avg: UserAdSettingsAvgAggregateOutputType | null
    _sum: UserAdSettingsSumAggregateOutputType | null
    _min: UserAdSettingsMinAggregateOutputType | null
    _max: UserAdSettingsMaxAggregateOutputType | null
  }

  export type UserAdSettingsAvgAggregateOutputType = {
    songsSinceLastAd: number | null
    adsPerHour: number | null
    skipCountToday: number | null
  }

  export type UserAdSettingsSumAggregateOutputType = {
    songsSinceLastAd: number | null
    adsPerHour: number | null
    skipCountToday: number | null
  }

  export type UserAdSettingsMinAggregateOutputType = {
    userId: string | null
    lastAdShownAt: Date | null
    songsSinceLastAd: number | null
    adsPerHour: number | null
    skipCountToday: number | null
    skipResetAt: Date | null
    updatedAt: Date | null
  }

  export type UserAdSettingsMaxAggregateOutputType = {
    userId: string | null
    lastAdShownAt: Date | null
    songsSinceLastAd: number | null
    adsPerHour: number | null
    skipCountToday: number | null
    skipResetAt: Date | null
    updatedAt: Date | null
  }

  export type UserAdSettingsCountAggregateOutputType = {
    userId: number
    lastAdShownAt: number
    songsSinceLastAd: number
    adsPerHour: number
    skipCountToday: number
    skipResetAt: number
    updatedAt: number
    _all: number
  }


  export type UserAdSettingsAvgAggregateInputType = {
    songsSinceLastAd?: true
    adsPerHour?: true
    skipCountToday?: true
  }

  export type UserAdSettingsSumAggregateInputType = {
    songsSinceLastAd?: true
    adsPerHour?: true
    skipCountToday?: true
  }

  export type UserAdSettingsMinAggregateInputType = {
    userId?: true
    lastAdShownAt?: true
    songsSinceLastAd?: true
    adsPerHour?: true
    skipCountToday?: true
    skipResetAt?: true
    updatedAt?: true
  }

  export type UserAdSettingsMaxAggregateInputType = {
    userId?: true
    lastAdShownAt?: true
    songsSinceLastAd?: true
    adsPerHour?: true
    skipCountToday?: true
    skipResetAt?: true
    updatedAt?: true
  }

  export type UserAdSettingsCountAggregateInputType = {
    userId?: true
    lastAdShownAt?: true
    songsSinceLastAd?: true
    adsPerHour?: true
    skipCountToday?: true
    skipResetAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAdSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAdSettings to aggregate.
     */
    where?: UserAdSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdSettings to fetch.
     */
    orderBy?: UserAdSettingsOrderByWithRelationInput | UserAdSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAdSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAdSettings
    **/
    _count?: true | UserAdSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAdSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAdSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAdSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAdSettingsMaxAggregateInputType
  }

  export type GetUserAdSettingsAggregateType<T extends UserAdSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAdSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAdSettings[P]>
      : GetScalarType<T[P], AggregateUserAdSettings[P]>
  }




  export type UserAdSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAdSettingsWhereInput
    orderBy?: UserAdSettingsOrderByWithAggregationInput | UserAdSettingsOrderByWithAggregationInput[]
    by: UserAdSettingsScalarFieldEnum[] | UserAdSettingsScalarFieldEnum
    having?: UserAdSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAdSettingsCountAggregateInputType | true
    _avg?: UserAdSettingsAvgAggregateInputType
    _sum?: UserAdSettingsSumAggregateInputType
    _min?: UserAdSettingsMinAggregateInputType
    _max?: UserAdSettingsMaxAggregateInputType
  }

  export type UserAdSettingsGroupByOutputType = {
    userId: string
    lastAdShownAt: Date | null
    songsSinceLastAd: number
    adsPerHour: number
    skipCountToday: number
    skipResetAt: Date | null
    updatedAt: Date
    _count: UserAdSettingsCountAggregateOutputType | null
    _avg: UserAdSettingsAvgAggregateOutputType | null
    _sum: UserAdSettingsSumAggregateOutputType | null
    _min: UserAdSettingsMinAggregateOutputType | null
    _max: UserAdSettingsMaxAggregateOutputType | null
  }

  type GetUserAdSettingsGroupByPayload<T extends UserAdSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAdSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAdSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAdSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserAdSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserAdSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    lastAdShownAt?: boolean
    songsSinceLastAd?: boolean
    adsPerHour?: boolean
    skipCountToday?: boolean
    skipResetAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAdSettings"]>

  export type UserAdSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    lastAdShownAt?: boolean
    songsSinceLastAd?: boolean
    adsPerHour?: boolean
    skipCountToday?: boolean
    skipResetAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAdSettings"]>

  export type UserAdSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    lastAdShownAt?: boolean
    songsSinceLastAd?: boolean
    adsPerHour?: boolean
    skipCountToday?: boolean
    skipResetAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAdSettings"]>

  export type UserAdSettingsSelectScalar = {
    userId?: boolean
    lastAdShownAt?: boolean
    songsSinceLastAd?: boolean
    adsPerHour?: boolean
    skipCountToday?: boolean
    skipResetAt?: boolean
    updatedAt?: boolean
  }

  export type UserAdSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "lastAdShownAt" | "songsSinceLastAd" | "adsPerHour" | "skipCountToday" | "skipResetAt" | "updatedAt", ExtArgs["result"]["userAdSettings"]>
  export type UserAdSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAdSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAdSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAdSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAdSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      lastAdShownAt: Date | null
      songsSinceLastAd: number
      adsPerHour: number
      skipCountToday: number
      skipResetAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["userAdSettings"]>
    composites: {}
  }

  type UserAdSettingsGetPayload<S extends boolean | null | undefined | UserAdSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserAdSettingsPayload, S>

  type UserAdSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAdSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAdSettingsCountAggregateInputType | true
    }

  export interface UserAdSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAdSettings'], meta: { name: 'UserAdSettings' } }
    /**
     * Find zero or one UserAdSettings that matches the filter.
     * @param {UserAdSettingsFindUniqueArgs} args - Arguments to find a UserAdSettings
     * @example
     * // Get one UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAdSettingsFindUniqueArgs>(args: SelectSubset<T, UserAdSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserAdSettingsClient<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAdSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAdSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserAdSettings
     * @example
     * // Get one UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAdSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAdSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAdSettingsClient<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAdSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdSettingsFindFirstArgs} args - Arguments to find a UserAdSettings
     * @example
     * // Get one UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAdSettingsFindFirstArgs>(args?: SelectSubset<T, UserAdSettingsFindFirstArgs<ExtArgs>>): Prisma__UserAdSettingsClient<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAdSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdSettingsFindFirstOrThrowArgs} args - Arguments to find a UserAdSettings
     * @example
     * // Get one UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAdSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAdSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAdSettingsClient<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAdSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.findMany()
     * 
     * // Get first 10 UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userAdSettingsWithUserIdOnly = await prisma.userAdSettings.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserAdSettingsFindManyArgs>(args?: SelectSubset<T, UserAdSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAdSettings.
     * @param {UserAdSettingsCreateArgs} args - Arguments to create a UserAdSettings.
     * @example
     * // Create one UserAdSettings
     * const UserAdSettings = await prisma.userAdSettings.create({
     *   data: {
     *     // ... data to create a UserAdSettings
     *   }
     * })
     * 
     */
    create<T extends UserAdSettingsCreateArgs>(args: SelectSubset<T, UserAdSettingsCreateArgs<ExtArgs>>): Prisma__UserAdSettingsClient<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAdSettings.
     * @param {UserAdSettingsCreateManyArgs} args - Arguments to create many UserAdSettings.
     * @example
     * // Create many UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAdSettingsCreateManyArgs>(args?: SelectSubset<T, UserAdSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAdSettings and returns the data saved in the database.
     * @param {UserAdSettingsCreateManyAndReturnArgs} args - Arguments to create many UserAdSettings.
     * @example
     * // Create many UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAdSettings and only return the `userId`
     * const userAdSettingsWithUserIdOnly = await prisma.userAdSettings.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAdSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAdSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAdSettings.
     * @param {UserAdSettingsDeleteArgs} args - Arguments to delete one UserAdSettings.
     * @example
     * // Delete one UserAdSettings
     * const UserAdSettings = await prisma.userAdSettings.delete({
     *   where: {
     *     // ... filter to delete one UserAdSettings
     *   }
     * })
     * 
     */
    delete<T extends UserAdSettingsDeleteArgs>(args: SelectSubset<T, UserAdSettingsDeleteArgs<ExtArgs>>): Prisma__UserAdSettingsClient<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAdSettings.
     * @param {UserAdSettingsUpdateArgs} args - Arguments to update one UserAdSettings.
     * @example
     * // Update one UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAdSettingsUpdateArgs>(args: SelectSubset<T, UserAdSettingsUpdateArgs<ExtArgs>>): Prisma__UserAdSettingsClient<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAdSettings.
     * @param {UserAdSettingsDeleteManyArgs} args - Arguments to filter UserAdSettings to delete.
     * @example
     * // Delete a few UserAdSettings
     * const { count } = await prisma.userAdSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAdSettingsDeleteManyArgs>(args?: SelectSubset<T, UserAdSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAdSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAdSettingsUpdateManyArgs>(args: SelectSubset<T, UserAdSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAdSettings and returns the data updated in the database.
     * @param {UserAdSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserAdSettings.
     * @example
     * // Update many UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAdSettings and only return the `userId`
     * const userAdSettingsWithUserIdOnly = await prisma.userAdSettings.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAdSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAdSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAdSettings.
     * @param {UserAdSettingsUpsertArgs} args - Arguments to update or create a UserAdSettings.
     * @example
     * // Update or create a UserAdSettings
     * const userAdSettings = await prisma.userAdSettings.upsert({
     *   create: {
     *     // ... data to create a UserAdSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAdSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserAdSettingsUpsertArgs>(args: SelectSubset<T, UserAdSettingsUpsertArgs<ExtArgs>>): Prisma__UserAdSettingsClient<$Result.GetResult<Prisma.$UserAdSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAdSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdSettingsCountArgs} args - Arguments to filter UserAdSettings to count.
     * @example
     * // Count the number of UserAdSettings
     * const count = await prisma.userAdSettings.count({
     *   where: {
     *     // ... the filter for the UserAdSettings we want to count
     *   }
     * })
    **/
    count<T extends UserAdSettingsCountArgs>(
      args?: Subset<T, UserAdSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAdSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAdSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAdSettingsAggregateArgs>(args: Subset<T, UserAdSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserAdSettingsAggregateType<T>>

    /**
     * Group by UserAdSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAdSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAdSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserAdSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAdSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAdSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAdSettings model
   */
  readonly fields: UserAdSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAdSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAdSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAdSettings model
   */
  interface UserAdSettingsFieldRefs {
    readonly userId: FieldRef<"UserAdSettings", 'String'>
    readonly lastAdShownAt: FieldRef<"UserAdSettings", 'DateTime'>
    readonly songsSinceLastAd: FieldRef<"UserAdSettings", 'Int'>
    readonly adsPerHour: FieldRef<"UserAdSettings", 'Int'>
    readonly skipCountToday: FieldRef<"UserAdSettings", 'Int'>
    readonly skipResetAt: FieldRef<"UserAdSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAdSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAdSettings findUnique
   */
  export type UserAdSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserAdSettings to fetch.
     */
    where: UserAdSettingsWhereUniqueInput
  }

  /**
   * UserAdSettings findUniqueOrThrow
   */
  export type UserAdSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserAdSettings to fetch.
     */
    where: UserAdSettingsWhereUniqueInput
  }

  /**
   * UserAdSettings findFirst
   */
  export type UserAdSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserAdSettings to fetch.
     */
    where?: UserAdSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdSettings to fetch.
     */
    orderBy?: UserAdSettingsOrderByWithRelationInput | UserAdSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAdSettings.
     */
    cursor?: UserAdSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAdSettings.
     */
    distinct?: UserAdSettingsScalarFieldEnum | UserAdSettingsScalarFieldEnum[]
  }

  /**
   * UserAdSettings findFirstOrThrow
   */
  export type UserAdSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserAdSettings to fetch.
     */
    where?: UserAdSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdSettings to fetch.
     */
    orderBy?: UserAdSettingsOrderByWithRelationInput | UserAdSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAdSettings.
     */
    cursor?: UserAdSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAdSettings.
     */
    distinct?: UserAdSettingsScalarFieldEnum | UserAdSettingsScalarFieldEnum[]
  }

  /**
   * UserAdSettings findMany
   */
  export type UserAdSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserAdSettings to fetch.
     */
    where?: UserAdSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdSettings to fetch.
     */
    orderBy?: UserAdSettingsOrderByWithRelationInput | UserAdSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAdSettings.
     */
    cursor?: UserAdSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdSettings.
     */
    skip?: number
    distinct?: UserAdSettingsScalarFieldEnum | UserAdSettingsScalarFieldEnum[]
  }

  /**
   * UserAdSettings create
   */
  export type UserAdSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAdSettings.
     */
    data: XOR<UserAdSettingsCreateInput, UserAdSettingsUncheckedCreateInput>
  }

  /**
   * UserAdSettings createMany
   */
  export type UserAdSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAdSettings.
     */
    data: UserAdSettingsCreateManyInput | UserAdSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAdSettings createManyAndReturn
   */
  export type UserAdSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserAdSettings.
     */
    data: UserAdSettingsCreateManyInput | UserAdSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAdSettings update
   */
  export type UserAdSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAdSettings.
     */
    data: XOR<UserAdSettingsUpdateInput, UserAdSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserAdSettings to update.
     */
    where: UserAdSettingsWhereUniqueInput
  }

  /**
   * UserAdSettings updateMany
   */
  export type UserAdSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAdSettings.
     */
    data: XOR<UserAdSettingsUpdateManyMutationInput, UserAdSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserAdSettings to update
     */
    where?: UserAdSettingsWhereInput
    /**
     * Limit how many UserAdSettings to update.
     */
    limit?: number
  }

  /**
   * UserAdSettings updateManyAndReturn
   */
  export type UserAdSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserAdSettings.
     */
    data: XOR<UserAdSettingsUpdateManyMutationInput, UserAdSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserAdSettings to update
     */
    where?: UserAdSettingsWhereInput
    /**
     * Limit how many UserAdSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAdSettings upsert
   */
  export type UserAdSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAdSettings to update in case it exists.
     */
    where: UserAdSettingsWhereUniqueInput
    /**
     * In case the UserAdSettings found by the `where` argument doesn't exist, create a new UserAdSettings with this data.
     */
    create: XOR<UserAdSettingsCreateInput, UserAdSettingsUncheckedCreateInput>
    /**
     * In case the UserAdSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAdSettingsUpdateInput, UserAdSettingsUncheckedUpdateInput>
  }

  /**
   * UserAdSettings delete
   */
  export type UserAdSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserAdSettings to delete.
     */
    where: UserAdSettingsWhereUniqueInput
  }

  /**
   * UserAdSettings deleteMany
   */
  export type UserAdSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAdSettings to delete
     */
    where?: UserAdSettingsWhereInput
    /**
     * Limit how many UserAdSettings to delete.
     */
    limit?: number
  }

  /**
   * UserAdSettings without action
   */
  export type UserAdSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdSettings
     */
    select?: UserAdSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdSettings
     */
    omit?: UserAdSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdSettingsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    username: 'username',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    dateOfBirth: 'dateOfBirth',
    country: 'country',
    subscriptionType: 'subscriptionType',
    isArtist: 'isArtist',
    isActive: 'isActive',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ArtistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    slug: 'slug',
    bio: 'bio',
    avatarUrl: 'avatarUrl',
    coverUrl: 'coverUrl',
    verified: 'verified',
    monthlyListeners: 'monthlyListeners',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArtistScalarFieldEnum = (typeof ArtistScalarFieldEnum)[keyof typeof ArtistScalarFieldEnum]


  export const AlbumScalarFieldEnum: {
    id: 'id',
    artistId: 'artistId',
    title: 'title',
    slug: 'slug',
    description: 'description',
    coverUrl: 'coverUrl',
    releaseDate: 'releaseDate',
    albumType: 'albumType',
    totalTracks: 'totalTracks',
    durationMs: 'durationMs',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlbumScalarFieldEnum = (typeof AlbumScalarFieldEnum)[keyof typeof AlbumScalarFieldEnum]


  export const SongScalarFieldEnum: {
    id: 'id',
    albumId: 'albumId',
    artistId: 'artistId',
    title: 'title',
    slug: 'slug',
    trackNumber: 'trackNumber',
    discNumber: 'discNumber',
    durationMs: 'durationMs',
    audioUrl: 'audioUrl',
    previewUrl: 'previewUrl',
    lyricsUrl: 'lyricsUrl',
    isExplicit: 'isExplicit',
    isPlayable: 'isPlayable',
    playCount: 'playCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SongScalarFieldEnum = (typeof SongScalarFieldEnum)[keyof typeof SongScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    imageUrl: 'imageUrl',
    color: 'color',
    createdAt: 'createdAt'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const SongGenreScalarFieldEnum: {
    songId: 'songId',
    genreId: 'genreId'
  };

  export type SongGenreScalarFieldEnum = (typeof SongGenreScalarFieldEnum)[keyof typeof SongGenreScalarFieldEnum]


  export const ArtistGenreScalarFieldEnum: {
    artistId: 'artistId',
    genreId: 'genreId'
  };

  export type ArtistGenreScalarFieldEnum = (typeof ArtistGenreScalarFieldEnum)[keyof typeof ArtistGenreScalarFieldEnum]


  export const SongArtistScalarFieldEnum: {
    songId: 'songId',
    artistId: 'artistId',
    role: 'role'
  };

  export type SongArtistScalarFieldEnum = (typeof SongArtistScalarFieldEnum)[keyof typeof SongArtistScalarFieldEnum]


  export const PlaylistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    slug: 'slug',
    description: 'description',
    imageUrl: 'imageUrl',
    isPublic: 'isPublic',
    isCollaborative: 'isCollaborative',
    totalTracks: 'totalTracks',
    durationMs: 'durationMs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlaylistScalarFieldEnum = (typeof PlaylistScalarFieldEnum)[keyof typeof PlaylistScalarFieldEnum]


  export const PlaylistSongScalarFieldEnum: {
    id: 'id',
    playlistId: 'playlistId',
    songId: 'songId',
    position: 'position',
    addedBy: 'addedBy',
    addedAt: 'addedAt'
  };

  export type PlaylistSongScalarFieldEnum = (typeof PlaylistSongScalarFieldEnum)[keyof typeof PlaylistSongScalarFieldEnum]


  export const UserFollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingType: 'followingType',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type UserFollowScalarFieldEnum = (typeof UserFollowScalarFieldEnum)[keyof typeof UserFollowScalarFieldEnum]


  export const UserLibraryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemType: 'itemType',
    itemId: 'itemId',
    addedAt: 'addedAt'
  };

  export type UserLibraryScalarFieldEnum = (typeof UserLibraryScalarFieldEnum)[keyof typeof UserLibraryScalarFieldEnum]


  export const ListeningHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    songId: 'songId',
    playedAt: 'playedAt',
    durationMs: 'durationMs',
    contextType: 'contextType',
    contextId: 'contextId'
  };

  export type ListeningHistoryScalarFieldEnum = (typeof ListeningHistoryScalarFieldEnum)[keyof typeof ListeningHistoryScalarFieldEnum]


  export const RecentlyPlayedScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    songId: 'songId',
    playedAt: 'playedAt',
    contextType: 'contextType',
    contextId: 'contextId'
  };

  export type RecentlyPlayedScalarFieldEnum = (typeof RecentlyPlayedScalarFieldEnum)[keyof typeof RecentlyPlayedScalarFieldEnum]


  export const PlaybackQueueScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    songId: 'songId',
    position: 'position',
    addedAt: 'addedAt'
  };

  export type PlaybackQueueScalarFieldEnum = (typeof PlaybackQueueScalarFieldEnum)[keyof typeof PlaybackQueueScalarFieldEnum]


  export const PlaybackStateScalarFieldEnum: {
    userId: 'userId',
    currentSongId: 'currentSongId',
    progressMs: 'progressMs',
    isPlaying: 'isPlaying',
    shuffleMode: 'shuffleMode',
    repeatMode: 'repeatMode',
    volume: 'volume',
    contextType: 'contextType',
    contextId: 'contextId',
    activeDeviceId: 'activeDeviceId',
    updatedAt: 'updatedAt'
  };

  export type PlaybackStateScalarFieldEnum = (typeof PlaybackStateScalarFieldEnum)[keyof typeof PlaybackStateScalarFieldEnum]


  export const UserOAuthAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerUserId: 'providerUserId',
    email: 'email',
    name: 'name',
    avatarUrl: 'avatarUrl',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenExpiresAt: 'tokenExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserOAuthAccountScalarFieldEnum = (typeof UserOAuthAccountScalarFieldEnum)[keyof typeof UserOAuthAccountScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceId: 'deviceId',
    tokenHash: 'tokenHash',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    lastActivityAt: 'lastActivityAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const UserDeviceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceType: 'deviceType',
    deviceName: 'deviceName',
    deviceToken: 'deviceToken',
    appVersion: 'appVersion',
    osVersion: 'osVersion',
    isActive: 'isActive',
    lastSyncAt: 'lastSyncAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserDeviceScalarFieldEnum = (typeof UserDeviceScalarFieldEnum)[keyof typeof UserDeviceScalarFieldEnum]


  export const DeviceSyncStateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceId: 'deviceId',
    syncType: 'syncType',
    lastSyncVersion: 'lastSyncVersion',
    lastSyncAt: 'lastSyncAt',
    pendingChanges: 'pendingChanges'
  };

  export type DeviceSyncStateScalarFieldEnum = (typeof DeviceSyncStateScalarFieldEnum)[keyof typeof DeviceSyncStateScalarFieldEnum]


  export const SyncLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    version: 'version',
    payload: 'payload',
    sourceDeviceId: 'sourceDeviceId',
    createdAt: 'createdAt'
  };

  export type SyncLogScalarFieldEnum = (typeof SyncLogScalarFieldEnum)[keyof typeof SyncLogScalarFieldEnum]


  export const DeviceTransferScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fromDeviceId: 'fromDeviceId',
    toDeviceId: 'toDeviceId',
    status: 'status',
    transferData: 'transferData',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type DeviceTransferScalarFieldEnum = (typeof DeviceTransferScalarFieldEnum)[keyof typeof DeviceTransferScalarFieldEnum]


  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    priceMonthly: 'priceMonthly',
    priceYearly: 'priceYearly',
    currency: 'currency',
    maxDevices: 'maxDevices',
    hasAds: 'hasAds',
    canDownload: 'canDownload',
    audioQuality: 'audioQuality',
    smartShuffle: 'smartShuffle',
    skipLimit: 'skipLimit',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


  export const UserSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    status: 'status',
    billingCycle: 'billingCycle',
    startDate: 'startDate',
    endDate: 'endDate',
    nextBillingDate: 'nextBillingDate',
    cancelledAt: 'cancelledAt',
    paymentMethod: 'paymentMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


  export const AdvertisementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    advertiser: 'advertiser',
    adType: 'adType',
    mediaUrl: 'mediaUrl',
    clickUrl: 'clickUrl',
    durationMs: 'durationMs',
    targetCountries: 'targetCountries',
    targetAgeMin: 'targetAgeMin',
    targetAgeMax: 'targetAgeMax',
    targetGenres: 'targetGenres',
    priority: 'priority',
    budget: 'budget',
    costPerImpression: 'costPerImpression',
    costPerClick: 'costPerClick',
    totalImpressions: 'totalImpressions',
    totalClicks: 'totalClicks',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdvertisementScalarFieldEnum = (typeof AdvertisementScalarFieldEnum)[keyof typeof AdvertisementScalarFieldEnum]


  export const AdImpressionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adId: 'adId',
    deviceId: 'deviceId',
    impressionType: 'impressionType',
    contextType: 'contextType',
    revenue: 'revenue',
    createdAt: 'createdAt'
  };

  export type AdImpressionScalarFieldEnum = (typeof AdImpressionScalarFieldEnum)[keyof typeof AdImpressionScalarFieldEnum]


  export const UserAdSettingsScalarFieldEnum: {
    userId: 'userId',
    lastAdShownAt: 'lastAdShownAt',
    songsSinceLastAd: 'songsSinceLastAd',
    adsPerHour: 'adsPerHour',
    skipCountToday: 'skipCountToday',
    skipResetAt: 'skipResetAt',
    updatedAt: 'updatedAt'
  };

  export type UserAdSettingsScalarFieldEnum = (typeof UserAdSettingsScalarFieldEnum)[keyof typeof UserAdSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SubscriptionType'
   */
  export type EnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType'>
    


  /**
   * Reference to a field of type 'SubscriptionType[]'
   */
  export type ListEnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AlbumType'
   */
  export type EnumAlbumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlbumType'>
    


  /**
   * Reference to a field of type 'AlbumType[]'
   */
  export type ListEnumAlbumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlbumType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'ArtistRole'
   */
  export type EnumArtistRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtistRole'>
    


  /**
   * Reference to a field of type 'ArtistRole[]'
   */
  export type ListEnumArtistRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtistRole[]'>
    


  /**
   * Reference to a field of type 'FollowType'
   */
  export type EnumFollowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowType'>
    


  /**
   * Reference to a field of type 'FollowType[]'
   */
  export type ListEnumFollowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowType[]'>
    


  /**
   * Reference to a field of type 'LibraryItemType'
   */
  export type EnumLibraryItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LibraryItemType'>
    


  /**
   * Reference to a field of type 'LibraryItemType[]'
   */
  export type ListEnumLibraryItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LibraryItemType[]'>
    


  /**
   * Reference to a field of type 'ContextType'
   */
  export type EnumContextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContextType'>
    


  /**
   * Reference to a field of type 'ContextType[]'
   */
  export type ListEnumContextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContextType[]'>
    


  /**
   * Reference to a field of type 'ShuffleMode'
   */
  export type EnumShuffleModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShuffleMode'>
    


  /**
   * Reference to a field of type 'ShuffleMode[]'
   */
  export type ListEnumShuffleModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShuffleMode[]'>
    


  /**
   * Reference to a field of type 'RepeatMode'
   */
  export type EnumRepeatModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RepeatMode'>
    


  /**
   * Reference to a field of type 'RepeatMode[]'
   */
  export type ListEnumRepeatModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RepeatMode[]'>
    


  /**
   * Reference to a field of type 'DeviceType'
   */
  export type EnumDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceType'>
    


  /**
   * Reference to a field of type 'DeviceType[]'
   */
  export type ListEnumDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceType[]'>
    


  /**
   * Reference to a field of type 'SyncType'
   */
  export type EnumSyncTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncType'>
    


  /**
   * Reference to a field of type 'SyncType[]'
   */
  export type ListEnumSyncTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncType[]'>
    


  /**
   * Reference to a field of type 'SyncAction'
   */
  export type EnumSyncActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncAction'>
    


  /**
   * Reference to a field of type 'SyncAction[]'
   */
  export type ListEnumSyncActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncAction[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'TransferStatus[]'
   */
  export type ListEnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'AudioQuality'
   */
  export type EnumAudioQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AudioQuality'>
    


  /**
   * Reference to a field of type 'AudioQuality[]'
   */
  export type ListEnumAudioQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AudioQuality[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'BillingCycle'
   */
  export type EnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle'>
    


  /**
   * Reference to a field of type 'BillingCycle[]'
   */
  export type ListEnumBillingCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingCycle[]'>
    


  /**
   * Reference to a field of type 'AdType'
   */
  export type EnumAdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdType'>
    


  /**
   * Reference to a field of type 'AdType[]'
   */
  export type ListEnumAdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdType[]'>
    


  /**
   * Reference to a field of type 'ImpressionType'
   */
  export type EnumImpressionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImpressionType'>
    


  /**
   * Reference to a field of type 'ImpressionType[]'
   */
  export type ListEnumImpressionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImpressionType[]'>
    


  /**
   * Reference to a field of type 'AdContextType'
   */
  export type EnumAdContextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdContextType'>
    


  /**
   * Reference to a field of type 'AdContextType[]'
   */
  export type ListEnumAdContextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdContextType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    country?: StringNullableFilter<"User"> | string | null
    subscriptionType?: EnumSubscriptionTypeFilter<"User"> | $Enums.SubscriptionType
    isArtist?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    artist?: XOR<ArtistNullableScalarRelationFilter, ArtistWhereInput> | null
    oauthAccounts?: UserOAuthAccountListRelationFilter
    sessions?: UserSessionListRelationFilter
    devices?: UserDeviceListRelationFilter
    playlists?: PlaylistListRelationFilter
    follows?: UserFollowListRelationFilter
    library?: UserLibraryListRelationFilter
    listeningHistory?: ListeningHistoryListRelationFilter
    recentlyPlayed?: RecentlyPlayedListRelationFilter
    playbackState?: XOR<PlaybackStateNullableScalarRelationFilter, PlaybackStateWhereInput> | null
    playbackQueue?: PlaybackQueueListRelationFilter
    subscriptions?: UserSubscriptionListRelationFilter
    adImpressions?: AdImpressionListRelationFilter
    adSettings?: XOR<UserAdSettingsNullableScalarRelationFilter, UserAdSettingsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    username?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    subscriptionType?: SortOrder
    isArtist?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artist?: ArtistOrderByWithRelationInput
    oauthAccounts?: UserOAuthAccountOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
    devices?: UserDeviceOrderByRelationAggregateInput
    playlists?: PlaylistOrderByRelationAggregateInput
    follows?: UserFollowOrderByRelationAggregateInput
    library?: UserLibraryOrderByRelationAggregateInput
    listeningHistory?: ListeningHistoryOrderByRelationAggregateInput
    recentlyPlayed?: RecentlyPlayedOrderByRelationAggregateInput
    playbackState?: PlaybackStateOrderByWithRelationInput
    playbackQueue?: PlaybackQueueOrderByRelationAggregateInput
    subscriptions?: UserSubscriptionOrderByRelationAggregateInput
    adImpressions?: AdImpressionOrderByRelationAggregateInput
    adSettings?: UserAdSettingsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    country?: StringNullableFilter<"User"> | string | null
    subscriptionType?: EnumSubscriptionTypeFilter<"User"> | $Enums.SubscriptionType
    isArtist?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    artist?: XOR<ArtistNullableScalarRelationFilter, ArtistWhereInput> | null
    oauthAccounts?: UserOAuthAccountListRelationFilter
    sessions?: UserSessionListRelationFilter
    devices?: UserDeviceListRelationFilter
    playlists?: PlaylistListRelationFilter
    follows?: UserFollowListRelationFilter
    library?: UserLibraryListRelationFilter
    listeningHistory?: ListeningHistoryListRelationFilter
    recentlyPlayed?: RecentlyPlayedListRelationFilter
    playbackState?: XOR<PlaybackStateNullableScalarRelationFilter, PlaybackStateWhereInput> | null
    playbackQueue?: PlaybackQueueListRelationFilter
    subscriptions?: UserSubscriptionListRelationFilter
    adImpressions?: AdImpressionListRelationFilter
    adSettings?: XOR<UserAdSettingsNullableScalarRelationFilter, UserAdSettingsWhereInput> | null
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    username?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    subscriptionType?: SortOrder
    isArtist?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionType?: EnumSubscriptionTypeWithAggregatesFilter<"User"> | $Enums.SubscriptionType
    isArtist?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ArtistWhereInput = {
    AND?: ArtistWhereInput | ArtistWhereInput[]
    OR?: ArtistWhereInput[]
    NOT?: ArtistWhereInput | ArtistWhereInput[]
    id?: StringFilter<"Artist"> | string
    userId?: StringNullableFilter<"Artist"> | string | null
    name?: StringFilter<"Artist"> | string
    slug?: StringFilter<"Artist"> | string
    bio?: StringNullableFilter<"Artist"> | string | null
    avatarUrl?: StringNullableFilter<"Artist"> | string | null
    coverUrl?: StringNullableFilter<"Artist"> | string | null
    verified?: BoolFilter<"Artist"> | boolean
    monthlyListeners?: IntFilter<"Artist"> | number
    createdAt?: DateTimeFilter<"Artist"> | Date | string
    updatedAt?: DateTimeFilter<"Artist"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    albums?: AlbumListRelationFilter
    songs?: SongListRelationFilter
    songArtists?: SongArtistListRelationFilter
    genres?: ArtistGenreListRelationFilter
  }

  export type ArtistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    albums?: AlbumOrderByRelationAggregateInput
    songs?: SongOrderByRelationAggregateInput
    songArtists?: SongArtistOrderByRelationAggregateInput
    genres?: ArtistGenreOrderByRelationAggregateInput
  }

  export type ArtistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    slug?: string
    AND?: ArtistWhereInput | ArtistWhereInput[]
    OR?: ArtistWhereInput[]
    NOT?: ArtistWhereInput | ArtistWhereInput[]
    name?: StringFilter<"Artist"> | string
    bio?: StringNullableFilter<"Artist"> | string | null
    avatarUrl?: StringNullableFilter<"Artist"> | string | null
    coverUrl?: StringNullableFilter<"Artist"> | string | null
    verified?: BoolFilter<"Artist"> | boolean
    monthlyListeners?: IntFilter<"Artist"> | number
    createdAt?: DateTimeFilter<"Artist"> | Date | string
    updatedAt?: DateTimeFilter<"Artist"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    albums?: AlbumListRelationFilter
    songs?: SongListRelationFilter
    songArtists?: SongArtistListRelationFilter
    genres?: ArtistGenreListRelationFilter
  }, "id" | "userId" | "slug">

  export type ArtistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArtistCountOrderByAggregateInput
    _avg?: ArtistAvgOrderByAggregateInput
    _max?: ArtistMaxOrderByAggregateInput
    _min?: ArtistMinOrderByAggregateInput
    _sum?: ArtistSumOrderByAggregateInput
  }

  export type ArtistScalarWhereWithAggregatesInput = {
    AND?: ArtistScalarWhereWithAggregatesInput | ArtistScalarWhereWithAggregatesInput[]
    OR?: ArtistScalarWhereWithAggregatesInput[]
    NOT?: ArtistScalarWhereWithAggregatesInput | ArtistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Artist"> | string
    userId?: StringNullableWithAggregatesFilter<"Artist"> | string | null
    name?: StringWithAggregatesFilter<"Artist"> | string
    slug?: StringWithAggregatesFilter<"Artist"> | string
    bio?: StringNullableWithAggregatesFilter<"Artist"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Artist"> | string | null
    coverUrl?: StringNullableWithAggregatesFilter<"Artist"> | string | null
    verified?: BoolWithAggregatesFilter<"Artist"> | boolean
    monthlyListeners?: IntWithAggregatesFilter<"Artist"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Artist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Artist"> | Date | string
  }

  export type AlbumWhereInput = {
    AND?: AlbumWhereInput | AlbumWhereInput[]
    OR?: AlbumWhereInput[]
    NOT?: AlbumWhereInput | AlbumWhereInput[]
    id?: StringFilter<"Album"> | string
    artistId?: StringFilter<"Album"> | string
    title?: StringFilter<"Album"> | string
    slug?: StringFilter<"Album"> | string
    description?: StringNullableFilter<"Album"> | string | null
    coverUrl?: StringNullableFilter<"Album"> | string | null
    releaseDate?: DateTimeNullableFilter<"Album"> | Date | string | null
    albumType?: EnumAlbumTypeFilter<"Album"> | $Enums.AlbumType
    totalTracks?: IntFilter<"Album"> | number
    durationMs?: IntFilter<"Album"> | number
    isPublished?: BoolFilter<"Album"> | boolean
    createdAt?: DateTimeFilter<"Album"> | Date | string
    updatedAt?: DateTimeFilter<"Album"> | Date | string
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    songs?: SongListRelationFilter
  }

  export type AlbumOrderByWithRelationInput = {
    id?: SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    albumType?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artist?: ArtistOrderByWithRelationInput
    songs?: SongOrderByRelationAggregateInput
  }

  export type AlbumWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: AlbumWhereInput | AlbumWhereInput[]
    OR?: AlbumWhereInput[]
    NOT?: AlbumWhereInput | AlbumWhereInput[]
    artistId?: StringFilter<"Album"> | string
    title?: StringFilter<"Album"> | string
    description?: StringNullableFilter<"Album"> | string | null
    coverUrl?: StringNullableFilter<"Album"> | string | null
    releaseDate?: DateTimeNullableFilter<"Album"> | Date | string | null
    albumType?: EnumAlbumTypeFilter<"Album"> | $Enums.AlbumType
    totalTracks?: IntFilter<"Album"> | number
    durationMs?: IntFilter<"Album"> | number
    isPublished?: BoolFilter<"Album"> | boolean
    createdAt?: DateTimeFilter<"Album"> | Date | string
    updatedAt?: DateTimeFilter<"Album"> | Date | string
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    songs?: SongListRelationFilter
  }, "id" | "slug">

  export type AlbumOrderByWithAggregationInput = {
    id?: SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    albumType?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlbumCountOrderByAggregateInput
    _avg?: AlbumAvgOrderByAggregateInput
    _max?: AlbumMaxOrderByAggregateInput
    _min?: AlbumMinOrderByAggregateInput
    _sum?: AlbumSumOrderByAggregateInput
  }

  export type AlbumScalarWhereWithAggregatesInput = {
    AND?: AlbumScalarWhereWithAggregatesInput | AlbumScalarWhereWithAggregatesInput[]
    OR?: AlbumScalarWhereWithAggregatesInput[]
    NOT?: AlbumScalarWhereWithAggregatesInput | AlbumScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Album"> | string
    artistId?: StringWithAggregatesFilter<"Album"> | string
    title?: StringWithAggregatesFilter<"Album"> | string
    slug?: StringWithAggregatesFilter<"Album"> | string
    description?: StringNullableWithAggregatesFilter<"Album"> | string | null
    coverUrl?: StringNullableWithAggregatesFilter<"Album"> | string | null
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Album"> | Date | string | null
    albumType?: EnumAlbumTypeWithAggregatesFilter<"Album"> | $Enums.AlbumType
    totalTracks?: IntWithAggregatesFilter<"Album"> | number
    durationMs?: IntWithAggregatesFilter<"Album"> | number
    isPublished?: BoolWithAggregatesFilter<"Album"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Album"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Album"> | Date | string
  }

  export type SongWhereInput = {
    AND?: SongWhereInput | SongWhereInput[]
    OR?: SongWhereInput[]
    NOT?: SongWhereInput | SongWhereInput[]
    id?: StringFilter<"Song"> | string
    albumId?: StringNullableFilter<"Song"> | string | null
    artistId?: StringFilter<"Song"> | string
    title?: StringFilter<"Song"> | string
    slug?: StringFilter<"Song"> | string
    trackNumber?: IntNullableFilter<"Song"> | number | null
    discNumber?: IntFilter<"Song"> | number
    durationMs?: IntFilter<"Song"> | number
    audioUrl?: StringFilter<"Song"> | string
    previewUrl?: StringNullableFilter<"Song"> | string | null
    lyricsUrl?: StringNullableFilter<"Song"> | string | null
    isExplicit?: BoolFilter<"Song"> | boolean
    isPlayable?: BoolFilter<"Song"> | boolean
    playCount?: BigIntFilter<"Song"> | bigint | number
    createdAt?: DateTimeFilter<"Song"> | Date | string
    updatedAt?: DateTimeFilter<"Song"> | Date | string
    album?: XOR<AlbumNullableScalarRelationFilter, AlbumWhereInput> | null
    primaryArtist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    songArtists?: SongArtistListRelationFilter
    genres?: SongGenreListRelationFilter
    playlistSongs?: PlaylistSongListRelationFilter
    listeningHistory?: ListeningHistoryListRelationFilter
    recentlyPlayed?: RecentlyPlayedListRelationFilter
    playbackStates?: PlaybackStateListRelationFilter
    playbackQueues?: PlaybackQueueListRelationFilter
  }

  export type SongOrderByWithRelationInput = {
    id?: SortOrder
    albumId?: SortOrderInput | SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    trackNumber?: SortOrderInput | SortOrder
    discNumber?: SortOrder
    durationMs?: SortOrder
    audioUrl?: SortOrder
    previewUrl?: SortOrderInput | SortOrder
    lyricsUrl?: SortOrderInput | SortOrder
    isExplicit?: SortOrder
    isPlayable?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    album?: AlbumOrderByWithRelationInput
    primaryArtist?: ArtistOrderByWithRelationInput
    songArtists?: SongArtistOrderByRelationAggregateInput
    genres?: SongGenreOrderByRelationAggregateInput
    playlistSongs?: PlaylistSongOrderByRelationAggregateInput
    listeningHistory?: ListeningHistoryOrderByRelationAggregateInput
    recentlyPlayed?: RecentlyPlayedOrderByRelationAggregateInput
    playbackStates?: PlaybackStateOrderByRelationAggregateInput
    playbackQueues?: PlaybackQueueOrderByRelationAggregateInput
  }

  export type SongWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SongWhereInput | SongWhereInput[]
    OR?: SongWhereInput[]
    NOT?: SongWhereInput | SongWhereInput[]
    albumId?: StringNullableFilter<"Song"> | string | null
    artistId?: StringFilter<"Song"> | string
    title?: StringFilter<"Song"> | string
    trackNumber?: IntNullableFilter<"Song"> | number | null
    discNumber?: IntFilter<"Song"> | number
    durationMs?: IntFilter<"Song"> | number
    audioUrl?: StringFilter<"Song"> | string
    previewUrl?: StringNullableFilter<"Song"> | string | null
    lyricsUrl?: StringNullableFilter<"Song"> | string | null
    isExplicit?: BoolFilter<"Song"> | boolean
    isPlayable?: BoolFilter<"Song"> | boolean
    playCount?: BigIntFilter<"Song"> | bigint | number
    createdAt?: DateTimeFilter<"Song"> | Date | string
    updatedAt?: DateTimeFilter<"Song"> | Date | string
    album?: XOR<AlbumNullableScalarRelationFilter, AlbumWhereInput> | null
    primaryArtist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    songArtists?: SongArtistListRelationFilter
    genres?: SongGenreListRelationFilter
    playlistSongs?: PlaylistSongListRelationFilter
    listeningHistory?: ListeningHistoryListRelationFilter
    recentlyPlayed?: RecentlyPlayedListRelationFilter
    playbackStates?: PlaybackStateListRelationFilter
    playbackQueues?: PlaybackQueueListRelationFilter
  }, "id" | "slug">

  export type SongOrderByWithAggregationInput = {
    id?: SortOrder
    albumId?: SortOrderInput | SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    trackNumber?: SortOrderInput | SortOrder
    discNumber?: SortOrder
    durationMs?: SortOrder
    audioUrl?: SortOrder
    previewUrl?: SortOrderInput | SortOrder
    lyricsUrl?: SortOrderInput | SortOrder
    isExplicit?: SortOrder
    isPlayable?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SongCountOrderByAggregateInput
    _avg?: SongAvgOrderByAggregateInput
    _max?: SongMaxOrderByAggregateInput
    _min?: SongMinOrderByAggregateInput
    _sum?: SongSumOrderByAggregateInput
  }

  export type SongScalarWhereWithAggregatesInput = {
    AND?: SongScalarWhereWithAggregatesInput | SongScalarWhereWithAggregatesInput[]
    OR?: SongScalarWhereWithAggregatesInput[]
    NOT?: SongScalarWhereWithAggregatesInput | SongScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Song"> | string
    albumId?: StringNullableWithAggregatesFilter<"Song"> | string | null
    artistId?: StringWithAggregatesFilter<"Song"> | string
    title?: StringWithAggregatesFilter<"Song"> | string
    slug?: StringWithAggregatesFilter<"Song"> | string
    trackNumber?: IntNullableWithAggregatesFilter<"Song"> | number | null
    discNumber?: IntWithAggregatesFilter<"Song"> | number
    durationMs?: IntWithAggregatesFilter<"Song"> | number
    audioUrl?: StringWithAggregatesFilter<"Song"> | string
    previewUrl?: StringNullableWithAggregatesFilter<"Song"> | string | null
    lyricsUrl?: StringNullableWithAggregatesFilter<"Song"> | string | null
    isExplicit?: BoolWithAggregatesFilter<"Song"> | boolean
    isPlayable?: BoolWithAggregatesFilter<"Song"> | boolean
    playCount?: BigIntWithAggregatesFilter<"Song"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Song"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Song"> | Date | string
  }

  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    id?: StringFilter<"Genre"> | string
    name?: StringFilter<"Genre"> | string
    slug?: StringFilter<"Genre"> | string
    description?: StringNullableFilter<"Genre"> | string | null
    imageUrl?: StringNullableFilter<"Genre"> | string | null
    color?: StringNullableFilter<"Genre"> | string | null
    createdAt?: DateTimeFilter<"Genre"> | Date | string
    songs?: SongGenreListRelationFilter
    artists?: ArtistGenreListRelationFilter
  }

  export type GenreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    songs?: SongGenreOrderByRelationAggregateInput
    artists?: ArtistGenreOrderByRelationAggregateInput
  }

  export type GenreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    description?: StringNullableFilter<"Genre"> | string | null
    imageUrl?: StringNullableFilter<"Genre"> | string | null
    color?: StringNullableFilter<"Genre"> | string | null
    createdAt?: DateTimeFilter<"Genre"> | Date | string
    songs?: SongGenreListRelationFilter
    artists?: ArtistGenreListRelationFilter
  }, "id" | "name" | "slug">

  export type GenreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GenreCountOrderByAggregateInput
    _max?: GenreMaxOrderByAggregateInput
    _min?: GenreMinOrderByAggregateInput
  }

  export type GenreScalarWhereWithAggregatesInput = {
    AND?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    OR?: GenreScalarWhereWithAggregatesInput[]
    NOT?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Genre"> | string
    name?: StringWithAggregatesFilter<"Genre"> | string
    slug?: StringWithAggregatesFilter<"Genre"> | string
    description?: StringNullableWithAggregatesFilter<"Genre"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Genre"> | string | null
    color?: StringNullableWithAggregatesFilter<"Genre"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Genre"> | Date | string
  }

  export type SongGenreWhereInput = {
    AND?: SongGenreWhereInput | SongGenreWhereInput[]
    OR?: SongGenreWhereInput[]
    NOT?: SongGenreWhereInput | SongGenreWhereInput[]
    songId?: StringFilter<"SongGenre"> | string
    genreId?: StringFilter<"SongGenre"> | string
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }

  export type SongGenreOrderByWithRelationInput = {
    songId?: SortOrder
    genreId?: SortOrder
    song?: SongOrderByWithRelationInput
    genre?: GenreOrderByWithRelationInput
  }

  export type SongGenreWhereUniqueInput = Prisma.AtLeast<{
    songId_genreId?: SongGenreSongIdGenreIdCompoundUniqueInput
    AND?: SongGenreWhereInput | SongGenreWhereInput[]
    OR?: SongGenreWhereInput[]
    NOT?: SongGenreWhereInput | SongGenreWhereInput[]
    songId?: StringFilter<"SongGenre"> | string
    genreId?: StringFilter<"SongGenre"> | string
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }, "songId_genreId">

  export type SongGenreOrderByWithAggregationInput = {
    songId?: SortOrder
    genreId?: SortOrder
    _count?: SongGenreCountOrderByAggregateInput
    _max?: SongGenreMaxOrderByAggregateInput
    _min?: SongGenreMinOrderByAggregateInput
  }

  export type SongGenreScalarWhereWithAggregatesInput = {
    AND?: SongGenreScalarWhereWithAggregatesInput | SongGenreScalarWhereWithAggregatesInput[]
    OR?: SongGenreScalarWhereWithAggregatesInput[]
    NOT?: SongGenreScalarWhereWithAggregatesInput | SongGenreScalarWhereWithAggregatesInput[]
    songId?: StringWithAggregatesFilter<"SongGenre"> | string
    genreId?: StringWithAggregatesFilter<"SongGenre"> | string
  }

  export type ArtistGenreWhereInput = {
    AND?: ArtistGenreWhereInput | ArtistGenreWhereInput[]
    OR?: ArtistGenreWhereInput[]
    NOT?: ArtistGenreWhereInput | ArtistGenreWhereInput[]
    artistId?: StringFilter<"ArtistGenre"> | string
    genreId?: StringFilter<"ArtistGenre"> | string
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }

  export type ArtistGenreOrderByWithRelationInput = {
    artistId?: SortOrder
    genreId?: SortOrder
    artist?: ArtistOrderByWithRelationInput
    genre?: GenreOrderByWithRelationInput
  }

  export type ArtistGenreWhereUniqueInput = Prisma.AtLeast<{
    artistId_genreId?: ArtistGenreArtistIdGenreIdCompoundUniqueInput
    AND?: ArtistGenreWhereInput | ArtistGenreWhereInput[]
    OR?: ArtistGenreWhereInput[]
    NOT?: ArtistGenreWhereInput | ArtistGenreWhereInput[]
    artistId?: StringFilter<"ArtistGenre"> | string
    genreId?: StringFilter<"ArtistGenre"> | string
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }, "artistId_genreId">

  export type ArtistGenreOrderByWithAggregationInput = {
    artistId?: SortOrder
    genreId?: SortOrder
    _count?: ArtistGenreCountOrderByAggregateInput
    _max?: ArtistGenreMaxOrderByAggregateInput
    _min?: ArtistGenreMinOrderByAggregateInput
  }

  export type ArtistGenreScalarWhereWithAggregatesInput = {
    AND?: ArtistGenreScalarWhereWithAggregatesInput | ArtistGenreScalarWhereWithAggregatesInput[]
    OR?: ArtistGenreScalarWhereWithAggregatesInput[]
    NOT?: ArtistGenreScalarWhereWithAggregatesInput | ArtistGenreScalarWhereWithAggregatesInput[]
    artistId?: StringWithAggregatesFilter<"ArtistGenre"> | string
    genreId?: StringWithAggregatesFilter<"ArtistGenre"> | string
  }

  export type SongArtistWhereInput = {
    AND?: SongArtistWhereInput | SongArtistWhereInput[]
    OR?: SongArtistWhereInput[]
    NOT?: SongArtistWhereInput | SongArtistWhereInput[]
    songId?: StringFilter<"SongArtist"> | string
    artistId?: StringFilter<"SongArtist"> | string
    role?: EnumArtistRoleFilter<"SongArtist"> | $Enums.ArtistRole
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
  }

  export type SongArtistOrderByWithRelationInput = {
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
    song?: SongOrderByWithRelationInput
    artist?: ArtistOrderByWithRelationInput
  }

  export type SongArtistWhereUniqueInput = Prisma.AtLeast<{
    songId_artistId?: SongArtistSongIdArtistIdCompoundUniqueInput
    AND?: SongArtistWhereInput | SongArtistWhereInput[]
    OR?: SongArtistWhereInput[]
    NOT?: SongArtistWhereInput | SongArtistWhereInput[]
    songId?: StringFilter<"SongArtist"> | string
    artistId?: StringFilter<"SongArtist"> | string
    role?: EnumArtistRoleFilter<"SongArtist"> | $Enums.ArtistRole
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
    artist?: XOR<ArtistScalarRelationFilter, ArtistWhereInput>
  }, "songId_artistId">

  export type SongArtistOrderByWithAggregationInput = {
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
    _count?: SongArtistCountOrderByAggregateInput
    _max?: SongArtistMaxOrderByAggregateInput
    _min?: SongArtistMinOrderByAggregateInput
  }

  export type SongArtistScalarWhereWithAggregatesInput = {
    AND?: SongArtistScalarWhereWithAggregatesInput | SongArtistScalarWhereWithAggregatesInput[]
    OR?: SongArtistScalarWhereWithAggregatesInput[]
    NOT?: SongArtistScalarWhereWithAggregatesInput | SongArtistScalarWhereWithAggregatesInput[]
    songId?: StringWithAggregatesFilter<"SongArtist"> | string
    artistId?: StringWithAggregatesFilter<"SongArtist"> | string
    role?: EnumArtistRoleWithAggregatesFilter<"SongArtist"> | $Enums.ArtistRole
  }

  export type PlaylistWhereInput = {
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    id?: StringFilter<"Playlist"> | string
    userId?: StringFilter<"Playlist"> | string
    name?: StringFilter<"Playlist"> | string
    slug?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    imageUrl?: StringNullableFilter<"Playlist"> | string | null
    isPublic?: BoolFilter<"Playlist"> | boolean
    isCollaborative?: BoolFilter<"Playlist"> | boolean
    totalTracks?: IntFilter<"Playlist"> | number
    durationMs?: IntFilter<"Playlist"> | number
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    songs?: PlaylistSongListRelationFilter
    followers?: UserFollowListRelationFilter
  }

  export type PlaylistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isCollaborative?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    songs?: PlaylistSongOrderByRelationAggregateInput
    followers?: UserFollowOrderByRelationAggregateInput
  }

  export type PlaylistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    userId?: StringFilter<"Playlist"> | string
    name?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    imageUrl?: StringNullableFilter<"Playlist"> | string | null
    isPublic?: BoolFilter<"Playlist"> | boolean
    isCollaborative?: BoolFilter<"Playlist"> | boolean
    totalTracks?: IntFilter<"Playlist"> | number
    durationMs?: IntFilter<"Playlist"> | number
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    songs?: PlaylistSongListRelationFilter
    followers?: UserFollowListRelationFilter
  }, "id" | "slug">

  export type PlaylistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isCollaborative?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlaylistCountOrderByAggregateInput
    _avg?: PlaylistAvgOrderByAggregateInput
    _max?: PlaylistMaxOrderByAggregateInput
    _min?: PlaylistMinOrderByAggregateInput
    _sum?: PlaylistSumOrderByAggregateInput
  }

  export type PlaylistScalarWhereWithAggregatesInput = {
    AND?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    OR?: PlaylistScalarWhereWithAggregatesInput[]
    NOT?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Playlist"> | string
    userId?: StringWithAggregatesFilter<"Playlist"> | string
    name?: StringWithAggregatesFilter<"Playlist"> | string
    slug?: StringWithAggregatesFilter<"Playlist"> | string
    description?: StringNullableWithAggregatesFilter<"Playlist"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Playlist"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Playlist"> | boolean
    isCollaborative?: BoolWithAggregatesFilter<"Playlist"> | boolean
    totalTracks?: IntWithAggregatesFilter<"Playlist"> | number
    durationMs?: IntWithAggregatesFilter<"Playlist"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string
  }

  export type PlaylistSongWhereInput = {
    AND?: PlaylistSongWhereInput | PlaylistSongWhereInput[]
    OR?: PlaylistSongWhereInput[]
    NOT?: PlaylistSongWhereInput | PlaylistSongWhereInput[]
    id?: StringFilter<"PlaylistSong"> | string
    playlistId?: StringFilter<"PlaylistSong"> | string
    songId?: StringFilter<"PlaylistSong"> | string
    position?: IntFilter<"PlaylistSong"> | number
    addedBy?: StringNullableFilter<"PlaylistSong"> | string | null
    addedAt?: DateTimeFilter<"PlaylistSong"> | Date | string
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }

  export type PlaylistSongOrderByWithRelationInput = {
    id?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedBy?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    playlist?: PlaylistOrderByWithRelationInput
    song?: SongOrderByWithRelationInput
  }

  export type PlaylistSongWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playlistId_songId?: PlaylistSongPlaylistIdSongIdCompoundUniqueInput
    AND?: PlaylistSongWhereInput | PlaylistSongWhereInput[]
    OR?: PlaylistSongWhereInput[]
    NOT?: PlaylistSongWhereInput | PlaylistSongWhereInput[]
    playlistId?: StringFilter<"PlaylistSong"> | string
    songId?: StringFilter<"PlaylistSong"> | string
    position?: IntFilter<"PlaylistSong"> | number
    addedBy?: StringNullableFilter<"PlaylistSong"> | string | null
    addedAt?: DateTimeFilter<"PlaylistSong"> | Date | string
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }, "id" | "playlistId_songId">

  export type PlaylistSongOrderByWithAggregationInput = {
    id?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedBy?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    _count?: PlaylistSongCountOrderByAggregateInput
    _avg?: PlaylistSongAvgOrderByAggregateInput
    _max?: PlaylistSongMaxOrderByAggregateInput
    _min?: PlaylistSongMinOrderByAggregateInput
    _sum?: PlaylistSongSumOrderByAggregateInput
  }

  export type PlaylistSongScalarWhereWithAggregatesInput = {
    AND?: PlaylistSongScalarWhereWithAggregatesInput | PlaylistSongScalarWhereWithAggregatesInput[]
    OR?: PlaylistSongScalarWhereWithAggregatesInput[]
    NOT?: PlaylistSongScalarWhereWithAggregatesInput | PlaylistSongScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlaylistSong"> | string
    playlistId?: StringWithAggregatesFilter<"PlaylistSong"> | string
    songId?: StringWithAggregatesFilter<"PlaylistSong"> | string
    position?: IntWithAggregatesFilter<"PlaylistSong"> | number
    addedBy?: StringNullableWithAggregatesFilter<"PlaylistSong"> | string | null
    addedAt?: DateTimeWithAggregatesFilter<"PlaylistSong"> | Date | string
  }

  export type UserFollowWhereInput = {
    AND?: UserFollowWhereInput | UserFollowWhereInput[]
    OR?: UserFollowWhereInput[]
    NOT?: UserFollowWhereInput | UserFollowWhereInput[]
    id?: StringFilter<"UserFollow"> | string
    followerId?: StringFilter<"UserFollow"> | string
    followingType?: EnumFollowTypeFilter<"UserFollow"> | $Enums.FollowType
    followingId?: StringFilter<"UserFollow"> | string
    createdAt?: DateTimeFilter<"UserFollow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    playlist?: XOR<PlaylistNullableScalarRelationFilter, PlaylistWhereInput> | null
  }

  export type UserFollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingType?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    playlist?: PlaylistOrderByWithRelationInput
  }

  export type UserFollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingType_followingId?: UserFollowFollowerIdFollowingTypeFollowingIdCompoundUniqueInput
    AND?: UserFollowWhereInput | UserFollowWhereInput[]
    OR?: UserFollowWhereInput[]
    NOT?: UserFollowWhereInput | UserFollowWhereInput[]
    followerId?: StringFilter<"UserFollow"> | string
    followingType?: EnumFollowTypeFilter<"UserFollow"> | $Enums.FollowType
    followingId?: StringFilter<"UserFollow"> | string
    createdAt?: DateTimeFilter<"UserFollow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    playlist?: XOR<PlaylistNullableScalarRelationFilter, PlaylistWhereInput> | null
  }, "id" | "followerId_followingType_followingId">

  export type UserFollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingType?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    _count?: UserFollowCountOrderByAggregateInput
    _max?: UserFollowMaxOrderByAggregateInput
    _min?: UserFollowMinOrderByAggregateInput
  }

  export type UserFollowScalarWhereWithAggregatesInput = {
    AND?: UserFollowScalarWhereWithAggregatesInput | UserFollowScalarWhereWithAggregatesInput[]
    OR?: UserFollowScalarWhereWithAggregatesInput[]
    NOT?: UserFollowScalarWhereWithAggregatesInput | UserFollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFollow"> | string
    followerId?: StringWithAggregatesFilter<"UserFollow"> | string
    followingType?: EnumFollowTypeWithAggregatesFilter<"UserFollow"> | $Enums.FollowType
    followingId?: StringWithAggregatesFilter<"UserFollow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserFollow"> | Date | string
  }

  export type UserLibraryWhereInput = {
    AND?: UserLibraryWhereInput | UserLibraryWhereInput[]
    OR?: UserLibraryWhereInput[]
    NOT?: UserLibraryWhereInput | UserLibraryWhereInput[]
    id?: StringFilter<"UserLibrary"> | string
    userId?: StringFilter<"UserLibrary"> | string
    itemType?: EnumLibraryItemTypeFilter<"UserLibrary"> | $Enums.LibraryItemType
    itemId?: StringFilter<"UserLibrary"> | string
    addedAt?: DateTimeFilter<"UserLibrary"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserLibraryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    addedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserLibraryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_itemType_itemId?: UserLibraryUserIdItemTypeItemIdCompoundUniqueInput
    AND?: UserLibraryWhereInput | UserLibraryWhereInput[]
    OR?: UserLibraryWhereInput[]
    NOT?: UserLibraryWhereInput | UserLibraryWhereInput[]
    userId?: StringFilter<"UserLibrary"> | string
    itemType?: EnumLibraryItemTypeFilter<"UserLibrary"> | $Enums.LibraryItemType
    itemId?: StringFilter<"UserLibrary"> | string
    addedAt?: DateTimeFilter<"UserLibrary"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_itemType_itemId">

  export type UserLibraryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    addedAt?: SortOrder
    _count?: UserLibraryCountOrderByAggregateInput
    _max?: UserLibraryMaxOrderByAggregateInput
    _min?: UserLibraryMinOrderByAggregateInput
  }

  export type UserLibraryScalarWhereWithAggregatesInput = {
    AND?: UserLibraryScalarWhereWithAggregatesInput | UserLibraryScalarWhereWithAggregatesInput[]
    OR?: UserLibraryScalarWhereWithAggregatesInput[]
    NOT?: UserLibraryScalarWhereWithAggregatesInput | UserLibraryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLibrary"> | string
    userId?: StringWithAggregatesFilter<"UserLibrary"> | string
    itemType?: EnumLibraryItemTypeWithAggregatesFilter<"UserLibrary"> | $Enums.LibraryItemType
    itemId?: StringWithAggregatesFilter<"UserLibrary"> | string
    addedAt?: DateTimeWithAggregatesFilter<"UserLibrary"> | Date | string
  }

  export type ListeningHistoryWhereInput = {
    AND?: ListeningHistoryWhereInput | ListeningHistoryWhereInput[]
    OR?: ListeningHistoryWhereInput[]
    NOT?: ListeningHistoryWhereInput | ListeningHistoryWhereInput[]
    id?: StringFilter<"ListeningHistory"> | string
    userId?: StringFilter<"ListeningHistory"> | string
    songId?: StringFilter<"ListeningHistory"> | string
    playedAt?: DateTimeFilter<"ListeningHistory"> | Date | string
    durationMs?: IntFilter<"ListeningHistory"> | number
    contextType?: EnumContextTypeNullableFilter<"ListeningHistory"> | $Enums.ContextType | null
    contextId?: StringNullableFilter<"ListeningHistory"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }

  export type ListeningHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    durationMs?: SortOrder
    contextType?: SortOrderInput | SortOrder
    contextId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    song?: SongOrderByWithRelationInput
  }

  export type ListeningHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListeningHistoryWhereInput | ListeningHistoryWhereInput[]
    OR?: ListeningHistoryWhereInput[]
    NOT?: ListeningHistoryWhereInput | ListeningHistoryWhereInput[]
    userId?: StringFilter<"ListeningHistory"> | string
    songId?: StringFilter<"ListeningHistory"> | string
    playedAt?: DateTimeFilter<"ListeningHistory"> | Date | string
    durationMs?: IntFilter<"ListeningHistory"> | number
    contextType?: EnumContextTypeNullableFilter<"ListeningHistory"> | $Enums.ContextType | null
    contextId?: StringNullableFilter<"ListeningHistory"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }, "id">

  export type ListeningHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    durationMs?: SortOrder
    contextType?: SortOrderInput | SortOrder
    contextId?: SortOrderInput | SortOrder
    _count?: ListeningHistoryCountOrderByAggregateInput
    _avg?: ListeningHistoryAvgOrderByAggregateInput
    _max?: ListeningHistoryMaxOrderByAggregateInput
    _min?: ListeningHistoryMinOrderByAggregateInput
    _sum?: ListeningHistorySumOrderByAggregateInput
  }

  export type ListeningHistoryScalarWhereWithAggregatesInput = {
    AND?: ListeningHistoryScalarWhereWithAggregatesInput | ListeningHistoryScalarWhereWithAggregatesInput[]
    OR?: ListeningHistoryScalarWhereWithAggregatesInput[]
    NOT?: ListeningHistoryScalarWhereWithAggregatesInput | ListeningHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ListeningHistory"> | string
    userId?: StringWithAggregatesFilter<"ListeningHistory"> | string
    songId?: StringWithAggregatesFilter<"ListeningHistory"> | string
    playedAt?: DateTimeWithAggregatesFilter<"ListeningHistory"> | Date | string
    durationMs?: IntWithAggregatesFilter<"ListeningHistory"> | number
    contextType?: EnumContextTypeNullableWithAggregatesFilter<"ListeningHistory"> | $Enums.ContextType | null
    contextId?: StringNullableWithAggregatesFilter<"ListeningHistory"> | string | null
  }

  export type RecentlyPlayedWhereInput = {
    AND?: RecentlyPlayedWhereInput | RecentlyPlayedWhereInput[]
    OR?: RecentlyPlayedWhereInput[]
    NOT?: RecentlyPlayedWhereInput | RecentlyPlayedWhereInput[]
    id?: StringFilter<"RecentlyPlayed"> | string
    userId?: StringFilter<"RecentlyPlayed"> | string
    songId?: StringFilter<"RecentlyPlayed"> | string
    playedAt?: DateTimeFilter<"RecentlyPlayed"> | Date | string
    contextType?: EnumContextTypeNullableFilter<"RecentlyPlayed"> | $Enums.ContextType | null
    contextId?: StringNullableFilter<"RecentlyPlayed"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }

  export type RecentlyPlayedOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    contextType?: SortOrderInput | SortOrder
    contextId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    song?: SongOrderByWithRelationInput
  }

  export type RecentlyPlayedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_songId?: RecentlyPlayedUserIdSongIdCompoundUniqueInput
    AND?: RecentlyPlayedWhereInput | RecentlyPlayedWhereInput[]
    OR?: RecentlyPlayedWhereInput[]
    NOT?: RecentlyPlayedWhereInput | RecentlyPlayedWhereInput[]
    userId?: StringFilter<"RecentlyPlayed"> | string
    songId?: StringFilter<"RecentlyPlayed"> | string
    playedAt?: DateTimeFilter<"RecentlyPlayed"> | Date | string
    contextType?: EnumContextTypeNullableFilter<"RecentlyPlayed"> | $Enums.ContextType | null
    contextId?: StringNullableFilter<"RecentlyPlayed"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }, "id" | "userId_songId">

  export type RecentlyPlayedOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    contextType?: SortOrderInput | SortOrder
    contextId?: SortOrderInput | SortOrder
    _count?: RecentlyPlayedCountOrderByAggregateInput
    _max?: RecentlyPlayedMaxOrderByAggregateInput
    _min?: RecentlyPlayedMinOrderByAggregateInput
  }

  export type RecentlyPlayedScalarWhereWithAggregatesInput = {
    AND?: RecentlyPlayedScalarWhereWithAggregatesInput | RecentlyPlayedScalarWhereWithAggregatesInput[]
    OR?: RecentlyPlayedScalarWhereWithAggregatesInput[]
    NOT?: RecentlyPlayedScalarWhereWithAggregatesInput | RecentlyPlayedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecentlyPlayed"> | string
    userId?: StringWithAggregatesFilter<"RecentlyPlayed"> | string
    songId?: StringWithAggregatesFilter<"RecentlyPlayed"> | string
    playedAt?: DateTimeWithAggregatesFilter<"RecentlyPlayed"> | Date | string
    contextType?: EnumContextTypeNullableWithAggregatesFilter<"RecentlyPlayed"> | $Enums.ContextType | null
    contextId?: StringNullableWithAggregatesFilter<"RecentlyPlayed"> | string | null
  }

  export type PlaybackQueueWhereInput = {
    AND?: PlaybackQueueWhereInput | PlaybackQueueWhereInput[]
    OR?: PlaybackQueueWhereInput[]
    NOT?: PlaybackQueueWhereInput | PlaybackQueueWhereInput[]
    id?: StringFilter<"PlaybackQueue"> | string
    userId?: StringFilter<"PlaybackQueue"> | string
    songId?: StringFilter<"PlaybackQueue"> | string
    position?: IntFilter<"PlaybackQueue"> | number
    addedAt?: DateTimeFilter<"PlaybackQueue"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }

  export type PlaybackQueueOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    song?: SongOrderByWithRelationInput
  }

  export type PlaybackQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_position?: PlaybackQueueUserIdPositionCompoundUniqueInput
    AND?: PlaybackQueueWhereInput | PlaybackQueueWhereInput[]
    OR?: PlaybackQueueWhereInput[]
    NOT?: PlaybackQueueWhereInput | PlaybackQueueWhereInput[]
    userId?: StringFilter<"PlaybackQueue"> | string
    songId?: StringFilter<"PlaybackQueue"> | string
    position?: IntFilter<"PlaybackQueue"> | number
    addedAt?: DateTimeFilter<"PlaybackQueue"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    song?: XOR<SongScalarRelationFilter, SongWhereInput>
  }, "id" | "userId_position">

  export type PlaybackQueueOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
    _count?: PlaybackQueueCountOrderByAggregateInput
    _avg?: PlaybackQueueAvgOrderByAggregateInput
    _max?: PlaybackQueueMaxOrderByAggregateInput
    _min?: PlaybackQueueMinOrderByAggregateInput
    _sum?: PlaybackQueueSumOrderByAggregateInput
  }

  export type PlaybackQueueScalarWhereWithAggregatesInput = {
    AND?: PlaybackQueueScalarWhereWithAggregatesInput | PlaybackQueueScalarWhereWithAggregatesInput[]
    OR?: PlaybackQueueScalarWhereWithAggregatesInput[]
    NOT?: PlaybackQueueScalarWhereWithAggregatesInput | PlaybackQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlaybackQueue"> | string
    userId?: StringWithAggregatesFilter<"PlaybackQueue"> | string
    songId?: StringWithAggregatesFilter<"PlaybackQueue"> | string
    position?: IntWithAggregatesFilter<"PlaybackQueue"> | number
    addedAt?: DateTimeWithAggregatesFilter<"PlaybackQueue"> | Date | string
  }

  export type PlaybackStateWhereInput = {
    AND?: PlaybackStateWhereInput | PlaybackStateWhereInput[]
    OR?: PlaybackStateWhereInput[]
    NOT?: PlaybackStateWhereInput | PlaybackStateWhereInput[]
    userId?: StringFilter<"PlaybackState"> | string
    currentSongId?: StringNullableFilter<"PlaybackState"> | string | null
    progressMs?: IntFilter<"PlaybackState"> | number
    isPlaying?: BoolFilter<"PlaybackState"> | boolean
    shuffleMode?: EnumShuffleModeFilter<"PlaybackState"> | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFilter<"PlaybackState"> | $Enums.RepeatMode
    volume?: IntFilter<"PlaybackState"> | number
    contextType?: EnumContextTypeNullableFilter<"PlaybackState"> | $Enums.ContextType | null
    contextId?: StringNullableFilter<"PlaybackState"> | string | null
    activeDeviceId?: StringNullableFilter<"PlaybackState"> | string | null
    updatedAt?: DateTimeFilter<"PlaybackState"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    currentSong?: XOR<SongNullableScalarRelationFilter, SongWhereInput> | null
    activeDevice?: XOR<UserDeviceNullableScalarRelationFilter, UserDeviceWhereInput> | null
  }

  export type PlaybackStateOrderByWithRelationInput = {
    userId?: SortOrder
    currentSongId?: SortOrderInput | SortOrder
    progressMs?: SortOrder
    isPlaying?: SortOrder
    shuffleMode?: SortOrder
    repeatMode?: SortOrder
    volume?: SortOrder
    contextType?: SortOrderInput | SortOrder
    contextId?: SortOrderInput | SortOrder
    activeDeviceId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    currentSong?: SongOrderByWithRelationInput
    activeDevice?: UserDeviceOrderByWithRelationInput
  }

  export type PlaybackStateWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: PlaybackStateWhereInput | PlaybackStateWhereInput[]
    OR?: PlaybackStateWhereInput[]
    NOT?: PlaybackStateWhereInput | PlaybackStateWhereInput[]
    currentSongId?: StringNullableFilter<"PlaybackState"> | string | null
    progressMs?: IntFilter<"PlaybackState"> | number
    isPlaying?: BoolFilter<"PlaybackState"> | boolean
    shuffleMode?: EnumShuffleModeFilter<"PlaybackState"> | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFilter<"PlaybackState"> | $Enums.RepeatMode
    volume?: IntFilter<"PlaybackState"> | number
    contextType?: EnumContextTypeNullableFilter<"PlaybackState"> | $Enums.ContextType | null
    contextId?: StringNullableFilter<"PlaybackState"> | string | null
    activeDeviceId?: StringNullableFilter<"PlaybackState"> | string | null
    updatedAt?: DateTimeFilter<"PlaybackState"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    currentSong?: XOR<SongNullableScalarRelationFilter, SongWhereInput> | null
    activeDevice?: XOR<UserDeviceNullableScalarRelationFilter, UserDeviceWhereInput> | null
  }, "userId">

  export type PlaybackStateOrderByWithAggregationInput = {
    userId?: SortOrder
    currentSongId?: SortOrderInput | SortOrder
    progressMs?: SortOrder
    isPlaying?: SortOrder
    shuffleMode?: SortOrder
    repeatMode?: SortOrder
    volume?: SortOrder
    contextType?: SortOrderInput | SortOrder
    contextId?: SortOrderInput | SortOrder
    activeDeviceId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: PlaybackStateCountOrderByAggregateInput
    _avg?: PlaybackStateAvgOrderByAggregateInput
    _max?: PlaybackStateMaxOrderByAggregateInput
    _min?: PlaybackStateMinOrderByAggregateInput
    _sum?: PlaybackStateSumOrderByAggregateInput
  }

  export type PlaybackStateScalarWhereWithAggregatesInput = {
    AND?: PlaybackStateScalarWhereWithAggregatesInput | PlaybackStateScalarWhereWithAggregatesInput[]
    OR?: PlaybackStateScalarWhereWithAggregatesInput[]
    NOT?: PlaybackStateScalarWhereWithAggregatesInput | PlaybackStateScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"PlaybackState"> | string
    currentSongId?: StringNullableWithAggregatesFilter<"PlaybackState"> | string | null
    progressMs?: IntWithAggregatesFilter<"PlaybackState"> | number
    isPlaying?: BoolWithAggregatesFilter<"PlaybackState"> | boolean
    shuffleMode?: EnumShuffleModeWithAggregatesFilter<"PlaybackState"> | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeWithAggregatesFilter<"PlaybackState"> | $Enums.RepeatMode
    volume?: IntWithAggregatesFilter<"PlaybackState"> | number
    contextType?: EnumContextTypeNullableWithAggregatesFilter<"PlaybackState"> | $Enums.ContextType | null
    contextId?: StringNullableWithAggregatesFilter<"PlaybackState"> | string | null
    activeDeviceId?: StringNullableWithAggregatesFilter<"PlaybackState"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"PlaybackState"> | Date | string
  }

  export type UserOAuthAccountWhereInput = {
    AND?: UserOAuthAccountWhereInput | UserOAuthAccountWhereInput[]
    OR?: UserOAuthAccountWhereInput[]
    NOT?: UserOAuthAccountWhereInput | UserOAuthAccountWhereInput[]
    id?: StringFilter<"UserOAuthAccount"> | string
    userId?: StringFilter<"UserOAuthAccount"> | string
    provider?: StringFilter<"UserOAuthAccount"> | string
    providerUserId?: StringFilter<"UserOAuthAccount"> | string
    email?: StringNullableFilter<"UserOAuthAccount"> | string | null
    name?: StringNullableFilter<"UserOAuthAccount"> | string | null
    avatarUrl?: StringNullableFilter<"UserOAuthAccount"> | string | null
    accessToken?: StringNullableFilter<"UserOAuthAccount"> | string | null
    refreshToken?: StringNullableFilter<"UserOAuthAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"UserOAuthAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"UserOAuthAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserOAuthAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserOAuthAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerUserId?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserOAuthAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerUserId?: UserOAuthAccountProviderProviderUserIdCompoundUniqueInput
    AND?: UserOAuthAccountWhereInput | UserOAuthAccountWhereInput[]
    OR?: UserOAuthAccountWhereInput[]
    NOT?: UserOAuthAccountWhereInput | UserOAuthAccountWhereInput[]
    userId?: StringFilter<"UserOAuthAccount"> | string
    provider?: StringFilter<"UserOAuthAccount"> | string
    providerUserId?: StringFilter<"UserOAuthAccount"> | string
    email?: StringNullableFilter<"UserOAuthAccount"> | string | null
    name?: StringNullableFilter<"UserOAuthAccount"> | string | null
    avatarUrl?: StringNullableFilter<"UserOAuthAccount"> | string | null
    accessToken?: StringNullableFilter<"UserOAuthAccount"> | string | null
    refreshToken?: StringNullableFilter<"UserOAuthAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"UserOAuthAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"UserOAuthAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserOAuthAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerUserId">

  export type UserOAuthAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerUserId?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserOAuthAccountCountOrderByAggregateInput
    _max?: UserOAuthAccountMaxOrderByAggregateInput
    _min?: UserOAuthAccountMinOrderByAggregateInput
  }

  export type UserOAuthAccountScalarWhereWithAggregatesInput = {
    AND?: UserOAuthAccountScalarWhereWithAggregatesInput | UserOAuthAccountScalarWhereWithAggregatesInput[]
    OR?: UserOAuthAccountScalarWhereWithAggregatesInput[]
    NOT?: UserOAuthAccountScalarWhereWithAggregatesInput | UserOAuthAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserOAuthAccount"> | string
    userId?: StringWithAggregatesFilter<"UserOAuthAccount"> | string
    provider?: StringWithAggregatesFilter<"UserOAuthAccount"> | string
    providerUserId?: StringWithAggregatesFilter<"UserOAuthAccount"> | string
    email?: StringNullableWithAggregatesFilter<"UserOAuthAccount"> | string | null
    name?: StringNullableWithAggregatesFilter<"UserOAuthAccount"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"UserOAuthAccount"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"UserOAuthAccount"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"UserOAuthAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"UserOAuthAccount"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserOAuthAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserOAuthAccount"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    deviceId?: StringNullableFilter<"UserSession"> | string | null
    tokenHash?: StringFilter<"UserSession"> | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    device?: XOR<UserDeviceNullableScalarRelationFilter, UserDeviceWhereInput> | null
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
    user?: UserOrderByWithRelationInput
    device?: UserDeviceOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    deviceId?: StringNullableFilter<"UserSession"> | string | null
    tokenHash?: StringFilter<"UserSession"> | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    device?: XOR<UserDeviceNullableScalarRelationFilter, UserDeviceWhereInput> | null
  }, "id">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    deviceId?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    tokenHash?: StringWithAggregatesFilter<"UserSession"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserSession"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    lastActivityAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type UserDeviceWhereInput = {
    AND?: UserDeviceWhereInput | UserDeviceWhereInput[]
    OR?: UserDeviceWhereInput[]
    NOT?: UserDeviceWhereInput | UserDeviceWhereInput[]
    id?: StringFilter<"UserDevice"> | string
    userId?: StringFilter<"UserDevice"> | string
    deviceType?: EnumDeviceTypeFilter<"UserDevice"> | $Enums.DeviceType
    deviceName?: StringNullableFilter<"UserDevice"> | string | null
    deviceToken?: StringNullableFilter<"UserDevice"> | string | null
    appVersion?: StringNullableFilter<"UserDevice"> | string | null
    osVersion?: StringNullableFilter<"UserDevice"> | string | null
    isActive?: BoolFilter<"UserDevice"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"UserDevice"> | Date | string | null
    createdAt?: DateTimeFilter<"UserDevice"> | Date | string
    updatedAt?: DateTimeFilter<"UserDevice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sessions?: UserSessionListRelationFilter
    playbackStates?: PlaybackStateListRelationFilter
    syncStates?: DeviceSyncStateListRelationFilter
    syncLogs?: SyncLogListRelationFilter
    transfersFrom?: DeviceTransferListRelationFilter
    transfersTo?: DeviceTransferListRelationFilter
    adImpressions?: AdImpressionListRelationFilter
  }

  export type UserDeviceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceToken?: SortOrderInput | SortOrder
    appVersion?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    sessions?: UserSessionOrderByRelationAggregateInput
    playbackStates?: PlaybackStateOrderByRelationAggregateInput
    syncStates?: DeviceSyncStateOrderByRelationAggregateInput
    syncLogs?: SyncLogOrderByRelationAggregateInput
    transfersFrom?: DeviceTransferOrderByRelationAggregateInput
    transfersTo?: DeviceTransferOrderByRelationAggregateInput
    adImpressions?: AdImpressionOrderByRelationAggregateInput
  }

  export type UserDeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserDeviceWhereInput | UserDeviceWhereInput[]
    OR?: UserDeviceWhereInput[]
    NOT?: UserDeviceWhereInput | UserDeviceWhereInput[]
    userId?: StringFilter<"UserDevice"> | string
    deviceType?: EnumDeviceTypeFilter<"UserDevice"> | $Enums.DeviceType
    deviceName?: StringNullableFilter<"UserDevice"> | string | null
    deviceToken?: StringNullableFilter<"UserDevice"> | string | null
    appVersion?: StringNullableFilter<"UserDevice"> | string | null
    osVersion?: StringNullableFilter<"UserDevice"> | string | null
    isActive?: BoolFilter<"UserDevice"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"UserDevice"> | Date | string | null
    createdAt?: DateTimeFilter<"UserDevice"> | Date | string
    updatedAt?: DateTimeFilter<"UserDevice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sessions?: UserSessionListRelationFilter
    playbackStates?: PlaybackStateListRelationFilter
    syncStates?: DeviceSyncStateListRelationFilter
    syncLogs?: SyncLogListRelationFilter
    transfersFrom?: DeviceTransferListRelationFilter
    transfersTo?: DeviceTransferListRelationFilter
    adImpressions?: AdImpressionListRelationFilter
  }, "id">

  export type UserDeviceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceToken?: SortOrderInput | SortOrder
    appVersion?: SortOrderInput | SortOrder
    osVersion?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserDeviceCountOrderByAggregateInput
    _max?: UserDeviceMaxOrderByAggregateInput
    _min?: UserDeviceMinOrderByAggregateInput
  }

  export type UserDeviceScalarWhereWithAggregatesInput = {
    AND?: UserDeviceScalarWhereWithAggregatesInput | UserDeviceScalarWhereWithAggregatesInput[]
    OR?: UserDeviceScalarWhereWithAggregatesInput[]
    NOT?: UserDeviceScalarWhereWithAggregatesInput | UserDeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserDevice"> | string
    userId?: StringWithAggregatesFilter<"UserDevice"> | string
    deviceType?: EnumDeviceTypeWithAggregatesFilter<"UserDevice"> | $Enums.DeviceType
    deviceName?: StringNullableWithAggregatesFilter<"UserDevice"> | string | null
    deviceToken?: StringNullableWithAggregatesFilter<"UserDevice"> | string | null
    appVersion?: StringNullableWithAggregatesFilter<"UserDevice"> | string | null
    osVersion?: StringNullableWithAggregatesFilter<"UserDevice"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserDevice"> | boolean
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"UserDevice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserDevice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserDevice"> | Date | string
  }

  export type DeviceSyncStateWhereInput = {
    AND?: DeviceSyncStateWhereInput | DeviceSyncStateWhereInput[]
    OR?: DeviceSyncStateWhereInput[]
    NOT?: DeviceSyncStateWhereInput | DeviceSyncStateWhereInput[]
    id?: StringFilter<"DeviceSyncState"> | string
    userId?: StringFilter<"DeviceSyncState"> | string
    deviceId?: StringFilter<"DeviceSyncState"> | string
    syncType?: EnumSyncTypeFilter<"DeviceSyncState"> | $Enums.SyncType
    lastSyncVersion?: BigIntFilter<"DeviceSyncState"> | bigint | number
    lastSyncAt?: DateTimeNullableFilter<"DeviceSyncState"> | Date | string | null
    pendingChanges?: IntFilter<"DeviceSyncState"> | number
    device?: XOR<UserDeviceScalarRelationFilter, UserDeviceWhereInput>
  }

  export type DeviceSyncStateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    syncType?: SortOrder
    lastSyncVersion?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    pendingChanges?: SortOrder
    device?: UserDeviceOrderByWithRelationInput
  }

  export type DeviceSyncStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_deviceId_syncType?: DeviceSyncStateUserIdDeviceIdSyncTypeCompoundUniqueInput
    AND?: DeviceSyncStateWhereInput | DeviceSyncStateWhereInput[]
    OR?: DeviceSyncStateWhereInput[]
    NOT?: DeviceSyncStateWhereInput | DeviceSyncStateWhereInput[]
    userId?: StringFilter<"DeviceSyncState"> | string
    deviceId?: StringFilter<"DeviceSyncState"> | string
    syncType?: EnumSyncTypeFilter<"DeviceSyncState"> | $Enums.SyncType
    lastSyncVersion?: BigIntFilter<"DeviceSyncState"> | bigint | number
    lastSyncAt?: DateTimeNullableFilter<"DeviceSyncState"> | Date | string | null
    pendingChanges?: IntFilter<"DeviceSyncState"> | number
    device?: XOR<UserDeviceScalarRelationFilter, UserDeviceWhereInput>
  }, "id" | "userId_deviceId_syncType">

  export type DeviceSyncStateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    syncType?: SortOrder
    lastSyncVersion?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    pendingChanges?: SortOrder
    _count?: DeviceSyncStateCountOrderByAggregateInput
    _avg?: DeviceSyncStateAvgOrderByAggregateInput
    _max?: DeviceSyncStateMaxOrderByAggregateInput
    _min?: DeviceSyncStateMinOrderByAggregateInput
    _sum?: DeviceSyncStateSumOrderByAggregateInput
  }

  export type DeviceSyncStateScalarWhereWithAggregatesInput = {
    AND?: DeviceSyncStateScalarWhereWithAggregatesInput | DeviceSyncStateScalarWhereWithAggregatesInput[]
    OR?: DeviceSyncStateScalarWhereWithAggregatesInput[]
    NOT?: DeviceSyncStateScalarWhereWithAggregatesInput | DeviceSyncStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceSyncState"> | string
    userId?: StringWithAggregatesFilter<"DeviceSyncState"> | string
    deviceId?: StringWithAggregatesFilter<"DeviceSyncState"> | string
    syncType?: EnumSyncTypeWithAggregatesFilter<"DeviceSyncState"> | $Enums.SyncType
    lastSyncVersion?: BigIntWithAggregatesFilter<"DeviceSyncState"> | bigint | number
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"DeviceSyncState"> | Date | string | null
    pendingChanges?: IntWithAggregatesFilter<"DeviceSyncState"> | number
  }

  export type SyncLogWhereInput = {
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    userId?: StringFilter<"SyncLog"> | string
    entityType?: StringFilter<"SyncLog"> | string
    entityId?: StringFilter<"SyncLog"> | string
    action?: EnumSyncActionFilter<"SyncLog"> | $Enums.SyncAction
    version?: BigIntFilter<"SyncLog"> | bigint | number
    payload?: JsonNullableFilter<"SyncLog">
    sourceDeviceId?: StringNullableFilter<"SyncLog"> | string | null
    createdAt?: DateTimeFilter<"SyncLog"> | Date | string
    sourceDevice?: XOR<UserDeviceNullableScalarRelationFilter, UserDeviceWhereInput> | null
  }

  export type SyncLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    version?: SortOrder
    payload?: SortOrderInput | SortOrder
    sourceDeviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sourceDevice?: UserDeviceOrderByWithRelationInput
  }

  export type SyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    userId?: StringFilter<"SyncLog"> | string
    entityType?: StringFilter<"SyncLog"> | string
    entityId?: StringFilter<"SyncLog"> | string
    action?: EnumSyncActionFilter<"SyncLog"> | $Enums.SyncAction
    version?: BigIntFilter<"SyncLog"> | bigint | number
    payload?: JsonNullableFilter<"SyncLog">
    sourceDeviceId?: StringNullableFilter<"SyncLog"> | string | null
    createdAt?: DateTimeFilter<"SyncLog"> | Date | string
    sourceDevice?: XOR<UserDeviceNullableScalarRelationFilter, UserDeviceWhereInput> | null
  }, "id">

  export type SyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    version?: SortOrder
    payload?: SortOrderInput | SortOrder
    sourceDeviceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SyncLogCountOrderByAggregateInput
    _avg?: SyncLogAvgOrderByAggregateInput
    _max?: SyncLogMaxOrderByAggregateInput
    _min?: SyncLogMinOrderByAggregateInput
    _sum?: SyncLogSumOrderByAggregateInput
  }

  export type SyncLogScalarWhereWithAggregatesInput = {
    AND?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    OR?: SyncLogScalarWhereWithAggregatesInput[]
    NOT?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncLog"> | string
    userId?: StringWithAggregatesFilter<"SyncLog"> | string
    entityType?: StringWithAggregatesFilter<"SyncLog"> | string
    entityId?: StringWithAggregatesFilter<"SyncLog"> | string
    action?: EnumSyncActionWithAggregatesFilter<"SyncLog"> | $Enums.SyncAction
    version?: BigIntWithAggregatesFilter<"SyncLog"> | bigint | number
    payload?: JsonNullableWithAggregatesFilter<"SyncLog">
    sourceDeviceId?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SyncLog"> | Date | string
  }

  export type DeviceTransferWhereInput = {
    AND?: DeviceTransferWhereInput | DeviceTransferWhereInput[]
    OR?: DeviceTransferWhereInput[]
    NOT?: DeviceTransferWhereInput | DeviceTransferWhereInput[]
    id?: StringFilter<"DeviceTransfer"> | string
    userId?: StringFilter<"DeviceTransfer"> | string
    fromDeviceId?: StringFilter<"DeviceTransfer"> | string
    toDeviceId?: StringFilter<"DeviceTransfer"> | string
    status?: EnumTransferStatusFilter<"DeviceTransfer"> | $Enums.TransferStatus
    transferData?: JsonNullableFilter<"DeviceTransfer">
    createdAt?: DateTimeFilter<"DeviceTransfer"> | Date | string
    expiresAt?: DateTimeFilter<"DeviceTransfer"> | Date | string
    fromDevice?: XOR<UserDeviceScalarRelationFilter, UserDeviceWhereInput>
    toDevice?: XOR<UserDeviceScalarRelationFilter, UserDeviceWhereInput>
  }

  export type DeviceTransferOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fromDeviceId?: SortOrder
    toDeviceId?: SortOrder
    status?: SortOrder
    transferData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    fromDevice?: UserDeviceOrderByWithRelationInput
    toDevice?: UserDeviceOrderByWithRelationInput
  }

  export type DeviceTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeviceTransferWhereInput | DeviceTransferWhereInput[]
    OR?: DeviceTransferWhereInput[]
    NOT?: DeviceTransferWhereInput | DeviceTransferWhereInput[]
    userId?: StringFilter<"DeviceTransfer"> | string
    fromDeviceId?: StringFilter<"DeviceTransfer"> | string
    toDeviceId?: StringFilter<"DeviceTransfer"> | string
    status?: EnumTransferStatusFilter<"DeviceTransfer"> | $Enums.TransferStatus
    transferData?: JsonNullableFilter<"DeviceTransfer">
    createdAt?: DateTimeFilter<"DeviceTransfer"> | Date | string
    expiresAt?: DateTimeFilter<"DeviceTransfer"> | Date | string
    fromDevice?: XOR<UserDeviceScalarRelationFilter, UserDeviceWhereInput>
    toDevice?: XOR<UserDeviceScalarRelationFilter, UserDeviceWhereInput>
  }, "id">

  export type DeviceTransferOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fromDeviceId?: SortOrder
    toDeviceId?: SortOrder
    status?: SortOrder
    transferData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: DeviceTransferCountOrderByAggregateInput
    _max?: DeviceTransferMaxOrderByAggregateInput
    _min?: DeviceTransferMinOrderByAggregateInput
  }

  export type DeviceTransferScalarWhereWithAggregatesInput = {
    AND?: DeviceTransferScalarWhereWithAggregatesInput | DeviceTransferScalarWhereWithAggregatesInput[]
    OR?: DeviceTransferScalarWhereWithAggregatesInput[]
    NOT?: DeviceTransferScalarWhereWithAggregatesInput | DeviceTransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceTransfer"> | string
    userId?: StringWithAggregatesFilter<"DeviceTransfer"> | string
    fromDeviceId?: StringWithAggregatesFilter<"DeviceTransfer"> | string
    toDeviceId?: StringWithAggregatesFilter<"DeviceTransfer"> | string
    status?: EnumTransferStatusWithAggregatesFilter<"DeviceTransfer"> | $Enums.TransferStatus
    transferData?: JsonNullableWithAggregatesFilter<"DeviceTransfer">
    createdAt?: DateTimeWithAggregatesFilter<"DeviceTransfer"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"DeviceTransfer"> | Date | string
  }

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    id?: StringFilter<"SubscriptionPlan"> | string
    name?: StringFilter<"SubscriptionPlan"> | string
    slug?: StringFilter<"SubscriptionPlan"> | string
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    priceMonthly?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    maxDevices?: IntFilter<"SubscriptionPlan"> | number
    hasAds?: BoolFilter<"SubscriptionPlan"> | boolean
    canDownload?: BoolFilter<"SubscriptionPlan"> | boolean
    audioQuality?: EnumAudioQualityFilter<"SubscriptionPlan"> | $Enums.AudioQuality
    smartShuffle?: BoolFilter<"SubscriptionPlan"> | boolean
    skipLimit?: IntNullableFilter<"SubscriptionPlan"> | number | null
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: UserSubscriptionListRelationFilter
  }

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    maxDevices?: SortOrder
    hasAds?: SortOrder
    canDownload?: SortOrder
    audioQuality?: SortOrder
    smartShuffle?: SortOrder
    skipLimit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    subscriptions?: UserSubscriptionOrderByRelationAggregateInput
  }

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    OR?: SubscriptionPlanWhereInput[]
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[]
    description?: StringNullableFilter<"SubscriptionPlan"> | string | null
    priceMonthly?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SubscriptionPlan"> | string
    maxDevices?: IntFilter<"SubscriptionPlan"> | number
    hasAds?: BoolFilter<"SubscriptionPlan"> | boolean
    canDownload?: BoolFilter<"SubscriptionPlan"> | boolean
    audioQuality?: EnumAudioQualityFilter<"SubscriptionPlan"> | $Enums.AudioQuality
    smartShuffle?: BoolFilter<"SubscriptionPlan"> | boolean
    skipLimit?: IntNullableFilter<"SubscriptionPlan"> | number | null
    isActive?: BoolFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionPlan"> | Date | string
    subscriptions?: UserSubscriptionListRelationFilter
  }, "id" | "name" | "slug">

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    maxDevices?: SortOrder
    hasAds?: SortOrder
    canDownload?: SortOrder
    audioQuality?: SortOrder
    smartShuffle?: SortOrder
    skipLimit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: SubscriptionPlanCountOrderByAggregateInput
    _avg?: SubscriptionPlanAvgOrderByAggregateInput
    _max?: SubscriptionPlanMaxOrderByAggregateInput
    _min?: SubscriptionPlanMinOrderByAggregateInput
    _sum?: SubscriptionPlanSumOrderByAggregateInput
  }

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPlanScalarWhereWithAggregatesInput | SubscriptionPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    slug?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPlan"> | string | null
    priceMonthly?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalWithAggregatesFilter<"SubscriptionPlan"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SubscriptionPlan"> | string
    maxDevices?: IntWithAggregatesFilter<"SubscriptionPlan"> | number
    hasAds?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    canDownload?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    audioQuality?: EnumAudioQualityWithAggregatesFilter<"SubscriptionPlan"> | $Enums.AudioQuality
    smartShuffle?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    skipLimit?: IntNullableWithAggregatesFilter<"SubscriptionPlan"> | number | null
    isActive?: BoolWithAggregatesFilter<"SubscriptionPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPlan"> | Date | string
  }

  export type UserSubscriptionWhereInput = {
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    id?: StringFilter<"UserSubscription"> | string
    userId?: StringFilter<"UserSubscription"> | string
    planId?: StringFilter<"UserSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFilter<"UserSubscription"> | $Enums.BillingCycle
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    paymentMethod?: StringNullableFilter<"UserSubscription"> | string | null
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
  }

  export type UserSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    plan?: SubscriptionPlanOrderByWithRelationInput
  }

  export type UserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    userId?: StringFilter<"UserSubscription"> | string
    planId?: StringFilter<"UserSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFilter<"UserSubscription"> | $Enums.BillingCycle
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    paymentMethod?: StringNullableFilter<"UserSubscription"> | string | null
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<SubscriptionPlanScalarRelationFilter, SubscriptionPlanWhereInput>
  }, "id">

  export type UserSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSubscriptionCountOrderByAggregateInput
    _max?: UserSubscriptionMaxOrderByAggregateInput
    _min?: UserSubscriptionMinOrderByAggregateInput
  }

  export type UserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: UserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSubscription"> | string
    userId?: StringWithAggregatesFilter<"UserSubscription"> | string
    planId?: StringWithAggregatesFilter<"UserSubscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleWithAggregatesFilter<"UserSubscription"> | $Enums.BillingCycle
    startDate?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
  }

  export type AdvertisementWhereInput = {
    AND?: AdvertisementWhereInput | AdvertisementWhereInput[]
    OR?: AdvertisementWhereInput[]
    NOT?: AdvertisementWhereInput | AdvertisementWhereInput[]
    id?: StringFilter<"Advertisement"> | string
    name?: StringFilter<"Advertisement"> | string
    advertiser?: StringFilter<"Advertisement"> | string
    adType?: EnumAdTypeFilter<"Advertisement"> | $Enums.AdType
    mediaUrl?: StringFilter<"Advertisement"> | string
    clickUrl?: StringNullableFilter<"Advertisement"> | string | null
    durationMs?: IntNullableFilter<"Advertisement"> | number | null
    targetCountries?: StringNullableListFilter<"Advertisement">
    targetAgeMin?: IntNullableFilter<"Advertisement"> | number | null
    targetAgeMax?: IntNullableFilter<"Advertisement"> | number | null
    targetGenres?: StringNullableListFilter<"Advertisement">
    priority?: IntFilter<"Advertisement"> | number
    budget?: DecimalNullableFilter<"Advertisement"> | Decimal | DecimalJsLike | number | string | null
    costPerImpression?: DecimalNullableFilter<"Advertisement"> | Decimal | DecimalJsLike | number | string | null
    costPerClick?: DecimalNullableFilter<"Advertisement"> | Decimal | DecimalJsLike | number | string | null
    totalImpressions?: BigIntFilter<"Advertisement"> | bigint | number
    totalClicks?: BigIntFilter<"Advertisement"> | bigint | number
    startDate?: DateTimeNullableFilter<"Advertisement"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Advertisement"> | Date | string | null
    isActive?: BoolFilter<"Advertisement"> | boolean
    createdAt?: DateTimeFilter<"Advertisement"> | Date | string
    updatedAt?: DateTimeFilter<"Advertisement"> | Date | string
    impressions?: AdImpressionListRelationFilter
  }

  export type AdvertisementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    advertiser?: SortOrder
    adType?: SortOrder
    mediaUrl?: SortOrder
    clickUrl?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    targetCountries?: SortOrder
    targetAgeMin?: SortOrderInput | SortOrder
    targetAgeMax?: SortOrderInput | SortOrder
    targetGenres?: SortOrder
    priority?: SortOrder
    budget?: SortOrderInput | SortOrder
    costPerImpression?: SortOrderInput | SortOrder
    costPerClick?: SortOrderInput | SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    impressions?: AdImpressionOrderByRelationAggregateInput
  }

  export type AdvertisementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdvertisementWhereInput | AdvertisementWhereInput[]
    OR?: AdvertisementWhereInput[]
    NOT?: AdvertisementWhereInput | AdvertisementWhereInput[]
    name?: StringFilter<"Advertisement"> | string
    advertiser?: StringFilter<"Advertisement"> | string
    adType?: EnumAdTypeFilter<"Advertisement"> | $Enums.AdType
    mediaUrl?: StringFilter<"Advertisement"> | string
    clickUrl?: StringNullableFilter<"Advertisement"> | string | null
    durationMs?: IntNullableFilter<"Advertisement"> | number | null
    targetCountries?: StringNullableListFilter<"Advertisement">
    targetAgeMin?: IntNullableFilter<"Advertisement"> | number | null
    targetAgeMax?: IntNullableFilter<"Advertisement"> | number | null
    targetGenres?: StringNullableListFilter<"Advertisement">
    priority?: IntFilter<"Advertisement"> | number
    budget?: DecimalNullableFilter<"Advertisement"> | Decimal | DecimalJsLike | number | string | null
    costPerImpression?: DecimalNullableFilter<"Advertisement"> | Decimal | DecimalJsLike | number | string | null
    costPerClick?: DecimalNullableFilter<"Advertisement"> | Decimal | DecimalJsLike | number | string | null
    totalImpressions?: BigIntFilter<"Advertisement"> | bigint | number
    totalClicks?: BigIntFilter<"Advertisement"> | bigint | number
    startDate?: DateTimeNullableFilter<"Advertisement"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Advertisement"> | Date | string | null
    isActive?: BoolFilter<"Advertisement"> | boolean
    createdAt?: DateTimeFilter<"Advertisement"> | Date | string
    updatedAt?: DateTimeFilter<"Advertisement"> | Date | string
    impressions?: AdImpressionListRelationFilter
  }, "id">

  export type AdvertisementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    advertiser?: SortOrder
    adType?: SortOrder
    mediaUrl?: SortOrder
    clickUrl?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    targetCountries?: SortOrder
    targetAgeMin?: SortOrderInput | SortOrder
    targetAgeMax?: SortOrderInput | SortOrder
    targetGenres?: SortOrder
    priority?: SortOrder
    budget?: SortOrderInput | SortOrder
    costPerImpression?: SortOrderInput | SortOrder
    costPerClick?: SortOrderInput | SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdvertisementCountOrderByAggregateInput
    _avg?: AdvertisementAvgOrderByAggregateInput
    _max?: AdvertisementMaxOrderByAggregateInput
    _min?: AdvertisementMinOrderByAggregateInput
    _sum?: AdvertisementSumOrderByAggregateInput
  }

  export type AdvertisementScalarWhereWithAggregatesInput = {
    AND?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    OR?: AdvertisementScalarWhereWithAggregatesInput[]
    NOT?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Advertisement"> | string
    name?: StringWithAggregatesFilter<"Advertisement"> | string
    advertiser?: StringWithAggregatesFilter<"Advertisement"> | string
    adType?: EnumAdTypeWithAggregatesFilter<"Advertisement"> | $Enums.AdType
    mediaUrl?: StringWithAggregatesFilter<"Advertisement"> | string
    clickUrl?: StringNullableWithAggregatesFilter<"Advertisement"> | string | null
    durationMs?: IntNullableWithAggregatesFilter<"Advertisement"> | number | null
    targetCountries?: StringNullableListFilter<"Advertisement">
    targetAgeMin?: IntNullableWithAggregatesFilter<"Advertisement"> | number | null
    targetAgeMax?: IntNullableWithAggregatesFilter<"Advertisement"> | number | null
    targetGenres?: StringNullableListFilter<"Advertisement">
    priority?: IntWithAggregatesFilter<"Advertisement"> | number
    budget?: DecimalNullableWithAggregatesFilter<"Advertisement"> | Decimal | DecimalJsLike | number | string | null
    costPerImpression?: DecimalNullableWithAggregatesFilter<"Advertisement"> | Decimal | DecimalJsLike | number | string | null
    costPerClick?: DecimalNullableWithAggregatesFilter<"Advertisement"> | Decimal | DecimalJsLike | number | string | null
    totalImpressions?: BigIntWithAggregatesFilter<"Advertisement"> | bigint | number
    totalClicks?: BigIntWithAggregatesFilter<"Advertisement"> | bigint | number
    startDate?: DateTimeNullableWithAggregatesFilter<"Advertisement"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Advertisement"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Advertisement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Advertisement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Advertisement"> | Date | string
  }

  export type AdImpressionWhereInput = {
    AND?: AdImpressionWhereInput | AdImpressionWhereInput[]
    OR?: AdImpressionWhereInput[]
    NOT?: AdImpressionWhereInput | AdImpressionWhereInput[]
    id?: StringFilter<"AdImpression"> | string
    userId?: StringFilter<"AdImpression"> | string
    adId?: StringFilter<"AdImpression"> | string
    deviceId?: StringNullableFilter<"AdImpression"> | string | null
    impressionType?: EnumImpressionTypeFilter<"AdImpression"> | $Enums.ImpressionType
    contextType?: EnumAdContextTypeNullableFilter<"AdImpression"> | $Enums.AdContextType | null
    revenue?: DecimalFilter<"AdImpression"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"AdImpression"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ad?: XOR<AdvertisementScalarRelationFilter, AdvertisementWhereInput>
    device?: XOR<UserDeviceNullableScalarRelationFilter, UserDeviceWhereInput> | null
  }

  export type AdImpressionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    impressionType?: SortOrder
    contextType?: SortOrderInput | SortOrder
    revenue?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    ad?: AdvertisementOrderByWithRelationInput
    device?: UserDeviceOrderByWithRelationInput
  }

  export type AdImpressionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdImpressionWhereInput | AdImpressionWhereInput[]
    OR?: AdImpressionWhereInput[]
    NOT?: AdImpressionWhereInput | AdImpressionWhereInput[]
    userId?: StringFilter<"AdImpression"> | string
    adId?: StringFilter<"AdImpression"> | string
    deviceId?: StringNullableFilter<"AdImpression"> | string | null
    impressionType?: EnumImpressionTypeFilter<"AdImpression"> | $Enums.ImpressionType
    contextType?: EnumAdContextTypeNullableFilter<"AdImpression"> | $Enums.AdContextType | null
    revenue?: DecimalFilter<"AdImpression"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"AdImpression"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ad?: XOR<AdvertisementScalarRelationFilter, AdvertisementWhereInput>
    device?: XOR<UserDeviceNullableScalarRelationFilter, UserDeviceWhereInput> | null
  }, "id">

  export type AdImpressionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    impressionType?: SortOrder
    contextType?: SortOrderInput | SortOrder
    revenue?: SortOrder
    createdAt?: SortOrder
    _count?: AdImpressionCountOrderByAggregateInput
    _avg?: AdImpressionAvgOrderByAggregateInput
    _max?: AdImpressionMaxOrderByAggregateInput
    _min?: AdImpressionMinOrderByAggregateInput
    _sum?: AdImpressionSumOrderByAggregateInput
  }

  export type AdImpressionScalarWhereWithAggregatesInput = {
    AND?: AdImpressionScalarWhereWithAggregatesInput | AdImpressionScalarWhereWithAggregatesInput[]
    OR?: AdImpressionScalarWhereWithAggregatesInput[]
    NOT?: AdImpressionScalarWhereWithAggregatesInput | AdImpressionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdImpression"> | string
    userId?: StringWithAggregatesFilter<"AdImpression"> | string
    adId?: StringWithAggregatesFilter<"AdImpression"> | string
    deviceId?: StringNullableWithAggregatesFilter<"AdImpression"> | string | null
    impressionType?: EnumImpressionTypeWithAggregatesFilter<"AdImpression"> | $Enums.ImpressionType
    contextType?: EnumAdContextTypeNullableWithAggregatesFilter<"AdImpression"> | $Enums.AdContextType | null
    revenue?: DecimalWithAggregatesFilter<"AdImpression"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"AdImpression"> | Date | string
  }

  export type UserAdSettingsWhereInput = {
    AND?: UserAdSettingsWhereInput | UserAdSettingsWhereInput[]
    OR?: UserAdSettingsWhereInput[]
    NOT?: UserAdSettingsWhereInput | UserAdSettingsWhereInput[]
    userId?: StringFilter<"UserAdSettings"> | string
    lastAdShownAt?: DateTimeNullableFilter<"UserAdSettings"> | Date | string | null
    songsSinceLastAd?: IntFilter<"UserAdSettings"> | number
    adsPerHour?: IntFilter<"UserAdSettings"> | number
    skipCountToday?: IntFilter<"UserAdSettings"> | number
    skipResetAt?: DateTimeNullableFilter<"UserAdSettings"> | Date | string | null
    updatedAt?: DateTimeFilter<"UserAdSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAdSettingsOrderByWithRelationInput = {
    userId?: SortOrder
    lastAdShownAt?: SortOrderInput | SortOrder
    songsSinceLastAd?: SortOrder
    adsPerHour?: SortOrder
    skipCountToday?: SortOrder
    skipResetAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAdSettingsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserAdSettingsWhereInput | UserAdSettingsWhereInput[]
    OR?: UserAdSettingsWhereInput[]
    NOT?: UserAdSettingsWhereInput | UserAdSettingsWhereInput[]
    lastAdShownAt?: DateTimeNullableFilter<"UserAdSettings"> | Date | string | null
    songsSinceLastAd?: IntFilter<"UserAdSettings"> | number
    adsPerHour?: IntFilter<"UserAdSettings"> | number
    skipCountToday?: IntFilter<"UserAdSettings"> | number
    skipResetAt?: DateTimeNullableFilter<"UserAdSettings"> | Date | string | null
    updatedAt?: DateTimeFilter<"UserAdSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type UserAdSettingsOrderByWithAggregationInput = {
    userId?: SortOrder
    lastAdShownAt?: SortOrderInput | SortOrder
    songsSinceLastAd?: SortOrder
    adsPerHour?: SortOrder
    skipCountToday?: SortOrder
    skipResetAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: UserAdSettingsCountOrderByAggregateInput
    _avg?: UserAdSettingsAvgOrderByAggregateInput
    _max?: UserAdSettingsMaxOrderByAggregateInput
    _min?: UserAdSettingsMinOrderByAggregateInput
    _sum?: UserAdSettingsSumOrderByAggregateInput
  }

  export type UserAdSettingsScalarWhereWithAggregatesInput = {
    AND?: UserAdSettingsScalarWhereWithAggregatesInput | UserAdSettingsScalarWhereWithAggregatesInput[]
    OR?: UserAdSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserAdSettingsScalarWhereWithAggregatesInput | UserAdSettingsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserAdSettings"> | string
    lastAdShownAt?: DateTimeNullableWithAggregatesFilter<"UserAdSettings"> | Date | string | null
    songsSinceLastAd?: IntWithAggregatesFilter<"UserAdSettings"> | number
    adsPerHour?: IntWithAggregatesFilter<"UserAdSettings"> | number
    skipCountToday?: IntWithAggregatesFilter<"UserAdSettings"> | number
    skipResetAt?: DateTimeNullableWithAggregatesFilter<"UserAdSettings"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"UserAdSettings"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistCreateInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutArtistInput
    albums?: AlbumCreateNestedManyWithoutArtistInput
    songs?: SongCreateNestedManyWithoutPrimaryArtistInput
    songArtists?: SongArtistCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateInput = {
    id?: string
    userId?: string | null
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    songs?: SongUncheckedCreateNestedManyWithoutPrimaryArtistInput
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutArtistNestedInput
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    songs?: SongUpdateManyWithoutPrimaryArtistNestedInput
    songArtists?: SongArtistUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    songs?: SongUncheckedUpdateManyWithoutPrimaryArtistNestedInput
    songArtists?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type ArtistCreateManyInput = {
    id?: string
    userId?: string | null
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArtistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    coverUrl?: string | null
    releaseDate?: Date | string | null
    albumType?: $Enums.AlbumType
    totalTracks?: number
    durationMs?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist: ArtistCreateNestedOneWithoutAlbumsInput
    songs?: SongCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateInput = {
    id?: string
    artistId: string
    title: string
    slug: string
    description?: string | null
    coverUrl?: string | null
    releaseDate?: Date | string | null
    albumType?: $Enums.AlbumType
    totalTracks?: number
    durationMs?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: SongUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneRequiredWithoutAlbumsNestedInput
    songs?: SongUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumCreateManyInput = {
    id?: string
    artistId: string
    title: string
    slug: string
    description?: string | null
    coverUrl?: string | null
    releaseDate?: Date | string | null
    albumType?: $Enums.AlbumType
    totalTracks?: number
    durationMs?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlbumUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongCreateInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    album?: AlbumCreateNestedOneWithoutSongsInput
    primaryArtist: ArtistCreateNestedOneWithoutSongsInput
    songArtists?: SongArtistCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateInput = {
    id?: string
    albumId?: string | null
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongUncheckedCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneWithoutSongsNestedInput
    primaryArtist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
    songArtists?: SongArtistUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songArtists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUncheckedUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput
  }

  export type SongCreateManyInput = {
    id?: string
    albumId?: string | null
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SongUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    color?: string | null
    createdAt?: Date | string
    songs?: SongGenreCreateNestedManyWithoutGenreInput
    artists?: ArtistGenreCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    color?: string | null
    createdAt?: Date | string
    songs?: SongGenreUncheckedCreateNestedManyWithoutGenreInput
    artists?: ArtistGenreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongGenreUpdateManyWithoutGenreNestedInput
    artists?: ArtistGenreUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongGenreUncheckedUpdateManyWithoutGenreNestedInput
    artists?: ArtistGenreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type GenreCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    color?: string | null
    createdAt?: Date | string
  }

  export type GenreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongGenreCreateInput = {
    song: SongCreateNestedOneWithoutGenresInput
    genre: GenreCreateNestedOneWithoutSongsInput
  }

  export type SongGenreUncheckedCreateInput = {
    songId: string
    genreId: string
  }

  export type SongGenreUpdateInput = {
    song?: SongUpdateOneRequiredWithoutGenresNestedInput
    genre?: GenreUpdateOneRequiredWithoutSongsNestedInput
  }

  export type SongGenreUncheckedUpdateInput = {
    songId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type SongGenreCreateManyInput = {
    songId: string
    genreId: string
  }

  export type SongGenreUpdateManyMutationInput = {

  }

  export type SongGenreUncheckedUpdateManyInput = {
    songId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreCreateInput = {
    artist: ArtistCreateNestedOneWithoutGenresInput
    genre: GenreCreateNestedOneWithoutArtistsInput
  }

  export type ArtistGenreUncheckedCreateInput = {
    artistId: string
    genreId: string
  }

  export type ArtistGenreUpdateInput = {
    artist?: ArtistUpdateOneRequiredWithoutGenresNestedInput
    genre?: GenreUpdateOneRequiredWithoutArtistsNestedInput
  }

  export type ArtistGenreUncheckedUpdateInput = {
    artistId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreCreateManyInput = {
    artistId: string
    genreId: string
  }

  export type ArtistGenreUpdateManyMutationInput = {

  }

  export type ArtistGenreUncheckedUpdateManyInput = {
    artistId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type SongArtistCreateInput = {
    role?: $Enums.ArtistRole
    song: SongCreateNestedOneWithoutSongArtistsInput
    artist: ArtistCreateNestedOneWithoutSongArtistsInput
  }

  export type SongArtistUncheckedCreateInput = {
    songId: string
    artistId: string
    role?: $Enums.ArtistRole
  }

  export type SongArtistUpdateInput = {
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    song?: SongUpdateOneRequiredWithoutSongArtistsNestedInput
    artist?: ArtistUpdateOneRequiredWithoutSongArtistsNestedInput
  }

  export type SongArtistUncheckedUpdateInput = {
    songId?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
  }

  export type SongArtistCreateManyInput = {
    songId: string
    artistId: string
    role?: $Enums.ArtistRole
  }

  export type SongArtistUpdateManyMutationInput = {
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
  }

  export type SongArtistUncheckedUpdateManyInput = {
    songId?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
  }

  export type PlaylistCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaylistsInput
    songs?: PlaylistSongCreateNestedManyWithoutPlaylistInput
    followers?: UserFollowCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: PlaylistSongUncheckedCreateNestedManyWithoutPlaylistInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaylistsNestedInput
    songs?: PlaylistSongUpdateManyWithoutPlaylistNestedInput
    followers?: UserFollowUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: PlaylistSongUncheckedUpdateManyWithoutPlaylistNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistCreateManyInput = {
    id?: string
    userId: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlaylistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistSongCreateInput = {
    id?: string
    position: number
    addedBy?: string | null
    addedAt?: Date | string
    playlist: PlaylistCreateNestedOneWithoutSongsInput
    song: SongCreateNestedOneWithoutPlaylistSongsInput
  }

  export type PlaylistSongUncheckedCreateInput = {
    id?: string
    playlistId: string
    songId: string
    position: number
    addedBy?: string | null
    addedAt?: Date | string
  }

  export type PlaylistSongUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlist?: PlaylistUpdateOneRequiredWithoutSongsNestedInput
    song?: SongUpdateOneRequiredWithoutPlaylistSongsNestedInput
  }

  export type PlaylistSongUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistSongCreateManyInput = {
    id?: string
    playlistId: string
    songId: string
    position: number
    addedBy?: string | null
    addedAt?: Date | string
  }

  export type PlaylistSongUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistSongUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowCreateInput = {
    id?: string
    followingType: $Enums.FollowType
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowsInput
    playlist?: PlaylistCreateNestedOneWithoutFollowersInput
  }

  export type UserFollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingType: $Enums.FollowType
    followingId: string
    createdAt?: Date | string
  }

  export type UserFollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowsNestedInput
    playlist?: PlaylistUpdateOneWithoutFollowersNestedInput
  }

  export type UserFollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowCreateManyInput = {
    id?: string
    followerId: string
    followingType: $Enums.FollowType
    followingId: string
    createdAt?: Date | string
  }

  export type UserFollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryCreateInput = {
    id?: string
    itemType: $Enums.LibraryItemType
    itemId: string
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutLibraryInput
  }

  export type UserLibraryUncheckedCreateInput = {
    id?: string
    userId: string
    itemType: $Enums.LibraryItemType
    itemId: string
    addedAt?: Date | string
  }

  export type UserLibraryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLibraryNestedInput
  }

  export type UserLibraryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryCreateManyInput = {
    id?: string
    userId: string
    itemType: $Enums.LibraryItemType
    itemId: string
    addedAt?: Date | string
  }

  export type UserLibraryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningHistoryCreateInput = {
    id?: string
    playedAt?: Date | string
    durationMs: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    user: UserCreateNestedOneWithoutListeningHistoryInput
    song: SongCreateNestedOneWithoutListeningHistoryInput
  }

  export type ListeningHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    songId: string
    playedAt?: Date | string
    durationMs: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type ListeningHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutListeningHistoryNestedInput
    song?: SongUpdateOneRequiredWithoutListeningHistoryNestedInput
  }

  export type ListeningHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListeningHistoryCreateManyInput = {
    id?: string
    userId: string
    songId: string
    playedAt?: Date | string
    durationMs: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type ListeningHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListeningHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecentlyPlayedCreateInput = {
    id?: string
    playedAt?: Date | string
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    user: UserCreateNestedOneWithoutRecentlyPlayedInput
    song: SongCreateNestedOneWithoutRecentlyPlayedInput
  }

  export type RecentlyPlayedUncheckedCreateInput = {
    id?: string
    userId: string
    songId: string
    playedAt?: Date | string
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type RecentlyPlayedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutRecentlyPlayedNestedInput
    song?: SongUpdateOneRequiredWithoutRecentlyPlayedNestedInput
  }

  export type RecentlyPlayedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecentlyPlayedCreateManyInput = {
    id?: string
    userId: string
    songId: string
    playedAt?: Date | string
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type RecentlyPlayedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecentlyPlayedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaybackQueueCreateInput = {
    id?: string
    position: number
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaybackQueueInput
    song: SongCreateNestedOneWithoutPlaybackQueuesInput
  }

  export type PlaybackQueueUncheckedCreateInput = {
    id?: string
    userId: string
    songId: string
    position: number
    addedAt?: Date | string
  }

  export type PlaybackQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaybackQueueNestedInput
    song?: SongUpdateOneRequiredWithoutPlaybackQueuesNestedInput
  }

  export type PlaybackQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackQueueCreateManyInput = {
    id?: string
    userId: string
    songId: string
    position: number
    addedAt?: Date | string
  }

  export type PlaybackQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackStateCreateInput = {
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaybackStateInput
    currentSong?: SongCreateNestedOneWithoutPlaybackStatesInput
    activeDevice?: UserDeviceCreateNestedOneWithoutPlaybackStatesInput
  }

  export type PlaybackStateUncheckedCreateInput = {
    userId: string
    currentSongId?: string | null
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    activeDeviceId?: string | null
    updatedAt?: Date | string
  }

  export type PlaybackStateUpdateInput = {
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaybackStateNestedInput
    currentSong?: SongUpdateOneWithoutPlaybackStatesNestedInput
    activeDevice?: UserDeviceUpdateOneWithoutPlaybackStatesNestedInput
  }

  export type PlaybackStateUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    currentSongId?: NullableStringFieldUpdateOperationsInput | string | null
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    activeDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackStateCreateManyInput = {
    userId: string
    currentSongId?: string | null
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    activeDeviceId?: string | null
    updatedAt?: Date | string
  }

  export type PlaybackStateUpdateManyMutationInput = {
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackStateUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    currentSongId?: NullableStringFieldUpdateOperationsInput | string | null
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    activeDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOAuthAccountCreateInput = {
    id?: string
    provider: string
    providerUserId: string
    email?: string | null
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOauthAccountsInput
  }

  export type UserOAuthAccountUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    providerUserId: string
    email?: string | null
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserOAuthAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerUserId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOauthAccountsNestedInput
  }

  export type UserOAuthAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerUserId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOAuthAccountCreateManyInput = {
    id?: string
    userId: string
    provider: string
    providerUserId: string
    email?: string | null
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserOAuthAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerUserId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOAuthAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerUserId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    tokenHash: string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
    device?: UserDeviceCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    deviceId?: string | null
    tokenHash: string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    device?: UserDeviceUpdateOneWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    deviceId?: string | null
    tokenHash: string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceCreateInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
    sessions?: UserSessionCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceUncheckedCreateInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateUncheckedCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferUncheckedCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferUncheckedCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
    sessions?: UserSessionUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUncheckedUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUncheckedUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUncheckedUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceCreateManyInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceSyncStateCreateInput = {
    id?: string
    userId: string
    syncType: $Enums.SyncType
    lastSyncVersion?: bigint | number
    lastSyncAt?: Date | string | null
    pendingChanges?: number
    device: UserDeviceCreateNestedOneWithoutSyncStatesInput
  }

  export type DeviceSyncStateUncheckedCreateInput = {
    id?: string
    userId: string
    deviceId: string
    syncType: $Enums.SyncType
    lastSyncVersion?: bigint | number
    lastSyncAt?: Date | string | null
    pendingChanges?: number
  }

  export type DeviceSyncStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    lastSyncVersion?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingChanges?: IntFieldUpdateOperationsInput | number
    device?: UserDeviceUpdateOneRequiredWithoutSyncStatesNestedInput
  }

  export type DeviceSyncStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    lastSyncVersion?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingChanges?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceSyncStateCreateManyInput = {
    id?: string
    userId: string
    deviceId: string
    syncType: $Enums.SyncType
    lastSyncVersion?: bigint | number
    lastSyncAt?: Date | string | null
    pendingChanges?: number
  }

  export type DeviceSyncStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    lastSyncVersion?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingChanges?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceSyncStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    lastSyncVersion?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingChanges?: IntFieldUpdateOperationsInput | number
  }

  export type SyncLogCreateInput = {
    id?: string
    userId: string
    entityType: string
    entityId: string
    action: $Enums.SyncAction
    version: bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sourceDevice?: UserDeviceCreateNestedOneWithoutSyncLogsInput
  }

  export type SyncLogUncheckedCreateInput = {
    id?: string
    userId: string
    entityType: string
    entityId: string
    action: $Enums.SyncAction
    version: bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    sourceDeviceId?: string | null
    createdAt?: Date | string
  }

  export type SyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumSyncActionFieldUpdateOperationsInput | $Enums.SyncAction
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceDevice?: UserDeviceUpdateOneWithoutSyncLogsNestedInput
  }

  export type SyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumSyncActionFieldUpdateOperationsInput | $Enums.SyncAction
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    sourceDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogCreateManyInput = {
    id?: string
    userId: string
    entityType: string
    entityId: string
    action: $Enums.SyncAction
    version: bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    sourceDeviceId?: string | null
    createdAt?: Date | string
  }

  export type SyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumSyncActionFieldUpdateOperationsInput | $Enums.SyncAction
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumSyncActionFieldUpdateOperationsInput | $Enums.SyncAction
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    sourceDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTransferCreateInput = {
    id?: string
    userId: string
    status?: $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
    fromDevice: UserDeviceCreateNestedOneWithoutTransfersFromInput
    toDevice: UserDeviceCreateNestedOneWithoutTransfersToInput
  }

  export type DeviceTransferUncheckedCreateInput = {
    id?: string
    userId: string
    fromDeviceId: string
    toDeviceId: string
    status?: $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type DeviceTransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromDevice?: UserDeviceUpdateOneRequiredWithoutTransfersFromNestedInput
    toDevice?: UserDeviceUpdateOneRequiredWithoutTransfersToNestedInput
  }

  export type DeviceTransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fromDeviceId?: StringFieldUpdateOperationsInput | string
    toDeviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTransferCreateManyInput = {
    id?: string
    userId: string
    fromDeviceId: string
    toDeviceId: string
    status?: $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type DeviceTransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fromDeviceId?: StringFieldUpdateOperationsInput | string
    toDeviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxDevices?: number
    hasAds?: boolean
    canDownload?: boolean
    audioQuality?: $Enums.AudioQuality
    smartShuffle?: boolean
    skipLimit?: number | null
    isActive?: boolean
    createdAt?: Date | string
    subscriptions?: UserSubscriptionCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxDevices?: number
    hasAds?: boolean
    canDownload?: boolean
    audioQuality?: $Enums.AudioQuality
    smartShuffle?: boolean
    skipLimit?: number | null
    isActive?: boolean
    createdAt?: Date | string
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxDevices?: IntFieldUpdateOperationsInput | number
    hasAds?: BoolFieldUpdateOperationsInput | boolean
    canDownload?: BoolFieldUpdateOperationsInput | boolean
    audioQuality?: EnumAudioQualityFieldUpdateOperationsInput | $Enums.AudioQuality
    smartShuffle?: BoolFieldUpdateOperationsInput | boolean
    skipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: UserSubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxDevices?: IntFieldUpdateOperationsInput | number
    hasAds?: BoolFieldUpdateOperationsInput | boolean
    canDownload?: BoolFieldUpdateOperationsInput | boolean
    audioQuality?: EnumAudioQualityFieldUpdateOperationsInput | $Enums.AudioQuality
    smartShuffle?: BoolFieldUpdateOperationsInput | boolean
    skipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPlanCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxDevices?: number
    hasAds?: boolean
    canDownload?: boolean
    audioQuality?: $Enums.AudioQuality
    smartShuffle?: boolean
    skipLimit?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxDevices?: IntFieldUpdateOperationsInput | number
    hasAds?: BoolFieldUpdateOperationsInput | boolean
    canDownload?: BoolFieldUpdateOperationsInput | boolean
    audioQuality?: EnumAudioQualityFieldUpdateOperationsInput | $Enums.AudioQuality
    smartShuffle?: BoolFieldUpdateOperationsInput | boolean
    skipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxDevices?: IntFieldUpdateOperationsInput | number
    hasAds?: BoolFieldUpdateOperationsInput | boolean
    canDownload?: BoolFieldUpdateOperationsInput | boolean
    audioQuality?: EnumAudioQualityFieldUpdateOperationsInput | $Enums.AudioQuality
    smartShuffle?: BoolFieldUpdateOperationsInput | boolean
    skipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    billingCycle?: $Enums.BillingCycle
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type UserSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    billingCycle?: $Enums.BillingCycle
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type UserSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateManyInput = {
    id?: string
    userId: string
    planId: string
    status?: $Enums.SubscriptionStatus
    billingCycle?: $Enums.BillingCycle
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisementCreateInput = {
    id?: string
    name: string
    advertiser: string
    adType: $Enums.AdType
    mediaUrl: string
    clickUrl?: string | null
    durationMs?: number | null
    targetCountries?: AdvertisementCreatetargetCountriesInput | string[]
    targetAgeMin?: number | null
    targetAgeMax?: number | null
    targetGenres?: AdvertisementCreatetargetGenresInput | string[]
    priority?: number
    budget?: Decimal | DecimalJsLike | number | string | null
    costPerImpression?: Decimal | DecimalJsLike | number | string | null
    costPerClick?: Decimal | DecimalJsLike | number | string | null
    totalImpressions?: bigint | number
    totalClicks?: bigint | number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    impressions?: AdImpressionCreateNestedManyWithoutAdInput
  }

  export type AdvertisementUncheckedCreateInput = {
    id?: string
    name: string
    advertiser: string
    adType: $Enums.AdType
    mediaUrl: string
    clickUrl?: string | null
    durationMs?: number | null
    targetCountries?: AdvertisementCreatetargetCountriesInput | string[]
    targetAgeMin?: number | null
    targetAgeMax?: number | null
    targetGenres?: AdvertisementCreatetargetGenresInput | string[]
    priority?: number
    budget?: Decimal | DecimalJsLike | number | string | null
    costPerImpression?: Decimal | DecimalJsLike | number | string | null
    costPerClick?: Decimal | DecimalJsLike | number | string | null
    totalImpressions?: bigint | number
    totalClicks?: bigint | number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    impressions?: AdImpressionUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdvertisementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    advertiser?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    mediaUrl?: StringFieldUpdateOperationsInput | string
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    targetCountries?: AdvertisementUpdatetargetCountriesInput | string[]
    targetAgeMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetAgeMax?: NullableIntFieldUpdateOperationsInput | number | null
    targetGenres?: AdvertisementUpdatetargetGenresInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerImpression?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerClick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalImpressions?: BigIntFieldUpdateOperationsInput | bigint | number
    totalClicks?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: AdImpressionUpdateManyWithoutAdNestedInput
  }

  export type AdvertisementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    advertiser?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    mediaUrl?: StringFieldUpdateOperationsInput | string
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    targetCountries?: AdvertisementUpdatetargetCountriesInput | string[]
    targetAgeMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetAgeMax?: NullableIntFieldUpdateOperationsInput | number | null
    targetGenres?: AdvertisementUpdatetargetGenresInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerImpression?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerClick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalImpressions?: BigIntFieldUpdateOperationsInput | bigint | number
    totalClicks?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: AdImpressionUncheckedUpdateManyWithoutAdNestedInput
  }

  export type AdvertisementCreateManyInput = {
    id?: string
    name: string
    advertiser: string
    adType: $Enums.AdType
    mediaUrl: string
    clickUrl?: string | null
    durationMs?: number | null
    targetCountries?: AdvertisementCreatetargetCountriesInput | string[]
    targetAgeMin?: number | null
    targetAgeMax?: number | null
    targetGenres?: AdvertisementCreatetargetGenresInput | string[]
    priority?: number
    budget?: Decimal | DecimalJsLike | number | string | null
    costPerImpression?: Decimal | DecimalJsLike | number | string | null
    costPerClick?: Decimal | DecimalJsLike | number | string | null
    totalImpressions?: bigint | number
    totalClicks?: bigint | number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvertisementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    advertiser?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    mediaUrl?: StringFieldUpdateOperationsInput | string
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    targetCountries?: AdvertisementUpdatetargetCountriesInput | string[]
    targetAgeMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetAgeMax?: NullableIntFieldUpdateOperationsInput | number | null
    targetGenres?: AdvertisementUpdatetargetGenresInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerImpression?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerClick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalImpressions?: BigIntFieldUpdateOperationsInput | bigint | number
    totalClicks?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    advertiser?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    mediaUrl?: StringFieldUpdateOperationsInput | string
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    targetCountries?: AdvertisementUpdatetargetCountriesInput | string[]
    targetAgeMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetAgeMax?: NullableIntFieldUpdateOperationsInput | number | null
    targetGenres?: AdvertisementUpdatetargetGenresInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerImpression?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerClick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalImpressions?: BigIntFieldUpdateOperationsInput | bigint | number
    totalClicks?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionCreateInput = {
    id?: string
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdImpressionsInput
    ad: AdvertisementCreateNestedOneWithoutImpressionsInput
    device?: UserDeviceCreateNestedOneWithoutAdImpressionsInput
  }

  export type AdImpressionUncheckedCreateInput = {
    id?: string
    userId: string
    adId: string
    deviceId?: string | null
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type AdImpressionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdImpressionsNestedInput
    ad?: AdvertisementUpdateOneRequiredWithoutImpressionsNestedInput
    device?: UserDeviceUpdateOneWithoutAdImpressionsNestedInput
  }

  export type AdImpressionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionCreateManyInput = {
    id?: string
    userId: string
    adId: string
    deviceId?: string | null
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type AdImpressionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAdSettingsCreateInput = {
    lastAdShownAt?: Date | string | null
    songsSinceLastAd?: number
    adsPerHour?: number
    skipCountToday?: number
    skipResetAt?: Date | string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdSettingsInput
  }

  export type UserAdSettingsUncheckedCreateInput = {
    userId: string
    lastAdShownAt?: Date | string | null
    songsSinceLastAd?: number
    adsPerHour?: number
    skipCountToday?: number
    skipResetAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type UserAdSettingsUpdateInput = {
    lastAdShownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    songsSinceLastAd?: IntFieldUpdateOperationsInput | number
    adsPerHour?: IntFieldUpdateOperationsInput | number
    skipCountToday?: IntFieldUpdateOperationsInput | number
    skipResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdSettingsNestedInput
  }

  export type UserAdSettingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    lastAdShownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    songsSinceLastAd?: IntFieldUpdateOperationsInput | number
    adsPerHour?: IntFieldUpdateOperationsInput | number
    skipCountToday?: IntFieldUpdateOperationsInput | number
    skipResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAdSettingsCreateManyInput = {
    userId: string
    lastAdShownAt?: Date | string | null
    songsSinceLastAd?: number
    adsPerHour?: number
    skipCountToday?: number
    skipResetAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type UserAdSettingsUpdateManyMutationInput = {
    lastAdShownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    songsSinceLastAd?: IntFieldUpdateOperationsInput | number
    adsPerHour?: IntFieldUpdateOperationsInput | number
    skipCountToday?: IntFieldUpdateOperationsInput | number
    skipResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAdSettingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    lastAdShownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    songsSinceLastAd?: IntFieldUpdateOperationsInput | number
    adsPerHour?: IntFieldUpdateOperationsInput | number
    skipCountToday?: IntFieldUpdateOperationsInput | number
    skipResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ArtistNullableScalarRelationFilter = {
    is?: ArtistWhereInput | null
    isNot?: ArtistWhereInput | null
  }

  export type UserOAuthAccountListRelationFilter = {
    every?: UserOAuthAccountWhereInput
    some?: UserOAuthAccountWhereInput
    none?: UserOAuthAccountWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type UserDeviceListRelationFilter = {
    every?: UserDeviceWhereInput
    some?: UserDeviceWhereInput
    none?: UserDeviceWhereInput
  }

  export type PlaylistListRelationFilter = {
    every?: PlaylistWhereInput
    some?: PlaylistWhereInput
    none?: PlaylistWhereInput
  }

  export type UserFollowListRelationFilter = {
    every?: UserFollowWhereInput
    some?: UserFollowWhereInput
    none?: UserFollowWhereInput
  }

  export type UserLibraryListRelationFilter = {
    every?: UserLibraryWhereInput
    some?: UserLibraryWhereInput
    none?: UserLibraryWhereInput
  }

  export type ListeningHistoryListRelationFilter = {
    every?: ListeningHistoryWhereInput
    some?: ListeningHistoryWhereInput
    none?: ListeningHistoryWhereInput
  }

  export type RecentlyPlayedListRelationFilter = {
    every?: RecentlyPlayedWhereInput
    some?: RecentlyPlayedWhereInput
    none?: RecentlyPlayedWhereInput
  }

  export type PlaybackStateNullableScalarRelationFilter = {
    is?: PlaybackStateWhereInput | null
    isNot?: PlaybackStateWhereInput | null
  }

  export type PlaybackQueueListRelationFilter = {
    every?: PlaybackQueueWhereInput
    some?: PlaybackQueueWhereInput
    none?: PlaybackQueueWhereInput
  }

  export type UserSubscriptionListRelationFilter = {
    every?: UserSubscriptionWhereInput
    some?: UserSubscriptionWhereInput
    none?: UserSubscriptionWhereInput
  }

  export type AdImpressionListRelationFilter = {
    every?: AdImpressionWhereInput
    some?: AdImpressionWhereInput
    none?: AdImpressionWhereInput
  }

  export type UserAdSettingsNullableScalarRelationFilter = {
    is?: UserAdSettingsWhereInput | null
    isNot?: UserAdSettingsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOAuthAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaylistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLibraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListeningHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecentlyPlayedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaybackQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdImpressionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    dateOfBirth?: SortOrder
    country?: SortOrder
    subscriptionType?: SortOrder
    isArtist?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    dateOfBirth?: SortOrder
    country?: SortOrder
    subscriptionType?: SortOrder
    isArtist?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    dateOfBirth?: SortOrder
    country?: SortOrder
    subscriptionType?: SortOrder
    isArtist?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AlbumListRelationFilter = {
    every?: AlbumWhereInput
    some?: AlbumWhereInput
    none?: AlbumWhereInput
  }

  export type SongListRelationFilter = {
    every?: SongWhereInput
    some?: SongWhereInput
    none?: SongWhereInput
  }

  export type SongArtistListRelationFilter = {
    every?: SongArtistWhereInput
    some?: SongArtistWhereInput
    none?: SongArtistWhereInput
  }

  export type ArtistGenreListRelationFilter = {
    every?: ArtistGenreWhereInput
    some?: ArtistGenreWhereInput
    none?: ArtistGenreWhereInput
  }

  export type AlbumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SongOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SongArtistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtistGenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistAvgOrderByAggregateInput = {
    monthlyListeners?: SortOrder
  }

  export type ArtistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    verified?: SortOrder
    monthlyListeners?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArtistSumOrderByAggregateInput = {
    monthlyListeners?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumAlbumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlbumType | EnumAlbumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlbumTypeFilter<$PrismaModel> | $Enums.AlbumType
  }

  export type ArtistScalarRelationFilter = {
    is?: ArtistWhereInput
    isNot?: ArtistWhereInput
  }

  export type AlbumCountOrderByAggregateInput = {
    id?: SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    coverUrl?: SortOrder
    releaseDate?: SortOrder
    albumType?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlbumAvgOrderByAggregateInput = {
    totalTracks?: SortOrder
    durationMs?: SortOrder
  }

  export type AlbumMaxOrderByAggregateInput = {
    id?: SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    coverUrl?: SortOrder
    releaseDate?: SortOrder
    albumType?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlbumMinOrderByAggregateInput = {
    id?: SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    coverUrl?: SortOrder
    releaseDate?: SortOrder
    albumType?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlbumSumOrderByAggregateInput = {
    totalTracks?: SortOrder
    durationMs?: SortOrder
  }

  export type EnumAlbumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlbumType | EnumAlbumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlbumTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlbumType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlbumTypeFilter<$PrismaModel>
    _max?: NestedEnumAlbumTypeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type AlbumNullableScalarRelationFilter = {
    is?: AlbumWhereInput | null
    isNot?: AlbumWhereInput | null
  }

  export type SongGenreListRelationFilter = {
    every?: SongGenreWhereInput
    some?: SongGenreWhereInput
    none?: SongGenreWhereInput
  }

  export type PlaylistSongListRelationFilter = {
    every?: PlaylistSongWhereInput
    some?: PlaylistSongWhereInput
    none?: PlaylistSongWhereInput
  }

  export type PlaybackStateListRelationFilter = {
    every?: PlaybackStateWhereInput
    some?: PlaybackStateWhereInput
    none?: PlaybackStateWhereInput
  }

  export type SongGenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaylistSongOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaybackStateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SongCountOrderByAggregateInput = {
    id?: SortOrder
    albumId?: SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    trackNumber?: SortOrder
    discNumber?: SortOrder
    durationMs?: SortOrder
    audioUrl?: SortOrder
    previewUrl?: SortOrder
    lyricsUrl?: SortOrder
    isExplicit?: SortOrder
    isPlayable?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SongAvgOrderByAggregateInput = {
    trackNumber?: SortOrder
    discNumber?: SortOrder
    durationMs?: SortOrder
    playCount?: SortOrder
  }

  export type SongMaxOrderByAggregateInput = {
    id?: SortOrder
    albumId?: SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    trackNumber?: SortOrder
    discNumber?: SortOrder
    durationMs?: SortOrder
    audioUrl?: SortOrder
    previewUrl?: SortOrder
    lyricsUrl?: SortOrder
    isExplicit?: SortOrder
    isPlayable?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SongMinOrderByAggregateInput = {
    id?: SortOrder
    albumId?: SortOrder
    artistId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    trackNumber?: SortOrder
    discNumber?: SortOrder
    durationMs?: SortOrder
    audioUrl?: SortOrder
    previewUrl?: SortOrder
    lyricsUrl?: SortOrder
    isExplicit?: SortOrder
    isPlayable?: SortOrder
    playCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SongSumOrderByAggregateInput = {
    trackNumber?: SortOrder
    discNumber?: SortOrder
    durationMs?: SortOrder
    playCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type GenreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type GenreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type GenreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
  }

  export type SongScalarRelationFilter = {
    is?: SongWhereInput
    isNot?: SongWhereInput
  }

  export type GenreScalarRelationFilter = {
    is?: GenreWhereInput
    isNot?: GenreWhereInput
  }

  export type SongGenreSongIdGenreIdCompoundUniqueInput = {
    songId: string
    genreId: string
  }

  export type SongGenreCountOrderByAggregateInput = {
    songId?: SortOrder
    genreId?: SortOrder
  }

  export type SongGenreMaxOrderByAggregateInput = {
    songId?: SortOrder
    genreId?: SortOrder
  }

  export type SongGenreMinOrderByAggregateInput = {
    songId?: SortOrder
    genreId?: SortOrder
  }

  export type ArtistGenreArtistIdGenreIdCompoundUniqueInput = {
    artistId: string
    genreId: string
  }

  export type ArtistGenreCountOrderByAggregateInput = {
    artistId?: SortOrder
    genreId?: SortOrder
  }

  export type ArtistGenreMaxOrderByAggregateInput = {
    artistId?: SortOrder
    genreId?: SortOrder
  }

  export type ArtistGenreMinOrderByAggregateInput = {
    artistId?: SortOrder
    genreId?: SortOrder
  }

  export type EnumArtistRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistRole | EnumArtistRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistRoleFilter<$PrismaModel> | $Enums.ArtistRole
  }

  export type SongArtistSongIdArtistIdCompoundUniqueInput = {
    songId: string
    artistId: string
  }

  export type SongArtistCountOrderByAggregateInput = {
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
  }

  export type SongArtistMaxOrderByAggregateInput = {
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
  }

  export type SongArtistMinOrderByAggregateInput = {
    songId?: SortOrder
    artistId?: SortOrder
    role?: SortOrder
  }

  export type EnumArtistRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistRole | EnumArtistRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistRoleWithAggregatesFilter<$PrismaModel> | $Enums.ArtistRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtistRoleFilter<$PrismaModel>
    _max?: NestedEnumArtistRoleFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PlaylistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isPublic?: SortOrder
    isCollaborative?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaylistAvgOrderByAggregateInput = {
    totalTracks?: SortOrder
    durationMs?: SortOrder
  }

  export type PlaylistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isPublic?: SortOrder
    isCollaborative?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaylistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isPublic?: SortOrder
    isCollaborative?: SortOrder
    totalTracks?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaylistSumOrderByAggregateInput = {
    totalTracks?: SortOrder
    durationMs?: SortOrder
  }

  export type PlaylistScalarRelationFilter = {
    is?: PlaylistWhereInput
    isNot?: PlaylistWhereInput
  }

  export type PlaylistSongPlaylistIdSongIdCompoundUniqueInput = {
    playlistId: string
    songId: string
  }

  export type PlaylistSongCountOrderByAggregateInput = {
    id?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
  }

  export type PlaylistSongAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type PlaylistSongMaxOrderByAggregateInput = {
    id?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
  }

  export type PlaylistSongMinOrderByAggregateInput = {
    id?: SortOrder
    playlistId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
  }

  export type PlaylistSongSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumFollowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowType | EnumFollowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FollowType[] | ListEnumFollowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowType[] | ListEnumFollowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowTypeFilter<$PrismaModel> | $Enums.FollowType
  }

  export type PlaylistNullableScalarRelationFilter = {
    is?: PlaylistWhereInput | null
    isNot?: PlaylistWhereInput | null
  }

  export type UserFollowFollowerIdFollowingTypeFollowingIdCompoundUniqueInput = {
    followerId: string
    followingType: $Enums.FollowType
    followingId: string
  }

  export type UserFollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingType?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingType?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingType?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFollowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowType | EnumFollowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FollowType[] | ListEnumFollowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowType[] | ListEnumFollowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowTypeWithAggregatesFilter<$PrismaModel> | $Enums.FollowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowTypeFilter<$PrismaModel>
    _max?: NestedEnumFollowTypeFilter<$PrismaModel>
  }

  export type EnumLibraryItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryItemType | EnumLibraryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLibraryItemTypeFilter<$PrismaModel> | $Enums.LibraryItemType
  }

  export type UserLibraryUserIdItemTypeItemIdCompoundUniqueInput = {
    userId: string
    itemType: $Enums.LibraryItemType
    itemId: string
  }

  export type UserLibraryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    addedAt?: SortOrder
  }

  export type UserLibraryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    addedAt?: SortOrder
  }

  export type UserLibraryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    addedAt?: SortOrder
  }

  export type EnumLibraryItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryItemType | EnumLibraryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLibraryItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.LibraryItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLibraryItemTypeFilter<$PrismaModel>
    _max?: NestedEnumLibraryItemTypeFilter<$PrismaModel>
  }

  export type EnumContextTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContextType | EnumContextTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContextTypeNullableFilter<$PrismaModel> | $Enums.ContextType | null
  }

  export type ListeningHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    durationMs?: SortOrder
    contextType?: SortOrder
    contextId?: SortOrder
  }

  export type ListeningHistoryAvgOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type ListeningHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    durationMs?: SortOrder
    contextType?: SortOrder
    contextId?: SortOrder
  }

  export type ListeningHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    durationMs?: SortOrder
    contextType?: SortOrder
    contextId?: SortOrder
  }

  export type ListeningHistorySumOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type EnumContextTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContextType | EnumContextTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContextTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContextType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContextTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumContextTypeNullableFilter<$PrismaModel>
  }

  export type RecentlyPlayedUserIdSongIdCompoundUniqueInput = {
    userId: string
    songId: string
  }

  export type RecentlyPlayedCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    contextType?: SortOrder
    contextId?: SortOrder
  }

  export type RecentlyPlayedMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    contextType?: SortOrder
    contextId?: SortOrder
  }

  export type RecentlyPlayedMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    playedAt?: SortOrder
    contextType?: SortOrder
    contextId?: SortOrder
  }

  export type PlaybackQueueUserIdPositionCompoundUniqueInput = {
    userId: string
    position: number
  }

  export type PlaybackQueueCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
  }

  export type PlaybackQueueAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type PlaybackQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
  }

  export type PlaybackQueueMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    songId?: SortOrder
    position?: SortOrder
    addedAt?: SortOrder
  }

  export type PlaybackQueueSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumShuffleModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShuffleMode | EnumShuffleModeFieldRefInput<$PrismaModel>
    in?: $Enums.ShuffleMode[] | ListEnumShuffleModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShuffleMode[] | ListEnumShuffleModeFieldRefInput<$PrismaModel>
    not?: NestedEnumShuffleModeFilter<$PrismaModel> | $Enums.ShuffleMode
  }

  export type EnumRepeatModeFilter<$PrismaModel = never> = {
    equals?: $Enums.RepeatMode | EnumRepeatModeFieldRefInput<$PrismaModel>
    in?: $Enums.RepeatMode[] | ListEnumRepeatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RepeatMode[] | ListEnumRepeatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumRepeatModeFilter<$PrismaModel> | $Enums.RepeatMode
  }

  export type SongNullableScalarRelationFilter = {
    is?: SongWhereInput | null
    isNot?: SongWhereInput | null
  }

  export type UserDeviceNullableScalarRelationFilter = {
    is?: UserDeviceWhereInput | null
    isNot?: UserDeviceWhereInput | null
  }

  export type PlaybackStateCountOrderByAggregateInput = {
    userId?: SortOrder
    currentSongId?: SortOrder
    progressMs?: SortOrder
    isPlaying?: SortOrder
    shuffleMode?: SortOrder
    repeatMode?: SortOrder
    volume?: SortOrder
    contextType?: SortOrder
    contextId?: SortOrder
    activeDeviceId?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaybackStateAvgOrderByAggregateInput = {
    progressMs?: SortOrder
    volume?: SortOrder
  }

  export type PlaybackStateMaxOrderByAggregateInput = {
    userId?: SortOrder
    currentSongId?: SortOrder
    progressMs?: SortOrder
    isPlaying?: SortOrder
    shuffleMode?: SortOrder
    repeatMode?: SortOrder
    volume?: SortOrder
    contextType?: SortOrder
    contextId?: SortOrder
    activeDeviceId?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaybackStateMinOrderByAggregateInput = {
    userId?: SortOrder
    currentSongId?: SortOrder
    progressMs?: SortOrder
    isPlaying?: SortOrder
    shuffleMode?: SortOrder
    repeatMode?: SortOrder
    volume?: SortOrder
    contextType?: SortOrder
    contextId?: SortOrder
    activeDeviceId?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaybackStateSumOrderByAggregateInput = {
    progressMs?: SortOrder
    volume?: SortOrder
  }

  export type EnumShuffleModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShuffleMode | EnumShuffleModeFieldRefInput<$PrismaModel>
    in?: $Enums.ShuffleMode[] | ListEnumShuffleModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShuffleMode[] | ListEnumShuffleModeFieldRefInput<$PrismaModel>
    not?: NestedEnumShuffleModeWithAggregatesFilter<$PrismaModel> | $Enums.ShuffleMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShuffleModeFilter<$PrismaModel>
    _max?: NestedEnumShuffleModeFilter<$PrismaModel>
  }

  export type EnumRepeatModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RepeatMode | EnumRepeatModeFieldRefInput<$PrismaModel>
    in?: $Enums.RepeatMode[] | ListEnumRepeatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RepeatMode[] | ListEnumRepeatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumRepeatModeWithAggregatesFilter<$PrismaModel> | $Enums.RepeatMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRepeatModeFilter<$PrismaModel>
    _max?: NestedEnumRepeatModeFilter<$PrismaModel>
  }

  export type UserOAuthAccountProviderProviderUserIdCompoundUniqueInput = {
    provider: string
    providerUserId: string
  }

  export type UserOAuthAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerUserId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserOAuthAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerUserId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserOAuthAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerUserId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type EnumDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceTypeFilter<$PrismaModel> | $Enums.DeviceType
  }

  export type DeviceSyncStateListRelationFilter = {
    every?: DeviceSyncStateWhereInput
    some?: DeviceSyncStateWhereInput
    none?: DeviceSyncStateWhereInput
  }

  export type SyncLogListRelationFilter = {
    every?: SyncLogWhereInput
    some?: SyncLogWhereInput
    none?: SyncLogWhereInput
  }

  export type DeviceTransferListRelationFilter = {
    every?: DeviceTransferWhereInput
    some?: DeviceTransferWhereInput
    none?: DeviceTransferWhereInput
  }

  export type DeviceSyncStateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyncLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDeviceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrder
    deviceToken?: SortOrder
    appVersion?: SortOrder
    osVersion?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrder
    deviceToken?: SortOrder
    appVersion?: SortOrder
    osVersion?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDeviceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceName?: SortOrder
    deviceToken?: SortOrder
    appVersion?: SortOrder
    osVersion?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumDeviceTypeFilter<$PrismaModel>
  }

  export type EnumSyncTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncTypeFilter<$PrismaModel> | $Enums.SyncType
  }

  export type UserDeviceScalarRelationFilter = {
    is?: UserDeviceWhereInput
    isNot?: UserDeviceWhereInput
  }

  export type DeviceSyncStateUserIdDeviceIdSyncTypeCompoundUniqueInput = {
    userId: string
    deviceId: string
    syncType: $Enums.SyncType
  }

  export type DeviceSyncStateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    syncType?: SortOrder
    lastSyncVersion?: SortOrder
    lastSyncAt?: SortOrder
    pendingChanges?: SortOrder
  }

  export type DeviceSyncStateAvgOrderByAggregateInput = {
    lastSyncVersion?: SortOrder
    pendingChanges?: SortOrder
  }

  export type DeviceSyncStateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    syncType?: SortOrder
    lastSyncVersion?: SortOrder
    lastSyncAt?: SortOrder
    pendingChanges?: SortOrder
  }

  export type DeviceSyncStateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    syncType?: SortOrder
    lastSyncVersion?: SortOrder
    lastSyncAt?: SortOrder
    pendingChanges?: SortOrder
  }

  export type DeviceSyncStateSumOrderByAggregateInput = {
    lastSyncVersion?: SortOrder
    pendingChanges?: SortOrder
  }

  export type EnumSyncTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncTypeWithAggregatesFilter<$PrismaModel> | $Enums.SyncType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncTypeFilter<$PrismaModel>
    _max?: NestedEnumSyncTypeFilter<$PrismaModel>
  }

  export type EnumSyncActionFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncAction | EnumSyncActionFieldRefInput<$PrismaModel>
    in?: $Enums.SyncAction[] | ListEnumSyncActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncAction[] | ListEnumSyncActionFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncActionFilter<$PrismaModel> | $Enums.SyncAction
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    version?: SortOrder
    payload?: SortOrder
    sourceDeviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncLogAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type SyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    version?: SortOrder
    sourceDeviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    version?: SortOrder
    sourceDeviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type SyncLogSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumSyncActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncAction | EnumSyncActionFieldRefInput<$PrismaModel>
    in?: $Enums.SyncAction[] | ListEnumSyncActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncAction[] | ListEnumSyncActionFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncActionWithAggregatesFilter<$PrismaModel> | $Enums.SyncAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncActionFilter<$PrismaModel>
    _max?: NestedEnumSyncActionFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type DeviceTransferCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fromDeviceId?: SortOrder
    toDeviceId?: SortOrder
    status?: SortOrder
    transferData?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type DeviceTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fromDeviceId?: SortOrder
    toDeviceId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type DeviceTransferMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fromDeviceId?: SortOrder
    toDeviceId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumAudioQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.AudioQuality | EnumAudioQualityFieldRefInput<$PrismaModel>
    in?: $Enums.AudioQuality[] | ListEnumAudioQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AudioQuality[] | ListEnumAudioQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumAudioQualityFilter<$PrismaModel> | $Enums.AudioQuality
  }

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    maxDevices?: SortOrder
    hasAds?: SortOrder
    canDownload?: SortOrder
    audioQuality?: SortOrder
    smartShuffle?: SortOrder
    skipLimit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxDevices?: SortOrder
    skipLimit?: SortOrder
  }

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    maxDevices?: SortOrder
    hasAds?: SortOrder
    canDownload?: SortOrder
    audioQuality?: SortOrder
    smartShuffle?: SortOrder
    skipLimit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    currency?: SortOrder
    maxDevices?: SortOrder
    hasAds?: SortOrder
    canDownload?: SortOrder
    audioQuality?: SortOrder
    smartShuffle?: SortOrder
    skipLimit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionPlanSumOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxDevices?: SortOrder
    skipLimit?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumAudioQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AudioQuality | EnumAudioQualityFieldRefInput<$PrismaModel>
    in?: $Enums.AudioQuality[] | ListEnumAudioQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AudioQuality[] | ListEnumAudioQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumAudioQualityWithAggregatesFilter<$PrismaModel> | $Enums.AudioQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAudioQualityFilter<$PrismaModel>
    _max?: NestedEnumAudioQualityFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type EnumBillingCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleFilter<$PrismaModel> | $Enums.BillingCycle
  }

  export type SubscriptionPlanScalarRelationFilter = {
    is?: SubscriptionPlanWhereInput
    isNot?: SubscriptionPlanWhereInput
  }

  export type UserSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextBillingDate?: SortOrder
    cancelledAt?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextBillingDate?: SortOrder
    cancelledAt?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    billingCycle?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextBillingDate?: SortOrder
    cancelledAt?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumBillingCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel> | $Enums.BillingCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCycleFilter<$PrismaModel>
    _max?: NestedEnumBillingCycleFilter<$PrismaModel>
  }

  export type EnumAdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdType | EnumAdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdType[] | ListEnumAdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdType[] | ListEnumAdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdTypeFilter<$PrismaModel> | $Enums.AdType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AdvertisementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    advertiser?: SortOrder
    adType?: SortOrder
    mediaUrl?: SortOrder
    clickUrl?: SortOrder
    durationMs?: SortOrder
    targetCountries?: SortOrder
    targetAgeMin?: SortOrder
    targetAgeMax?: SortOrder
    targetGenres?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    costPerImpression?: SortOrder
    costPerClick?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvertisementAvgOrderByAggregateInput = {
    durationMs?: SortOrder
    targetAgeMin?: SortOrder
    targetAgeMax?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    costPerImpression?: SortOrder
    costPerClick?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
  }

  export type AdvertisementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    advertiser?: SortOrder
    adType?: SortOrder
    mediaUrl?: SortOrder
    clickUrl?: SortOrder
    durationMs?: SortOrder
    targetAgeMin?: SortOrder
    targetAgeMax?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    costPerImpression?: SortOrder
    costPerClick?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvertisementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    advertiser?: SortOrder
    adType?: SortOrder
    mediaUrl?: SortOrder
    clickUrl?: SortOrder
    durationMs?: SortOrder
    targetAgeMin?: SortOrder
    targetAgeMax?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    costPerImpression?: SortOrder
    costPerClick?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvertisementSumOrderByAggregateInput = {
    durationMs?: SortOrder
    targetAgeMin?: SortOrder
    targetAgeMax?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    costPerImpression?: SortOrder
    costPerClick?: SortOrder
    totalImpressions?: SortOrder
    totalClicks?: SortOrder
  }

  export type EnumAdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdType | EnumAdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdType[] | ListEnumAdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdType[] | ListEnumAdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdTypeFilter<$PrismaModel>
    _max?: NestedEnumAdTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumImpressionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImpressionType | EnumImpressionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImpressionType[] | ListEnumImpressionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImpressionType[] | ListEnumImpressionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImpressionTypeFilter<$PrismaModel> | $Enums.ImpressionType
  }

  export type EnumAdContextTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AdContextType | EnumAdContextTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdContextType[] | ListEnumAdContextTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdContextType[] | ListEnumAdContextTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdContextTypeNullableFilter<$PrismaModel> | $Enums.AdContextType | null
  }

  export type AdvertisementScalarRelationFilter = {
    is?: AdvertisementWhereInput
    isNot?: AdvertisementWhereInput
  }

  export type AdImpressionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrder
    deviceId?: SortOrder
    impressionType?: SortOrder
    contextType?: SortOrder
    revenue?: SortOrder
    createdAt?: SortOrder
  }

  export type AdImpressionAvgOrderByAggregateInput = {
    revenue?: SortOrder
  }

  export type AdImpressionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrder
    deviceId?: SortOrder
    impressionType?: SortOrder
    contextType?: SortOrder
    revenue?: SortOrder
    createdAt?: SortOrder
  }

  export type AdImpressionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrder
    deviceId?: SortOrder
    impressionType?: SortOrder
    contextType?: SortOrder
    revenue?: SortOrder
    createdAt?: SortOrder
  }

  export type AdImpressionSumOrderByAggregateInput = {
    revenue?: SortOrder
  }

  export type EnumImpressionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImpressionType | EnumImpressionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImpressionType[] | ListEnumImpressionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImpressionType[] | ListEnumImpressionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImpressionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImpressionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImpressionTypeFilter<$PrismaModel>
    _max?: NestedEnumImpressionTypeFilter<$PrismaModel>
  }

  export type EnumAdContextTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdContextType | EnumAdContextTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdContextType[] | ListEnumAdContextTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdContextType[] | ListEnumAdContextTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdContextTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AdContextType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAdContextTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAdContextTypeNullableFilter<$PrismaModel>
  }

  export type UserAdSettingsCountOrderByAggregateInput = {
    userId?: SortOrder
    lastAdShownAt?: SortOrder
    songsSinceLastAd?: SortOrder
    adsPerHour?: SortOrder
    skipCountToday?: SortOrder
    skipResetAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAdSettingsAvgOrderByAggregateInput = {
    songsSinceLastAd?: SortOrder
    adsPerHour?: SortOrder
    skipCountToday?: SortOrder
  }

  export type UserAdSettingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    lastAdShownAt?: SortOrder
    songsSinceLastAd?: SortOrder
    adsPerHour?: SortOrder
    skipCountToday?: SortOrder
    skipResetAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAdSettingsMinOrderByAggregateInput = {
    userId?: SortOrder
    lastAdShownAt?: SortOrder
    songsSinceLastAd?: SortOrder
    adsPerHour?: SortOrder
    skipCountToday?: SortOrder
    skipResetAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAdSettingsSumOrderByAggregateInput = {
    songsSinceLastAd?: SortOrder
    adsPerHour?: SortOrder
    skipCountToday?: SortOrder
  }

  export type ArtistCreateNestedOneWithoutUserInput = {
    create?: XOR<ArtistCreateWithoutUserInput, ArtistUncheckedCreateWithoutUserInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutUserInput
    connect?: ArtistWhereUniqueInput
  }

  export type UserOAuthAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<UserOAuthAccountCreateWithoutUserInput, UserOAuthAccountUncheckedCreateWithoutUserInput> | UserOAuthAccountCreateWithoutUserInput[] | UserOAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOAuthAccountCreateOrConnectWithoutUserInput | UserOAuthAccountCreateOrConnectWithoutUserInput[]
    createMany?: UserOAuthAccountCreateManyUserInputEnvelope
    connect?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserDeviceCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDeviceCreateWithoutUserInput, UserDeviceUncheckedCreateWithoutUserInput> | UserDeviceCreateWithoutUserInput[] | UserDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceCreateOrConnectWithoutUserInput | UserDeviceCreateOrConnectWithoutUserInput[]
    createMany?: UserDeviceCreateManyUserInputEnvelope
    connect?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
  }

  export type PlaylistCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type UserFollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserLibraryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLibraryCreateWithoutUserInput, UserLibraryUncheckedCreateWithoutUserInput> | UserLibraryCreateWithoutUserInput[] | UserLibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLibraryCreateOrConnectWithoutUserInput | UserLibraryCreateOrConnectWithoutUserInput[]
    createMany?: UserLibraryCreateManyUserInputEnvelope
    connect?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
  }

  export type ListeningHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ListeningHistoryCreateWithoutUserInput, ListeningHistoryUncheckedCreateWithoutUserInput> | ListeningHistoryCreateWithoutUserInput[] | ListeningHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListeningHistoryCreateOrConnectWithoutUserInput | ListeningHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ListeningHistoryCreateManyUserInputEnvelope
    connect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
  }

  export type RecentlyPlayedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecentlyPlayedCreateWithoutUserInput, RecentlyPlayedUncheckedCreateWithoutUserInput> | RecentlyPlayedCreateWithoutUserInput[] | RecentlyPlayedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecentlyPlayedCreateOrConnectWithoutUserInput | RecentlyPlayedCreateOrConnectWithoutUserInput[]
    createMany?: RecentlyPlayedCreateManyUserInputEnvelope
    connect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
  }

  export type PlaybackStateCreateNestedOneWithoutUserInput = {
    create?: XOR<PlaybackStateCreateWithoutUserInput, PlaybackStateUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutUserInput
    connect?: PlaybackStateWhereUniqueInput
  }

  export type PlaybackQueueCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaybackQueueCreateWithoutUserInput, PlaybackQueueUncheckedCreateWithoutUserInput> | PlaybackQueueCreateWithoutUserInput[] | PlaybackQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaybackQueueCreateOrConnectWithoutUserInput | PlaybackQueueCreateOrConnectWithoutUserInput[]
    createMany?: PlaybackQueueCreateManyUserInputEnvelope
    connect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
  }

  export type UserSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type AdImpressionCreateNestedManyWithoutUserInput = {
    create?: XOR<AdImpressionCreateWithoutUserInput, AdImpressionUncheckedCreateWithoutUserInput> | AdImpressionCreateWithoutUserInput[] | AdImpressionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutUserInput | AdImpressionCreateOrConnectWithoutUserInput[]
    createMany?: AdImpressionCreateManyUserInputEnvelope
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
  }

  export type UserAdSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAdSettingsCreateWithoutUserInput, UserAdSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAdSettingsCreateOrConnectWithoutUserInput
    connect?: UserAdSettingsWhereUniqueInput
  }

  export type ArtistUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ArtistCreateWithoutUserInput, ArtistUncheckedCreateWithoutUserInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutUserInput
    connect?: ArtistWhereUniqueInput
  }

  export type UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserOAuthAccountCreateWithoutUserInput, UserOAuthAccountUncheckedCreateWithoutUserInput> | UserOAuthAccountCreateWithoutUserInput[] | UserOAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOAuthAccountCreateOrConnectWithoutUserInput | UserOAuthAccountCreateOrConnectWithoutUserInput[]
    createMany?: UserOAuthAccountCreateManyUserInputEnvelope
    connect?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserDeviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDeviceCreateWithoutUserInput, UserDeviceUncheckedCreateWithoutUserInput> | UserDeviceCreateWithoutUserInput[] | UserDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceCreateOrConnectWithoutUserInput | UserDeviceCreateOrConnectWithoutUserInput[]
    createMany?: UserDeviceCreateManyUserInputEnvelope
    connect?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
  }

  export type PlaylistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type UserFollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserLibraryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLibraryCreateWithoutUserInput, UserLibraryUncheckedCreateWithoutUserInput> | UserLibraryCreateWithoutUserInput[] | UserLibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLibraryCreateOrConnectWithoutUserInput | UserLibraryCreateOrConnectWithoutUserInput[]
    createMany?: UserLibraryCreateManyUserInputEnvelope
    connect?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
  }

  export type ListeningHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ListeningHistoryCreateWithoutUserInput, ListeningHistoryUncheckedCreateWithoutUserInput> | ListeningHistoryCreateWithoutUserInput[] | ListeningHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListeningHistoryCreateOrConnectWithoutUserInput | ListeningHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ListeningHistoryCreateManyUserInputEnvelope
    connect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
  }

  export type RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecentlyPlayedCreateWithoutUserInput, RecentlyPlayedUncheckedCreateWithoutUserInput> | RecentlyPlayedCreateWithoutUserInput[] | RecentlyPlayedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecentlyPlayedCreateOrConnectWithoutUserInput | RecentlyPlayedCreateOrConnectWithoutUserInput[]
    createMany?: RecentlyPlayedCreateManyUserInputEnvelope
    connect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
  }

  export type PlaybackStateUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PlaybackStateCreateWithoutUserInput, PlaybackStateUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutUserInput
    connect?: PlaybackStateWhereUniqueInput
  }

  export type PlaybackQueueUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaybackQueueCreateWithoutUserInput, PlaybackQueueUncheckedCreateWithoutUserInput> | PlaybackQueueCreateWithoutUserInput[] | PlaybackQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaybackQueueCreateOrConnectWithoutUserInput | PlaybackQueueCreateOrConnectWithoutUserInput[]
    createMany?: PlaybackQueueCreateManyUserInputEnvelope
    connect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type AdImpressionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdImpressionCreateWithoutUserInput, AdImpressionUncheckedCreateWithoutUserInput> | AdImpressionCreateWithoutUserInput[] | AdImpressionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutUserInput | AdImpressionCreateOrConnectWithoutUserInput[]
    createMany?: AdImpressionCreateManyUserInputEnvelope
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
  }

  export type UserAdSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAdSettingsCreateWithoutUserInput, UserAdSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAdSettingsCreateOrConnectWithoutUserInput
    connect?: UserAdSettingsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSubscriptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ArtistUpdateOneWithoutUserNestedInput = {
    create?: XOR<ArtistCreateWithoutUserInput, ArtistUncheckedCreateWithoutUserInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutUserInput
    upsert?: ArtistUpsertWithoutUserInput
    disconnect?: ArtistWhereInput | boolean
    delete?: ArtistWhereInput | boolean
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutUserInput, ArtistUpdateWithoutUserInput>, ArtistUncheckedUpdateWithoutUserInput>
  }

  export type UserOAuthAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserOAuthAccountCreateWithoutUserInput, UserOAuthAccountUncheckedCreateWithoutUserInput> | UserOAuthAccountCreateWithoutUserInput[] | UserOAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOAuthAccountCreateOrConnectWithoutUserInput | UserOAuthAccountCreateOrConnectWithoutUserInput[]
    upsert?: UserOAuthAccountUpsertWithWhereUniqueWithoutUserInput | UserOAuthAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserOAuthAccountCreateManyUserInputEnvelope
    set?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
    disconnect?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
    delete?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
    connect?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
    update?: UserOAuthAccountUpdateWithWhereUniqueWithoutUserInput | UserOAuthAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserOAuthAccountUpdateManyWithWhereWithoutUserInput | UserOAuthAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserOAuthAccountScalarWhereInput | UserOAuthAccountScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserDeviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDeviceCreateWithoutUserInput, UserDeviceUncheckedCreateWithoutUserInput> | UserDeviceCreateWithoutUserInput[] | UserDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceCreateOrConnectWithoutUserInput | UserDeviceCreateOrConnectWithoutUserInput[]
    upsert?: UserDeviceUpsertWithWhereUniqueWithoutUserInput | UserDeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDeviceCreateManyUserInputEnvelope
    set?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
    disconnect?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
    delete?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
    connect?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
    update?: UserDeviceUpdateWithWhereUniqueWithoutUserInput | UserDeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDeviceUpdateManyWithWhereWithoutUserInput | UserDeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDeviceScalarWhereInput | UserDeviceScalarWhereInput[]
  }

  export type PlaylistUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutUserInput | PlaylistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutUserInput | PlaylistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutUserInput | PlaylistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type UserFollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowerInput | UserFollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowerInput | UserFollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowerInput | UserFollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserLibraryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLibraryCreateWithoutUserInput, UserLibraryUncheckedCreateWithoutUserInput> | UserLibraryCreateWithoutUserInput[] | UserLibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLibraryCreateOrConnectWithoutUserInput | UserLibraryCreateOrConnectWithoutUserInput[]
    upsert?: UserLibraryUpsertWithWhereUniqueWithoutUserInput | UserLibraryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLibraryCreateManyUserInputEnvelope
    set?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
    disconnect?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
    delete?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
    connect?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
    update?: UserLibraryUpdateWithWhereUniqueWithoutUserInput | UserLibraryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLibraryUpdateManyWithWhereWithoutUserInput | UserLibraryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLibraryScalarWhereInput | UserLibraryScalarWhereInput[]
  }

  export type ListeningHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ListeningHistoryCreateWithoutUserInput, ListeningHistoryUncheckedCreateWithoutUserInput> | ListeningHistoryCreateWithoutUserInput[] | ListeningHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListeningHistoryCreateOrConnectWithoutUserInput | ListeningHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ListeningHistoryUpsertWithWhereUniqueWithoutUserInput | ListeningHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ListeningHistoryCreateManyUserInputEnvelope
    set?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    disconnect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    delete?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    connect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    update?: ListeningHistoryUpdateWithWhereUniqueWithoutUserInput | ListeningHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ListeningHistoryUpdateManyWithWhereWithoutUserInput | ListeningHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ListeningHistoryScalarWhereInput | ListeningHistoryScalarWhereInput[]
  }

  export type RecentlyPlayedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecentlyPlayedCreateWithoutUserInput, RecentlyPlayedUncheckedCreateWithoutUserInput> | RecentlyPlayedCreateWithoutUserInput[] | RecentlyPlayedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecentlyPlayedCreateOrConnectWithoutUserInput | RecentlyPlayedCreateOrConnectWithoutUserInput[]
    upsert?: RecentlyPlayedUpsertWithWhereUniqueWithoutUserInput | RecentlyPlayedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecentlyPlayedCreateManyUserInputEnvelope
    set?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    disconnect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    delete?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    connect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    update?: RecentlyPlayedUpdateWithWhereUniqueWithoutUserInput | RecentlyPlayedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecentlyPlayedUpdateManyWithWhereWithoutUserInput | RecentlyPlayedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecentlyPlayedScalarWhereInput | RecentlyPlayedScalarWhereInput[]
  }

  export type PlaybackStateUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlaybackStateCreateWithoutUserInput, PlaybackStateUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutUserInput
    upsert?: PlaybackStateUpsertWithoutUserInput
    disconnect?: PlaybackStateWhereInput | boolean
    delete?: PlaybackStateWhereInput | boolean
    connect?: PlaybackStateWhereUniqueInput
    update?: XOR<XOR<PlaybackStateUpdateToOneWithWhereWithoutUserInput, PlaybackStateUpdateWithoutUserInput>, PlaybackStateUncheckedUpdateWithoutUserInput>
  }

  export type PlaybackQueueUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaybackQueueCreateWithoutUserInput, PlaybackQueueUncheckedCreateWithoutUserInput> | PlaybackQueueCreateWithoutUserInput[] | PlaybackQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaybackQueueCreateOrConnectWithoutUserInput | PlaybackQueueCreateOrConnectWithoutUserInput[]
    upsert?: PlaybackQueueUpsertWithWhereUniqueWithoutUserInput | PlaybackQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaybackQueueCreateManyUserInputEnvelope
    set?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    disconnect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    delete?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    connect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    update?: PlaybackQueueUpdateWithWhereUniqueWithoutUserInput | PlaybackQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaybackQueueUpdateManyWithWhereWithoutUserInput | PlaybackQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaybackQueueScalarWhereInput | PlaybackQueueScalarWhereInput[]
  }

  export type UserSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutUserInput | UserSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutUserInput | UserSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutUserInput | UserSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type AdImpressionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdImpressionCreateWithoutUserInput, AdImpressionUncheckedCreateWithoutUserInput> | AdImpressionCreateWithoutUserInput[] | AdImpressionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutUserInput | AdImpressionCreateOrConnectWithoutUserInput[]
    upsert?: AdImpressionUpsertWithWhereUniqueWithoutUserInput | AdImpressionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdImpressionCreateManyUserInputEnvelope
    set?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    disconnect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    delete?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    update?: AdImpressionUpdateWithWhereUniqueWithoutUserInput | AdImpressionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdImpressionUpdateManyWithWhereWithoutUserInput | AdImpressionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdImpressionScalarWhereInput | AdImpressionScalarWhereInput[]
  }

  export type UserAdSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAdSettingsCreateWithoutUserInput, UserAdSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAdSettingsCreateOrConnectWithoutUserInput
    upsert?: UserAdSettingsUpsertWithoutUserInput
    disconnect?: UserAdSettingsWhereInput | boolean
    delete?: UserAdSettingsWhereInput | boolean
    connect?: UserAdSettingsWhereUniqueInput
    update?: XOR<XOR<UserAdSettingsUpdateToOneWithWhereWithoutUserInput, UserAdSettingsUpdateWithoutUserInput>, UserAdSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ArtistUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ArtistCreateWithoutUserInput, ArtistUncheckedCreateWithoutUserInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutUserInput
    upsert?: ArtistUpsertWithoutUserInput
    disconnect?: ArtistWhereInput | boolean
    delete?: ArtistWhereInput | boolean
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutUserInput, ArtistUpdateWithoutUserInput>, ArtistUncheckedUpdateWithoutUserInput>
  }

  export type UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserOAuthAccountCreateWithoutUserInput, UserOAuthAccountUncheckedCreateWithoutUserInput> | UserOAuthAccountCreateWithoutUserInput[] | UserOAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOAuthAccountCreateOrConnectWithoutUserInput | UserOAuthAccountCreateOrConnectWithoutUserInput[]
    upsert?: UserOAuthAccountUpsertWithWhereUniqueWithoutUserInput | UserOAuthAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserOAuthAccountCreateManyUserInputEnvelope
    set?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
    disconnect?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
    delete?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
    connect?: UserOAuthAccountWhereUniqueInput | UserOAuthAccountWhereUniqueInput[]
    update?: UserOAuthAccountUpdateWithWhereUniqueWithoutUserInput | UserOAuthAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserOAuthAccountUpdateManyWithWhereWithoutUserInput | UserOAuthAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserOAuthAccountScalarWhereInput | UserOAuthAccountScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserDeviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDeviceCreateWithoutUserInput, UserDeviceUncheckedCreateWithoutUserInput> | UserDeviceCreateWithoutUserInput[] | UserDeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDeviceCreateOrConnectWithoutUserInput | UserDeviceCreateOrConnectWithoutUserInput[]
    upsert?: UserDeviceUpsertWithWhereUniqueWithoutUserInput | UserDeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDeviceCreateManyUserInputEnvelope
    set?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
    disconnect?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
    delete?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
    connect?: UserDeviceWhereUniqueInput | UserDeviceWhereUniqueInput[]
    update?: UserDeviceUpdateWithWhereUniqueWithoutUserInput | UserDeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDeviceUpdateManyWithWhereWithoutUserInput | UserDeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDeviceScalarWhereInput | UserDeviceScalarWhereInput[]
  }

  export type PlaylistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput> | PlaylistCreateWithoutUserInput[] | PlaylistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutUserInput | PlaylistCreateOrConnectWithoutUserInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutUserInput | PlaylistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaylistCreateManyUserInputEnvelope
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutUserInput | PlaylistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutUserInput | PlaylistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput> | UserFollowCreateWithoutFollowerInput[] | UserFollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutFollowerInput | UserFollowCreateOrConnectWithoutFollowerInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutFollowerInput | UserFollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: UserFollowCreateManyFollowerInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutFollowerInput | UserFollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutFollowerInput | UserFollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type UserLibraryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLibraryCreateWithoutUserInput, UserLibraryUncheckedCreateWithoutUserInput> | UserLibraryCreateWithoutUserInput[] | UserLibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLibraryCreateOrConnectWithoutUserInput | UserLibraryCreateOrConnectWithoutUserInput[]
    upsert?: UserLibraryUpsertWithWhereUniqueWithoutUserInput | UserLibraryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLibraryCreateManyUserInputEnvelope
    set?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
    disconnect?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
    delete?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
    connect?: UserLibraryWhereUniqueInput | UserLibraryWhereUniqueInput[]
    update?: UserLibraryUpdateWithWhereUniqueWithoutUserInput | UserLibraryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLibraryUpdateManyWithWhereWithoutUserInput | UserLibraryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLibraryScalarWhereInput | UserLibraryScalarWhereInput[]
  }

  export type ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ListeningHistoryCreateWithoutUserInput, ListeningHistoryUncheckedCreateWithoutUserInput> | ListeningHistoryCreateWithoutUserInput[] | ListeningHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListeningHistoryCreateOrConnectWithoutUserInput | ListeningHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ListeningHistoryUpsertWithWhereUniqueWithoutUserInput | ListeningHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ListeningHistoryCreateManyUserInputEnvelope
    set?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    disconnect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    delete?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    connect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    update?: ListeningHistoryUpdateWithWhereUniqueWithoutUserInput | ListeningHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ListeningHistoryUpdateManyWithWhereWithoutUserInput | ListeningHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ListeningHistoryScalarWhereInput | ListeningHistoryScalarWhereInput[]
  }

  export type RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecentlyPlayedCreateWithoutUserInput, RecentlyPlayedUncheckedCreateWithoutUserInput> | RecentlyPlayedCreateWithoutUserInput[] | RecentlyPlayedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecentlyPlayedCreateOrConnectWithoutUserInput | RecentlyPlayedCreateOrConnectWithoutUserInput[]
    upsert?: RecentlyPlayedUpsertWithWhereUniqueWithoutUserInput | RecentlyPlayedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecentlyPlayedCreateManyUserInputEnvelope
    set?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    disconnect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    delete?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    connect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    update?: RecentlyPlayedUpdateWithWhereUniqueWithoutUserInput | RecentlyPlayedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecentlyPlayedUpdateManyWithWhereWithoutUserInput | RecentlyPlayedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecentlyPlayedScalarWhereInput | RecentlyPlayedScalarWhereInput[]
  }

  export type PlaybackStateUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PlaybackStateCreateWithoutUserInput, PlaybackStateUncheckedCreateWithoutUserInput>
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutUserInput
    upsert?: PlaybackStateUpsertWithoutUserInput
    disconnect?: PlaybackStateWhereInput | boolean
    delete?: PlaybackStateWhereInput | boolean
    connect?: PlaybackStateWhereUniqueInput
    update?: XOR<XOR<PlaybackStateUpdateToOneWithWhereWithoutUserInput, PlaybackStateUpdateWithoutUserInput>, PlaybackStateUncheckedUpdateWithoutUserInput>
  }

  export type PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaybackQueueCreateWithoutUserInput, PlaybackQueueUncheckedCreateWithoutUserInput> | PlaybackQueueCreateWithoutUserInput[] | PlaybackQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaybackQueueCreateOrConnectWithoutUserInput | PlaybackQueueCreateOrConnectWithoutUserInput[]
    upsert?: PlaybackQueueUpsertWithWhereUniqueWithoutUserInput | PlaybackQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaybackQueueCreateManyUserInputEnvelope
    set?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    disconnect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    delete?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    connect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    update?: PlaybackQueueUpdateWithWhereUniqueWithoutUserInput | PlaybackQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaybackQueueUpdateManyWithWhereWithoutUserInput | PlaybackQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaybackQueueScalarWhereInput | PlaybackQueueScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutUserInput | UserSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutUserInput | UserSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutUserInput | UserSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type AdImpressionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdImpressionCreateWithoutUserInput, AdImpressionUncheckedCreateWithoutUserInput> | AdImpressionCreateWithoutUserInput[] | AdImpressionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutUserInput | AdImpressionCreateOrConnectWithoutUserInput[]
    upsert?: AdImpressionUpsertWithWhereUniqueWithoutUserInput | AdImpressionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdImpressionCreateManyUserInputEnvelope
    set?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    disconnect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    delete?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    update?: AdImpressionUpdateWithWhereUniqueWithoutUserInput | AdImpressionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdImpressionUpdateManyWithWhereWithoutUserInput | AdImpressionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdImpressionScalarWhereInput | AdImpressionScalarWhereInput[]
  }

  export type UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAdSettingsCreateWithoutUserInput, UserAdSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAdSettingsCreateOrConnectWithoutUserInput
    upsert?: UserAdSettingsUpsertWithoutUserInput
    disconnect?: UserAdSettingsWhereInput | boolean
    delete?: UserAdSettingsWhereInput | boolean
    connect?: UserAdSettingsWhereUniqueInput
    update?: XOR<XOR<UserAdSettingsUpdateToOneWithWhereWithoutUserInput, UserAdSettingsUpdateWithoutUserInput>, UserAdSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutArtistInput = {
    create?: XOR<UserCreateWithoutArtistInput, UserUncheckedCreateWithoutArtistInput>
    connectOrCreate?: UserCreateOrConnectWithoutArtistInput
    connect?: UserWhereUniqueInput
  }

  export type AlbumCreateNestedManyWithoutArtistInput = {
    create?: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput> | AlbumCreateWithoutArtistInput[] | AlbumUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutArtistInput | AlbumCreateOrConnectWithoutArtistInput[]
    createMany?: AlbumCreateManyArtistInputEnvelope
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
  }

  export type SongCreateNestedManyWithoutPrimaryArtistInput = {
    create?: XOR<SongCreateWithoutPrimaryArtistInput, SongUncheckedCreateWithoutPrimaryArtistInput> | SongCreateWithoutPrimaryArtistInput[] | SongUncheckedCreateWithoutPrimaryArtistInput[]
    connectOrCreate?: SongCreateOrConnectWithoutPrimaryArtistInput | SongCreateOrConnectWithoutPrimaryArtistInput[]
    createMany?: SongCreateManyPrimaryArtistInputEnvelope
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
  }

  export type SongArtistCreateNestedManyWithoutArtistInput = {
    create?: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput> | SongArtistCreateWithoutArtistInput[] | SongArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutArtistInput | SongArtistCreateOrConnectWithoutArtistInput[]
    createMany?: SongArtistCreateManyArtistInputEnvelope
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
  }

  export type ArtistGenreCreateNestedManyWithoutArtistInput = {
    create?: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput> | ArtistGenreCreateWithoutArtistInput[] | ArtistGenreUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutArtistInput | ArtistGenreCreateOrConnectWithoutArtistInput[]
    createMany?: ArtistGenreCreateManyArtistInputEnvelope
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
  }

  export type AlbumUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput> | AlbumCreateWithoutArtistInput[] | AlbumUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutArtistInput | AlbumCreateOrConnectWithoutArtistInput[]
    createMany?: AlbumCreateManyArtistInputEnvelope
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
  }

  export type SongUncheckedCreateNestedManyWithoutPrimaryArtistInput = {
    create?: XOR<SongCreateWithoutPrimaryArtistInput, SongUncheckedCreateWithoutPrimaryArtistInput> | SongCreateWithoutPrimaryArtistInput[] | SongUncheckedCreateWithoutPrimaryArtistInput[]
    connectOrCreate?: SongCreateOrConnectWithoutPrimaryArtistInput | SongCreateOrConnectWithoutPrimaryArtistInput[]
    createMany?: SongCreateManyPrimaryArtistInputEnvelope
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
  }

  export type SongArtistUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput> | SongArtistCreateWithoutArtistInput[] | SongArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutArtistInput | SongArtistCreateOrConnectWithoutArtistInput[]
    createMany?: SongArtistCreateManyArtistInputEnvelope
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
  }

  export type ArtistGenreUncheckedCreateNestedManyWithoutArtistInput = {
    create?: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput> | ArtistGenreCreateWithoutArtistInput[] | ArtistGenreUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutArtistInput | ArtistGenreCreateOrConnectWithoutArtistInput[]
    createMany?: ArtistGenreCreateManyArtistInputEnvelope
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutArtistNestedInput = {
    create?: XOR<UserCreateWithoutArtistInput, UserUncheckedCreateWithoutArtistInput>
    connectOrCreate?: UserCreateOrConnectWithoutArtistInput
    upsert?: UserUpsertWithoutArtistInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArtistInput, UserUpdateWithoutArtistInput>, UserUncheckedUpdateWithoutArtistInput>
  }

  export type AlbumUpdateManyWithoutArtistNestedInput = {
    create?: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput> | AlbumCreateWithoutArtistInput[] | AlbumUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutArtistInput | AlbumCreateOrConnectWithoutArtistInput[]
    upsert?: AlbumUpsertWithWhereUniqueWithoutArtistInput | AlbumUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: AlbumCreateManyArtistInputEnvelope
    set?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    disconnect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    delete?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    update?: AlbumUpdateWithWhereUniqueWithoutArtistInput | AlbumUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: AlbumUpdateManyWithWhereWithoutArtistInput | AlbumUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
  }

  export type SongUpdateManyWithoutPrimaryArtistNestedInput = {
    create?: XOR<SongCreateWithoutPrimaryArtistInput, SongUncheckedCreateWithoutPrimaryArtistInput> | SongCreateWithoutPrimaryArtistInput[] | SongUncheckedCreateWithoutPrimaryArtistInput[]
    connectOrCreate?: SongCreateOrConnectWithoutPrimaryArtistInput | SongCreateOrConnectWithoutPrimaryArtistInput[]
    upsert?: SongUpsertWithWhereUniqueWithoutPrimaryArtistInput | SongUpsertWithWhereUniqueWithoutPrimaryArtistInput[]
    createMany?: SongCreateManyPrimaryArtistInputEnvelope
    set?: SongWhereUniqueInput | SongWhereUniqueInput[]
    disconnect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    delete?: SongWhereUniqueInput | SongWhereUniqueInput[]
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    update?: SongUpdateWithWhereUniqueWithoutPrimaryArtistInput | SongUpdateWithWhereUniqueWithoutPrimaryArtistInput[]
    updateMany?: SongUpdateManyWithWhereWithoutPrimaryArtistInput | SongUpdateManyWithWhereWithoutPrimaryArtistInput[]
    deleteMany?: SongScalarWhereInput | SongScalarWhereInput[]
  }

  export type SongArtistUpdateManyWithoutArtistNestedInput = {
    create?: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput> | SongArtistCreateWithoutArtistInput[] | SongArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutArtistInput | SongArtistCreateOrConnectWithoutArtistInput[]
    upsert?: SongArtistUpsertWithWhereUniqueWithoutArtistInput | SongArtistUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: SongArtistCreateManyArtistInputEnvelope
    set?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    disconnect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    delete?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    update?: SongArtistUpdateWithWhereUniqueWithoutArtistInput | SongArtistUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: SongArtistUpdateManyWithWhereWithoutArtistInput | SongArtistUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
  }

  export type ArtistGenreUpdateManyWithoutArtistNestedInput = {
    create?: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput> | ArtistGenreCreateWithoutArtistInput[] | ArtistGenreUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutArtistInput | ArtistGenreCreateOrConnectWithoutArtistInput[]
    upsert?: ArtistGenreUpsertWithWhereUniqueWithoutArtistInput | ArtistGenreUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: ArtistGenreCreateManyArtistInputEnvelope
    set?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    disconnect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    delete?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    update?: ArtistGenreUpdateWithWhereUniqueWithoutArtistInput | ArtistGenreUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: ArtistGenreUpdateManyWithWhereWithoutArtistInput | ArtistGenreUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
  }

  export type AlbumUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput> | AlbumCreateWithoutArtistInput[] | AlbumUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutArtistInput | AlbumCreateOrConnectWithoutArtistInput[]
    upsert?: AlbumUpsertWithWhereUniqueWithoutArtistInput | AlbumUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: AlbumCreateManyArtistInputEnvelope
    set?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    disconnect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    delete?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    update?: AlbumUpdateWithWhereUniqueWithoutArtistInput | AlbumUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: AlbumUpdateManyWithWhereWithoutArtistInput | AlbumUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
  }

  export type SongUncheckedUpdateManyWithoutPrimaryArtistNestedInput = {
    create?: XOR<SongCreateWithoutPrimaryArtistInput, SongUncheckedCreateWithoutPrimaryArtistInput> | SongCreateWithoutPrimaryArtistInput[] | SongUncheckedCreateWithoutPrimaryArtistInput[]
    connectOrCreate?: SongCreateOrConnectWithoutPrimaryArtistInput | SongCreateOrConnectWithoutPrimaryArtistInput[]
    upsert?: SongUpsertWithWhereUniqueWithoutPrimaryArtistInput | SongUpsertWithWhereUniqueWithoutPrimaryArtistInput[]
    createMany?: SongCreateManyPrimaryArtistInputEnvelope
    set?: SongWhereUniqueInput | SongWhereUniqueInput[]
    disconnect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    delete?: SongWhereUniqueInput | SongWhereUniqueInput[]
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    update?: SongUpdateWithWhereUniqueWithoutPrimaryArtistInput | SongUpdateWithWhereUniqueWithoutPrimaryArtistInput[]
    updateMany?: SongUpdateManyWithWhereWithoutPrimaryArtistInput | SongUpdateManyWithWhereWithoutPrimaryArtistInput[]
    deleteMany?: SongScalarWhereInput | SongScalarWhereInput[]
  }

  export type SongArtistUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput> | SongArtistCreateWithoutArtistInput[] | SongArtistUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutArtistInput | SongArtistCreateOrConnectWithoutArtistInput[]
    upsert?: SongArtistUpsertWithWhereUniqueWithoutArtistInput | SongArtistUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: SongArtistCreateManyArtistInputEnvelope
    set?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    disconnect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    delete?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    update?: SongArtistUpdateWithWhereUniqueWithoutArtistInput | SongArtistUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: SongArtistUpdateManyWithWhereWithoutArtistInput | SongArtistUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
  }

  export type ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput = {
    create?: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput> | ArtistGenreCreateWithoutArtistInput[] | ArtistGenreUncheckedCreateWithoutArtistInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutArtistInput | ArtistGenreCreateOrConnectWithoutArtistInput[]
    upsert?: ArtistGenreUpsertWithWhereUniqueWithoutArtistInput | ArtistGenreUpsertWithWhereUniqueWithoutArtistInput[]
    createMany?: ArtistGenreCreateManyArtistInputEnvelope
    set?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    disconnect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    delete?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    update?: ArtistGenreUpdateWithWhereUniqueWithoutArtistInput | ArtistGenreUpdateWithWhereUniqueWithoutArtistInput[]
    updateMany?: ArtistGenreUpdateManyWithWhereWithoutArtistInput | ArtistGenreUpdateManyWithWhereWithoutArtistInput[]
    deleteMany?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
  }

  export type ArtistCreateNestedOneWithoutAlbumsInput = {
    create?: XOR<ArtistCreateWithoutAlbumsInput, ArtistUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutAlbumsInput
    connect?: ArtistWhereUniqueInput
  }

  export type SongCreateNestedManyWithoutAlbumInput = {
    create?: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput> | SongCreateWithoutAlbumInput[] | SongUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: SongCreateOrConnectWithoutAlbumInput | SongCreateOrConnectWithoutAlbumInput[]
    createMany?: SongCreateManyAlbumInputEnvelope
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
  }

  export type SongUncheckedCreateNestedManyWithoutAlbumInput = {
    create?: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput> | SongCreateWithoutAlbumInput[] | SongUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: SongCreateOrConnectWithoutAlbumInput | SongCreateOrConnectWithoutAlbumInput[]
    createMany?: SongCreateManyAlbumInputEnvelope
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
  }

  export type EnumAlbumTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlbumType
  }

  export type ArtistUpdateOneRequiredWithoutAlbumsNestedInput = {
    create?: XOR<ArtistCreateWithoutAlbumsInput, ArtistUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutAlbumsInput
    upsert?: ArtistUpsertWithoutAlbumsInput
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutAlbumsInput, ArtistUpdateWithoutAlbumsInput>, ArtistUncheckedUpdateWithoutAlbumsInput>
  }

  export type SongUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput> | SongCreateWithoutAlbumInput[] | SongUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: SongCreateOrConnectWithoutAlbumInput | SongCreateOrConnectWithoutAlbumInput[]
    upsert?: SongUpsertWithWhereUniqueWithoutAlbumInput | SongUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: SongCreateManyAlbumInputEnvelope
    set?: SongWhereUniqueInput | SongWhereUniqueInput[]
    disconnect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    delete?: SongWhereUniqueInput | SongWhereUniqueInput[]
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    update?: SongUpdateWithWhereUniqueWithoutAlbumInput | SongUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: SongUpdateManyWithWhereWithoutAlbumInput | SongUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: SongScalarWhereInput | SongScalarWhereInput[]
  }

  export type SongUncheckedUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput> | SongCreateWithoutAlbumInput[] | SongUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: SongCreateOrConnectWithoutAlbumInput | SongCreateOrConnectWithoutAlbumInput[]
    upsert?: SongUpsertWithWhereUniqueWithoutAlbumInput | SongUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: SongCreateManyAlbumInputEnvelope
    set?: SongWhereUniqueInput | SongWhereUniqueInput[]
    disconnect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    delete?: SongWhereUniqueInput | SongWhereUniqueInput[]
    connect?: SongWhereUniqueInput | SongWhereUniqueInput[]
    update?: SongUpdateWithWhereUniqueWithoutAlbumInput | SongUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: SongUpdateManyWithWhereWithoutAlbumInput | SongUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: SongScalarWhereInput | SongScalarWhereInput[]
  }

  export type AlbumCreateNestedOneWithoutSongsInput = {
    create?: XOR<AlbumCreateWithoutSongsInput, AlbumUncheckedCreateWithoutSongsInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutSongsInput
    connect?: AlbumWhereUniqueInput
  }

  export type ArtistCreateNestedOneWithoutSongsInput = {
    create?: XOR<ArtistCreateWithoutSongsInput, ArtistUncheckedCreateWithoutSongsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutSongsInput
    connect?: ArtistWhereUniqueInput
  }

  export type SongArtistCreateNestedManyWithoutSongInput = {
    create?: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput> | SongArtistCreateWithoutSongInput[] | SongArtistUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutSongInput | SongArtistCreateOrConnectWithoutSongInput[]
    createMany?: SongArtistCreateManySongInputEnvelope
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
  }

  export type SongGenreCreateNestedManyWithoutSongInput = {
    create?: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput> | SongGenreCreateWithoutSongInput[] | SongGenreUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutSongInput | SongGenreCreateOrConnectWithoutSongInput[]
    createMany?: SongGenreCreateManySongInputEnvelope
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
  }

  export type PlaylistSongCreateNestedManyWithoutSongInput = {
    create?: XOR<PlaylistSongCreateWithoutSongInput, PlaylistSongUncheckedCreateWithoutSongInput> | PlaylistSongCreateWithoutSongInput[] | PlaylistSongUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaylistSongCreateOrConnectWithoutSongInput | PlaylistSongCreateOrConnectWithoutSongInput[]
    createMany?: PlaylistSongCreateManySongInputEnvelope
    connect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
  }

  export type ListeningHistoryCreateNestedManyWithoutSongInput = {
    create?: XOR<ListeningHistoryCreateWithoutSongInput, ListeningHistoryUncheckedCreateWithoutSongInput> | ListeningHistoryCreateWithoutSongInput[] | ListeningHistoryUncheckedCreateWithoutSongInput[]
    connectOrCreate?: ListeningHistoryCreateOrConnectWithoutSongInput | ListeningHistoryCreateOrConnectWithoutSongInput[]
    createMany?: ListeningHistoryCreateManySongInputEnvelope
    connect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
  }

  export type RecentlyPlayedCreateNestedManyWithoutSongInput = {
    create?: XOR<RecentlyPlayedCreateWithoutSongInput, RecentlyPlayedUncheckedCreateWithoutSongInput> | RecentlyPlayedCreateWithoutSongInput[] | RecentlyPlayedUncheckedCreateWithoutSongInput[]
    connectOrCreate?: RecentlyPlayedCreateOrConnectWithoutSongInput | RecentlyPlayedCreateOrConnectWithoutSongInput[]
    createMany?: RecentlyPlayedCreateManySongInputEnvelope
    connect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
  }

  export type PlaybackStateCreateNestedManyWithoutCurrentSongInput = {
    create?: XOR<PlaybackStateCreateWithoutCurrentSongInput, PlaybackStateUncheckedCreateWithoutCurrentSongInput> | PlaybackStateCreateWithoutCurrentSongInput[] | PlaybackStateUncheckedCreateWithoutCurrentSongInput[]
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutCurrentSongInput | PlaybackStateCreateOrConnectWithoutCurrentSongInput[]
    createMany?: PlaybackStateCreateManyCurrentSongInputEnvelope
    connect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
  }

  export type PlaybackQueueCreateNestedManyWithoutSongInput = {
    create?: XOR<PlaybackQueueCreateWithoutSongInput, PlaybackQueueUncheckedCreateWithoutSongInput> | PlaybackQueueCreateWithoutSongInput[] | PlaybackQueueUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaybackQueueCreateOrConnectWithoutSongInput | PlaybackQueueCreateOrConnectWithoutSongInput[]
    createMany?: PlaybackQueueCreateManySongInputEnvelope
    connect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
  }

  export type SongArtistUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput> | SongArtistCreateWithoutSongInput[] | SongArtistUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutSongInput | SongArtistCreateOrConnectWithoutSongInput[]
    createMany?: SongArtistCreateManySongInputEnvelope
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
  }

  export type SongGenreUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput> | SongGenreCreateWithoutSongInput[] | SongGenreUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutSongInput | SongGenreCreateOrConnectWithoutSongInput[]
    createMany?: SongGenreCreateManySongInputEnvelope
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
  }

  export type PlaylistSongUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<PlaylistSongCreateWithoutSongInput, PlaylistSongUncheckedCreateWithoutSongInput> | PlaylistSongCreateWithoutSongInput[] | PlaylistSongUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaylistSongCreateOrConnectWithoutSongInput | PlaylistSongCreateOrConnectWithoutSongInput[]
    createMany?: PlaylistSongCreateManySongInputEnvelope
    connect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
  }

  export type ListeningHistoryUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<ListeningHistoryCreateWithoutSongInput, ListeningHistoryUncheckedCreateWithoutSongInput> | ListeningHistoryCreateWithoutSongInput[] | ListeningHistoryUncheckedCreateWithoutSongInput[]
    connectOrCreate?: ListeningHistoryCreateOrConnectWithoutSongInput | ListeningHistoryCreateOrConnectWithoutSongInput[]
    createMany?: ListeningHistoryCreateManySongInputEnvelope
    connect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
  }

  export type RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<RecentlyPlayedCreateWithoutSongInput, RecentlyPlayedUncheckedCreateWithoutSongInput> | RecentlyPlayedCreateWithoutSongInput[] | RecentlyPlayedUncheckedCreateWithoutSongInput[]
    connectOrCreate?: RecentlyPlayedCreateOrConnectWithoutSongInput | RecentlyPlayedCreateOrConnectWithoutSongInput[]
    createMany?: RecentlyPlayedCreateManySongInputEnvelope
    connect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
  }

  export type PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput = {
    create?: XOR<PlaybackStateCreateWithoutCurrentSongInput, PlaybackStateUncheckedCreateWithoutCurrentSongInput> | PlaybackStateCreateWithoutCurrentSongInput[] | PlaybackStateUncheckedCreateWithoutCurrentSongInput[]
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutCurrentSongInput | PlaybackStateCreateOrConnectWithoutCurrentSongInput[]
    createMany?: PlaybackStateCreateManyCurrentSongInputEnvelope
    connect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
  }

  export type PlaybackQueueUncheckedCreateNestedManyWithoutSongInput = {
    create?: XOR<PlaybackQueueCreateWithoutSongInput, PlaybackQueueUncheckedCreateWithoutSongInput> | PlaybackQueueCreateWithoutSongInput[] | PlaybackQueueUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaybackQueueCreateOrConnectWithoutSongInput | PlaybackQueueCreateOrConnectWithoutSongInput[]
    createMany?: PlaybackQueueCreateManySongInputEnvelope
    connect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type AlbumUpdateOneWithoutSongsNestedInput = {
    create?: XOR<AlbumCreateWithoutSongsInput, AlbumUncheckedCreateWithoutSongsInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutSongsInput
    upsert?: AlbumUpsertWithoutSongsInput
    disconnect?: AlbumWhereInput | boolean
    delete?: AlbumWhereInput | boolean
    connect?: AlbumWhereUniqueInput
    update?: XOR<XOR<AlbumUpdateToOneWithWhereWithoutSongsInput, AlbumUpdateWithoutSongsInput>, AlbumUncheckedUpdateWithoutSongsInput>
  }

  export type ArtistUpdateOneRequiredWithoutSongsNestedInput = {
    create?: XOR<ArtistCreateWithoutSongsInput, ArtistUncheckedCreateWithoutSongsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutSongsInput
    upsert?: ArtistUpsertWithoutSongsInput
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutSongsInput, ArtistUpdateWithoutSongsInput>, ArtistUncheckedUpdateWithoutSongsInput>
  }

  export type SongArtistUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput> | SongArtistCreateWithoutSongInput[] | SongArtistUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutSongInput | SongArtistCreateOrConnectWithoutSongInput[]
    upsert?: SongArtistUpsertWithWhereUniqueWithoutSongInput | SongArtistUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongArtistCreateManySongInputEnvelope
    set?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    disconnect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    delete?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    update?: SongArtistUpdateWithWhereUniqueWithoutSongInput | SongArtistUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongArtistUpdateManyWithWhereWithoutSongInput | SongArtistUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
  }

  export type SongGenreUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput> | SongGenreCreateWithoutSongInput[] | SongGenreUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutSongInput | SongGenreCreateOrConnectWithoutSongInput[]
    upsert?: SongGenreUpsertWithWhereUniqueWithoutSongInput | SongGenreUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongGenreCreateManySongInputEnvelope
    set?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    disconnect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    delete?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    update?: SongGenreUpdateWithWhereUniqueWithoutSongInput | SongGenreUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongGenreUpdateManyWithWhereWithoutSongInput | SongGenreUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
  }

  export type PlaylistSongUpdateManyWithoutSongNestedInput = {
    create?: XOR<PlaylistSongCreateWithoutSongInput, PlaylistSongUncheckedCreateWithoutSongInput> | PlaylistSongCreateWithoutSongInput[] | PlaylistSongUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaylistSongCreateOrConnectWithoutSongInput | PlaylistSongCreateOrConnectWithoutSongInput[]
    upsert?: PlaylistSongUpsertWithWhereUniqueWithoutSongInput | PlaylistSongUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: PlaylistSongCreateManySongInputEnvelope
    set?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    disconnect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    delete?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    connect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    update?: PlaylistSongUpdateWithWhereUniqueWithoutSongInput | PlaylistSongUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: PlaylistSongUpdateManyWithWhereWithoutSongInput | PlaylistSongUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: PlaylistSongScalarWhereInput | PlaylistSongScalarWhereInput[]
  }

  export type ListeningHistoryUpdateManyWithoutSongNestedInput = {
    create?: XOR<ListeningHistoryCreateWithoutSongInput, ListeningHistoryUncheckedCreateWithoutSongInput> | ListeningHistoryCreateWithoutSongInput[] | ListeningHistoryUncheckedCreateWithoutSongInput[]
    connectOrCreate?: ListeningHistoryCreateOrConnectWithoutSongInput | ListeningHistoryCreateOrConnectWithoutSongInput[]
    upsert?: ListeningHistoryUpsertWithWhereUniqueWithoutSongInput | ListeningHistoryUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: ListeningHistoryCreateManySongInputEnvelope
    set?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    disconnect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    delete?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    connect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    update?: ListeningHistoryUpdateWithWhereUniqueWithoutSongInput | ListeningHistoryUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: ListeningHistoryUpdateManyWithWhereWithoutSongInput | ListeningHistoryUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: ListeningHistoryScalarWhereInput | ListeningHistoryScalarWhereInput[]
  }

  export type RecentlyPlayedUpdateManyWithoutSongNestedInput = {
    create?: XOR<RecentlyPlayedCreateWithoutSongInput, RecentlyPlayedUncheckedCreateWithoutSongInput> | RecentlyPlayedCreateWithoutSongInput[] | RecentlyPlayedUncheckedCreateWithoutSongInput[]
    connectOrCreate?: RecentlyPlayedCreateOrConnectWithoutSongInput | RecentlyPlayedCreateOrConnectWithoutSongInput[]
    upsert?: RecentlyPlayedUpsertWithWhereUniqueWithoutSongInput | RecentlyPlayedUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: RecentlyPlayedCreateManySongInputEnvelope
    set?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    disconnect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    delete?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    connect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    update?: RecentlyPlayedUpdateWithWhereUniqueWithoutSongInput | RecentlyPlayedUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: RecentlyPlayedUpdateManyWithWhereWithoutSongInput | RecentlyPlayedUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: RecentlyPlayedScalarWhereInput | RecentlyPlayedScalarWhereInput[]
  }

  export type PlaybackStateUpdateManyWithoutCurrentSongNestedInput = {
    create?: XOR<PlaybackStateCreateWithoutCurrentSongInput, PlaybackStateUncheckedCreateWithoutCurrentSongInput> | PlaybackStateCreateWithoutCurrentSongInput[] | PlaybackStateUncheckedCreateWithoutCurrentSongInput[]
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutCurrentSongInput | PlaybackStateCreateOrConnectWithoutCurrentSongInput[]
    upsert?: PlaybackStateUpsertWithWhereUniqueWithoutCurrentSongInput | PlaybackStateUpsertWithWhereUniqueWithoutCurrentSongInput[]
    createMany?: PlaybackStateCreateManyCurrentSongInputEnvelope
    set?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    disconnect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    delete?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    connect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    update?: PlaybackStateUpdateWithWhereUniqueWithoutCurrentSongInput | PlaybackStateUpdateWithWhereUniqueWithoutCurrentSongInput[]
    updateMany?: PlaybackStateUpdateManyWithWhereWithoutCurrentSongInput | PlaybackStateUpdateManyWithWhereWithoutCurrentSongInput[]
    deleteMany?: PlaybackStateScalarWhereInput | PlaybackStateScalarWhereInput[]
  }

  export type PlaybackQueueUpdateManyWithoutSongNestedInput = {
    create?: XOR<PlaybackQueueCreateWithoutSongInput, PlaybackQueueUncheckedCreateWithoutSongInput> | PlaybackQueueCreateWithoutSongInput[] | PlaybackQueueUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaybackQueueCreateOrConnectWithoutSongInput | PlaybackQueueCreateOrConnectWithoutSongInput[]
    upsert?: PlaybackQueueUpsertWithWhereUniqueWithoutSongInput | PlaybackQueueUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: PlaybackQueueCreateManySongInputEnvelope
    set?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    disconnect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    delete?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    connect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    update?: PlaybackQueueUpdateWithWhereUniqueWithoutSongInput | PlaybackQueueUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: PlaybackQueueUpdateManyWithWhereWithoutSongInput | PlaybackQueueUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: PlaybackQueueScalarWhereInput | PlaybackQueueScalarWhereInput[]
  }

  export type SongArtistUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput> | SongArtistCreateWithoutSongInput[] | SongArtistUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongArtistCreateOrConnectWithoutSongInput | SongArtistCreateOrConnectWithoutSongInput[]
    upsert?: SongArtistUpsertWithWhereUniqueWithoutSongInput | SongArtistUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongArtistCreateManySongInputEnvelope
    set?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    disconnect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    delete?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    connect?: SongArtistWhereUniqueInput | SongArtistWhereUniqueInput[]
    update?: SongArtistUpdateWithWhereUniqueWithoutSongInput | SongArtistUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongArtistUpdateManyWithWhereWithoutSongInput | SongArtistUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
  }

  export type SongGenreUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput> | SongGenreCreateWithoutSongInput[] | SongGenreUncheckedCreateWithoutSongInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutSongInput | SongGenreCreateOrConnectWithoutSongInput[]
    upsert?: SongGenreUpsertWithWhereUniqueWithoutSongInput | SongGenreUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: SongGenreCreateManySongInputEnvelope
    set?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    disconnect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    delete?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    update?: SongGenreUpdateWithWhereUniqueWithoutSongInput | SongGenreUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: SongGenreUpdateManyWithWhereWithoutSongInput | SongGenreUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
  }

  export type PlaylistSongUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<PlaylistSongCreateWithoutSongInput, PlaylistSongUncheckedCreateWithoutSongInput> | PlaylistSongCreateWithoutSongInput[] | PlaylistSongUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaylistSongCreateOrConnectWithoutSongInput | PlaylistSongCreateOrConnectWithoutSongInput[]
    upsert?: PlaylistSongUpsertWithWhereUniqueWithoutSongInput | PlaylistSongUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: PlaylistSongCreateManySongInputEnvelope
    set?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    disconnect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    delete?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    connect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    update?: PlaylistSongUpdateWithWhereUniqueWithoutSongInput | PlaylistSongUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: PlaylistSongUpdateManyWithWhereWithoutSongInput | PlaylistSongUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: PlaylistSongScalarWhereInput | PlaylistSongScalarWhereInput[]
  }

  export type ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<ListeningHistoryCreateWithoutSongInput, ListeningHistoryUncheckedCreateWithoutSongInput> | ListeningHistoryCreateWithoutSongInput[] | ListeningHistoryUncheckedCreateWithoutSongInput[]
    connectOrCreate?: ListeningHistoryCreateOrConnectWithoutSongInput | ListeningHistoryCreateOrConnectWithoutSongInput[]
    upsert?: ListeningHistoryUpsertWithWhereUniqueWithoutSongInput | ListeningHistoryUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: ListeningHistoryCreateManySongInputEnvelope
    set?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    disconnect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    delete?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    connect?: ListeningHistoryWhereUniqueInput | ListeningHistoryWhereUniqueInput[]
    update?: ListeningHistoryUpdateWithWhereUniqueWithoutSongInput | ListeningHistoryUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: ListeningHistoryUpdateManyWithWhereWithoutSongInput | ListeningHistoryUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: ListeningHistoryScalarWhereInput | ListeningHistoryScalarWhereInput[]
  }

  export type RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<RecentlyPlayedCreateWithoutSongInput, RecentlyPlayedUncheckedCreateWithoutSongInput> | RecentlyPlayedCreateWithoutSongInput[] | RecentlyPlayedUncheckedCreateWithoutSongInput[]
    connectOrCreate?: RecentlyPlayedCreateOrConnectWithoutSongInput | RecentlyPlayedCreateOrConnectWithoutSongInput[]
    upsert?: RecentlyPlayedUpsertWithWhereUniqueWithoutSongInput | RecentlyPlayedUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: RecentlyPlayedCreateManySongInputEnvelope
    set?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    disconnect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    delete?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    connect?: RecentlyPlayedWhereUniqueInput | RecentlyPlayedWhereUniqueInput[]
    update?: RecentlyPlayedUpdateWithWhereUniqueWithoutSongInput | RecentlyPlayedUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: RecentlyPlayedUpdateManyWithWhereWithoutSongInput | RecentlyPlayedUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: RecentlyPlayedScalarWhereInput | RecentlyPlayedScalarWhereInput[]
  }

  export type PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput = {
    create?: XOR<PlaybackStateCreateWithoutCurrentSongInput, PlaybackStateUncheckedCreateWithoutCurrentSongInput> | PlaybackStateCreateWithoutCurrentSongInput[] | PlaybackStateUncheckedCreateWithoutCurrentSongInput[]
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutCurrentSongInput | PlaybackStateCreateOrConnectWithoutCurrentSongInput[]
    upsert?: PlaybackStateUpsertWithWhereUniqueWithoutCurrentSongInput | PlaybackStateUpsertWithWhereUniqueWithoutCurrentSongInput[]
    createMany?: PlaybackStateCreateManyCurrentSongInputEnvelope
    set?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    disconnect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    delete?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    connect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    update?: PlaybackStateUpdateWithWhereUniqueWithoutCurrentSongInput | PlaybackStateUpdateWithWhereUniqueWithoutCurrentSongInput[]
    updateMany?: PlaybackStateUpdateManyWithWhereWithoutCurrentSongInput | PlaybackStateUpdateManyWithWhereWithoutCurrentSongInput[]
    deleteMany?: PlaybackStateScalarWhereInput | PlaybackStateScalarWhereInput[]
  }

  export type PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput = {
    create?: XOR<PlaybackQueueCreateWithoutSongInput, PlaybackQueueUncheckedCreateWithoutSongInput> | PlaybackQueueCreateWithoutSongInput[] | PlaybackQueueUncheckedCreateWithoutSongInput[]
    connectOrCreate?: PlaybackQueueCreateOrConnectWithoutSongInput | PlaybackQueueCreateOrConnectWithoutSongInput[]
    upsert?: PlaybackQueueUpsertWithWhereUniqueWithoutSongInput | PlaybackQueueUpsertWithWhereUniqueWithoutSongInput[]
    createMany?: PlaybackQueueCreateManySongInputEnvelope
    set?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    disconnect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    delete?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    connect?: PlaybackQueueWhereUniqueInput | PlaybackQueueWhereUniqueInput[]
    update?: PlaybackQueueUpdateWithWhereUniqueWithoutSongInput | PlaybackQueueUpdateWithWhereUniqueWithoutSongInput[]
    updateMany?: PlaybackQueueUpdateManyWithWhereWithoutSongInput | PlaybackQueueUpdateManyWithWhereWithoutSongInput[]
    deleteMany?: PlaybackQueueScalarWhereInput | PlaybackQueueScalarWhereInput[]
  }

  export type SongGenreCreateNestedManyWithoutGenreInput = {
    create?: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput> | SongGenreCreateWithoutGenreInput[] | SongGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutGenreInput | SongGenreCreateOrConnectWithoutGenreInput[]
    createMany?: SongGenreCreateManyGenreInputEnvelope
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
  }

  export type ArtistGenreCreateNestedManyWithoutGenreInput = {
    create?: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput> | ArtistGenreCreateWithoutGenreInput[] | ArtistGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutGenreInput | ArtistGenreCreateOrConnectWithoutGenreInput[]
    createMany?: ArtistGenreCreateManyGenreInputEnvelope
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
  }

  export type SongGenreUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput> | SongGenreCreateWithoutGenreInput[] | SongGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutGenreInput | SongGenreCreateOrConnectWithoutGenreInput[]
    createMany?: SongGenreCreateManyGenreInputEnvelope
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
  }

  export type ArtistGenreUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput> | ArtistGenreCreateWithoutGenreInput[] | ArtistGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutGenreInput | ArtistGenreCreateOrConnectWithoutGenreInput[]
    createMany?: ArtistGenreCreateManyGenreInputEnvelope
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
  }

  export type SongGenreUpdateManyWithoutGenreNestedInput = {
    create?: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput> | SongGenreCreateWithoutGenreInput[] | SongGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutGenreInput | SongGenreCreateOrConnectWithoutGenreInput[]
    upsert?: SongGenreUpsertWithWhereUniqueWithoutGenreInput | SongGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: SongGenreCreateManyGenreInputEnvelope
    set?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    disconnect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    delete?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    update?: SongGenreUpdateWithWhereUniqueWithoutGenreInput | SongGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: SongGenreUpdateManyWithWhereWithoutGenreInput | SongGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
  }

  export type ArtistGenreUpdateManyWithoutGenreNestedInput = {
    create?: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput> | ArtistGenreCreateWithoutGenreInput[] | ArtistGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutGenreInput | ArtistGenreCreateOrConnectWithoutGenreInput[]
    upsert?: ArtistGenreUpsertWithWhereUniqueWithoutGenreInput | ArtistGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: ArtistGenreCreateManyGenreInputEnvelope
    set?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    disconnect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    delete?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    update?: ArtistGenreUpdateWithWhereUniqueWithoutGenreInput | ArtistGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: ArtistGenreUpdateManyWithWhereWithoutGenreInput | ArtistGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
  }

  export type SongGenreUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput> | SongGenreCreateWithoutGenreInput[] | SongGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: SongGenreCreateOrConnectWithoutGenreInput | SongGenreCreateOrConnectWithoutGenreInput[]
    upsert?: SongGenreUpsertWithWhereUniqueWithoutGenreInput | SongGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: SongGenreCreateManyGenreInputEnvelope
    set?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    disconnect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    delete?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    connect?: SongGenreWhereUniqueInput | SongGenreWhereUniqueInput[]
    update?: SongGenreUpdateWithWhereUniqueWithoutGenreInput | SongGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: SongGenreUpdateManyWithWhereWithoutGenreInput | SongGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
  }

  export type ArtistGenreUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput> | ArtistGenreCreateWithoutGenreInput[] | ArtistGenreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: ArtistGenreCreateOrConnectWithoutGenreInput | ArtistGenreCreateOrConnectWithoutGenreInput[]
    upsert?: ArtistGenreUpsertWithWhereUniqueWithoutGenreInput | ArtistGenreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: ArtistGenreCreateManyGenreInputEnvelope
    set?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    disconnect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    delete?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    connect?: ArtistGenreWhereUniqueInput | ArtistGenreWhereUniqueInput[]
    update?: ArtistGenreUpdateWithWhereUniqueWithoutGenreInput | ArtistGenreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: ArtistGenreUpdateManyWithWhereWithoutGenreInput | ArtistGenreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
  }

  export type SongCreateNestedOneWithoutGenresInput = {
    create?: XOR<SongCreateWithoutGenresInput, SongUncheckedCreateWithoutGenresInput>
    connectOrCreate?: SongCreateOrConnectWithoutGenresInput
    connect?: SongWhereUniqueInput
  }

  export type GenreCreateNestedOneWithoutSongsInput = {
    create?: XOR<GenreCreateWithoutSongsInput, GenreUncheckedCreateWithoutSongsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutSongsInput
    connect?: GenreWhereUniqueInput
  }

  export type SongUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<SongCreateWithoutGenresInput, SongUncheckedCreateWithoutGenresInput>
    connectOrCreate?: SongCreateOrConnectWithoutGenresInput
    upsert?: SongUpsertWithoutGenresInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutGenresInput, SongUpdateWithoutGenresInput>, SongUncheckedUpdateWithoutGenresInput>
  }

  export type GenreUpdateOneRequiredWithoutSongsNestedInput = {
    create?: XOR<GenreCreateWithoutSongsInput, GenreUncheckedCreateWithoutSongsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutSongsInput
    upsert?: GenreUpsertWithoutSongsInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutSongsInput, GenreUpdateWithoutSongsInput>, GenreUncheckedUpdateWithoutSongsInput>
  }

  export type ArtistCreateNestedOneWithoutGenresInput = {
    create?: XOR<ArtistCreateWithoutGenresInput, ArtistUncheckedCreateWithoutGenresInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutGenresInput
    connect?: ArtistWhereUniqueInput
  }

  export type GenreCreateNestedOneWithoutArtistsInput = {
    create?: XOR<GenreCreateWithoutArtistsInput, GenreUncheckedCreateWithoutArtistsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutArtistsInput
    connect?: GenreWhereUniqueInput
  }

  export type ArtistUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<ArtistCreateWithoutGenresInput, ArtistUncheckedCreateWithoutGenresInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutGenresInput
    upsert?: ArtistUpsertWithoutGenresInput
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutGenresInput, ArtistUpdateWithoutGenresInput>, ArtistUncheckedUpdateWithoutGenresInput>
  }

  export type GenreUpdateOneRequiredWithoutArtistsNestedInput = {
    create?: XOR<GenreCreateWithoutArtistsInput, GenreUncheckedCreateWithoutArtistsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutArtistsInput
    upsert?: GenreUpsertWithoutArtistsInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutArtistsInput, GenreUpdateWithoutArtistsInput>, GenreUncheckedUpdateWithoutArtistsInput>
  }

  export type SongCreateNestedOneWithoutSongArtistsInput = {
    create?: XOR<SongCreateWithoutSongArtistsInput, SongUncheckedCreateWithoutSongArtistsInput>
    connectOrCreate?: SongCreateOrConnectWithoutSongArtistsInput
    connect?: SongWhereUniqueInput
  }

  export type ArtistCreateNestedOneWithoutSongArtistsInput = {
    create?: XOR<ArtistCreateWithoutSongArtistsInput, ArtistUncheckedCreateWithoutSongArtistsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutSongArtistsInput
    connect?: ArtistWhereUniqueInput
  }

  export type EnumArtistRoleFieldUpdateOperationsInput = {
    set?: $Enums.ArtistRole
  }

  export type SongUpdateOneRequiredWithoutSongArtistsNestedInput = {
    create?: XOR<SongCreateWithoutSongArtistsInput, SongUncheckedCreateWithoutSongArtistsInput>
    connectOrCreate?: SongCreateOrConnectWithoutSongArtistsInput
    upsert?: SongUpsertWithoutSongArtistsInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutSongArtistsInput, SongUpdateWithoutSongArtistsInput>, SongUncheckedUpdateWithoutSongArtistsInput>
  }

  export type ArtistUpdateOneRequiredWithoutSongArtistsNestedInput = {
    create?: XOR<ArtistCreateWithoutSongArtistsInput, ArtistUncheckedCreateWithoutSongArtistsInput>
    connectOrCreate?: ArtistCreateOrConnectWithoutSongArtistsInput
    upsert?: ArtistUpsertWithoutSongArtistsInput
    connect?: ArtistWhereUniqueInput
    update?: XOR<XOR<ArtistUpdateToOneWithWhereWithoutSongArtistsInput, ArtistUpdateWithoutSongArtistsInput>, ArtistUncheckedUpdateWithoutSongArtistsInput>
  }

  export type UserCreateNestedOneWithoutPlaylistsInput = {
    create?: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaylistsInput
    connect?: UserWhereUniqueInput
  }

  export type PlaylistSongCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistSongCreateWithoutPlaylistInput, PlaylistSongUncheckedCreateWithoutPlaylistInput> | PlaylistSongCreateWithoutPlaylistInput[] | PlaylistSongUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistSongCreateOrConnectWithoutPlaylistInput | PlaylistSongCreateOrConnectWithoutPlaylistInput[]
    createMany?: PlaylistSongCreateManyPlaylistInputEnvelope
    connect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
  }

  export type UserFollowCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<UserFollowCreateWithoutPlaylistInput, UserFollowUncheckedCreateWithoutPlaylistInput> | UserFollowCreateWithoutPlaylistInput[] | UserFollowUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutPlaylistInput | UserFollowCreateOrConnectWithoutPlaylistInput[]
    createMany?: UserFollowCreateManyPlaylistInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type PlaylistSongUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistSongCreateWithoutPlaylistInput, PlaylistSongUncheckedCreateWithoutPlaylistInput> | PlaylistSongCreateWithoutPlaylistInput[] | PlaylistSongUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistSongCreateOrConnectWithoutPlaylistInput | PlaylistSongCreateOrConnectWithoutPlaylistInput[]
    createMany?: PlaylistSongCreateManyPlaylistInputEnvelope
    connect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
  }

  export type UserFollowUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<UserFollowCreateWithoutPlaylistInput, UserFollowUncheckedCreateWithoutPlaylistInput> | UserFollowCreateWithoutPlaylistInput[] | UserFollowUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutPlaylistInput | UserFollowCreateOrConnectWithoutPlaylistInput[]
    createMany?: UserFollowCreateManyPlaylistInputEnvelope
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPlaylistsNestedInput = {
    create?: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaylistsInput
    upsert?: UserUpsertWithoutPlaylistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlaylistsInput, UserUpdateWithoutPlaylistsInput>, UserUncheckedUpdateWithoutPlaylistsInput>
  }

  export type PlaylistSongUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistSongCreateWithoutPlaylistInput, PlaylistSongUncheckedCreateWithoutPlaylistInput> | PlaylistSongCreateWithoutPlaylistInput[] | PlaylistSongUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistSongCreateOrConnectWithoutPlaylistInput | PlaylistSongCreateOrConnectWithoutPlaylistInput[]
    upsert?: PlaylistSongUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistSongUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: PlaylistSongCreateManyPlaylistInputEnvelope
    set?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    disconnect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    delete?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    connect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    update?: PlaylistSongUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistSongUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: PlaylistSongUpdateManyWithWhereWithoutPlaylistInput | PlaylistSongUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: PlaylistSongScalarWhereInput | PlaylistSongScalarWhereInput[]
  }

  export type UserFollowUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<UserFollowCreateWithoutPlaylistInput, UserFollowUncheckedCreateWithoutPlaylistInput> | UserFollowCreateWithoutPlaylistInput[] | UserFollowUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutPlaylistInput | UserFollowCreateOrConnectWithoutPlaylistInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutPlaylistInput | UserFollowUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: UserFollowCreateManyPlaylistInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutPlaylistInput | UserFollowUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutPlaylistInput | UserFollowUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type PlaylistSongUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistSongCreateWithoutPlaylistInput, PlaylistSongUncheckedCreateWithoutPlaylistInput> | PlaylistSongCreateWithoutPlaylistInput[] | PlaylistSongUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistSongCreateOrConnectWithoutPlaylistInput | PlaylistSongCreateOrConnectWithoutPlaylistInput[]
    upsert?: PlaylistSongUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistSongUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: PlaylistSongCreateManyPlaylistInputEnvelope
    set?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    disconnect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    delete?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    connect?: PlaylistSongWhereUniqueInput | PlaylistSongWhereUniqueInput[]
    update?: PlaylistSongUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistSongUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: PlaylistSongUpdateManyWithWhereWithoutPlaylistInput | PlaylistSongUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: PlaylistSongScalarWhereInput | PlaylistSongScalarWhereInput[]
  }

  export type UserFollowUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<UserFollowCreateWithoutPlaylistInput, UserFollowUncheckedCreateWithoutPlaylistInput> | UserFollowCreateWithoutPlaylistInput[] | UserFollowUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: UserFollowCreateOrConnectWithoutPlaylistInput | UserFollowCreateOrConnectWithoutPlaylistInput[]
    upsert?: UserFollowUpsertWithWhereUniqueWithoutPlaylistInput | UserFollowUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: UserFollowCreateManyPlaylistInputEnvelope
    set?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    disconnect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    delete?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    connect?: UserFollowWhereUniqueInput | UserFollowWhereUniqueInput[]
    update?: UserFollowUpdateWithWhereUniqueWithoutPlaylistInput | UserFollowUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: UserFollowUpdateManyWithWhereWithoutPlaylistInput | UserFollowUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
  }

  export type PlaylistCreateNestedOneWithoutSongsInput = {
    create?: XOR<PlaylistCreateWithoutSongsInput, PlaylistUncheckedCreateWithoutSongsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutSongsInput
    connect?: PlaylistWhereUniqueInput
  }

  export type SongCreateNestedOneWithoutPlaylistSongsInput = {
    create?: XOR<SongCreateWithoutPlaylistSongsInput, SongUncheckedCreateWithoutPlaylistSongsInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlaylistSongsInput
    connect?: SongWhereUniqueInput
  }

  export type PlaylistUpdateOneRequiredWithoutSongsNestedInput = {
    create?: XOR<PlaylistCreateWithoutSongsInput, PlaylistUncheckedCreateWithoutSongsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutSongsInput
    upsert?: PlaylistUpsertWithoutSongsInput
    connect?: PlaylistWhereUniqueInput
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutSongsInput, PlaylistUpdateWithoutSongsInput>, PlaylistUncheckedUpdateWithoutSongsInput>
  }

  export type SongUpdateOneRequiredWithoutPlaylistSongsNestedInput = {
    create?: XOR<SongCreateWithoutPlaylistSongsInput, SongUncheckedCreateWithoutPlaylistSongsInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlaylistSongsInput
    upsert?: SongUpsertWithoutPlaylistSongsInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutPlaylistSongsInput, SongUpdateWithoutPlaylistSongsInput>, SongUncheckedUpdateWithoutPlaylistSongsInput>
  }

  export type UserCreateNestedOneWithoutFollowsInput = {
    create?: XOR<UserCreateWithoutFollowsInput, UserUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowsInput
    connect?: UserWhereUniqueInput
  }

  export type PlaylistCreateNestedOneWithoutFollowersInput = {
    create?: XOR<PlaylistCreateWithoutFollowersInput, PlaylistUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutFollowersInput
    connect?: PlaylistWhereUniqueInput
  }

  export type EnumFollowTypeFieldUpdateOperationsInput = {
    set?: $Enums.FollowType
  }

  export type UserUpdateOneRequiredWithoutFollowsNestedInput = {
    create?: XOR<UserCreateWithoutFollowsInput, UserUncheckedCreateWithoutFollowsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowsInput
    upsert?: UserUpsertWithoutFollowsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowsInput, UserUpdateWithoutFollowsInput>, UserUncheckedUpdateWithoutFollowsInput>
  }

  export type PlaylistUpdateOneWithoutFollowersNestedInput = {
    create?: XOR<PlaylistCreateWithoutFollowersInput, PlaylistUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutFollowersInput
    upsert?: PlaylistUpsertWithoutFollowersInput
    disconnect?: PlaylistWhereInput | boolean
    delete?: PlaylistWhereInput | boolean
    connect?: PlaylistWhereUniqueInput
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutFollowersInput, PlaylistUpdateWithoutFollowersInput>, PlaylistUncheckedUpdateWithoutFollowersInput>
  }

  export type UserCreateNestedOneWithoutLibraryInput = {
    create?: XOR<UserCreateWithoutLibraryInput, UserUncheckedCreateWithoutLibraryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLibraryItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.LibraryItemType
  }

  export type UserUpdateOneRequiredWithoutLibraryNestedInput = {
    create?: XOR<UserCreateWithoutLibraryInput, UserUncheckedCreateWithoutLibraryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLibraryInput
    upsert?: UserUpsertWithoutLibraryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLibraryInput, UserUpdateWithoutLibraryInput>, UserUncheckedUpdateWithoutLibraryInput>
  }

  export type UserCreateNestedOneWithoutListeningHistoryInput = {
    create?: XOR<UserCreateWithoutListeningHistoryInput, UserUncheckedCreateWithoutListeningHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutListeningHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type SongCreateNestedOneWithoutListeningHistoryInput = {
    create?: XOR<SongCreateWithoutListeningHistoryInput, SongUncheckedCreateWithoutListeningHistoryInput>
    connectOrCreate?: SongCreateOrConnectWithoutListeningHistoryInput
    connect?: SongWhereUniqueInput
  }

  export type NullableEnumContextTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContextType | null
  }

  export type UserUpdateOneRequiredWithoutListeningHistoryNestedInput = {
    create?: XOR<UserCreateWithoutListeningHistoryInput, UserUncheckedCreateWithoutListeningHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutListeningHistoryInput
    upsert?: UserUpsertWithoutListeningHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListeningHistoryInput, UserUpdateWithoutListeningHistoryInput>, UserUncheckedUpdateWithoutListeningHistoryInput>
  }

  export type SongUpdateOneRequiredWithoutListeningHistoryNestedInput = {
    create?: XOR<SongCreateWithoutListeningHistoryInput, SongUncheckedCreateWithoutListeningHistoryInput>
    connectOrCreate?: SongCreateOrConnectWithoutListeningHistoryInput
    upsert?: SongUpsertWithoutListeningHistoryInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutListeningHistoryInput, SongUpdateWithoutListeningHistoryInput>, SongUncheckedUpdateWithoutListeningHistoryInput>
  }

  export type UserCreateNestedOneWithoutRecentlyPlayedInput = {
    create?: XOR<UserCreateWithoutRecentlyPlayedInput, UserUncheckedCreateWithoutRecentlyPlayedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecentlyPlayedInput
    connect?: UserWhereUniqueInput
  }

  export type SongCreateNestedOneWithoutRecentlyPlayedInput = {
    create?: XOR<SongCreateWithoutRecentlyPlayedInput, SongUncheckedCreateWithoutRecentlyPlayedInput>
    connectOrCreate?: SongCreateOrConnectWithoutRecentlyPlayedInput
    connect?: SongWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRecentlyPlayedNestedInput = {
    create?: XOR<UserCreateWithoutRecentlyPlayedInput, UserUncheckedCreateWithoutRecentlyPlayedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecentlyPlayedInput
    upsert?: UserUpsertWithoutRecentlyPlayedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecentlyPlayedInput, UserUpdateWithoutRecentlyPlayedInput>, UserUncheckedUpdateWithoutRecentlyPlayedInput>
  }

  export type SongUpdateOneRequiredWithoutRecentlyPlayedNestedInput = {
    create?: XOR<SongCreateWithoutRecentlyPlayedInput, SongUncheckedCreateWithoutRecentlyPlayedInput>
    connectOrCreate?: SongCreateOrConnectWithoutRecentlyPlayedInput
    upsert?: SongUpsertWithoutRecentlyPlayedInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutRecentlyPlayedInput, SongUpdateWithoutRecentlyPlayedInput>, SongUncheckedUpdateWithoutRecentlyPlayedInput>
  }

  export type UserCreateNestedOneWithoutPlaybackQueueInput = {
    create?: XOR<UserCreateWithoutPlaybackQueueInput, UserUncheckedCreateWithoutPlaybackQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaybackQueueInput
    connect?: UserWhereUniqueInput
  }

  export type SongCreateNestedOneWithoutPlaybackQueuesInput = {
    create?: XOR<SongCreateWithoutPlaybackQueuesInput, SongUncheckedCreateWithoutPlaybackQueuesInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlaybackQueuesInput
    connect?: SongWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlaybackQueueNestedInput = {
    create?: XOR<UserCreateWithoutPlaybackQueueInput, UserUncheckedCreateWithoutPlaybackQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaybackQueueInput
    upsert?: UserUpsertWithoutPlaybackQueueInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlaybackQueueInput, UserUpdateWithoutPlaybackQueueInput>, UserUncheckedUpdateWithoutPlaybackQueueInput>
  }

  export type SongUpdateOneRequiredWithoutPlaybackQueuesNestedInput = {
    create?: XOR<SongCreateWithoutPlaybackQueuesInput, SongUncheckedCreateWithoutPlaybackQueuesInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlaybackQueuesInput
    upsert?: SongUpsertWithoutPlaybackQueuesInput
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutPlaybackQueuesInput, SongUpdateWithoutPlaybackQueuesInput>, SongUncheckedUpdateWithoutPlaybackQueuesInput>
  }

  export type UserCreateNestedOneWithoutPlaybackStateInput = {
    create?: XOR<UserCreateWithoutPlaybackStateInput, UserUncheckedCreateWithoutPlaybackStateInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaybackStateInput
    connect?: UserWhereUniqueInput
  }

  export type SongCreateNestedOneWithoutPlaybackStatesInput = {
    create?: XOR<SongCreateWithoutPlaybackStatesInput, SongUncheckedCreateWithoutPlaybackStatesInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlaybackStatesInput
    connect?: SongWhereUniqueInput
  }

  export type UserDeviceCreateNestedOneWithoutPlaybackStatesInput = {
    create?: XOR<UserDeviceCreateWithoutPlaybackStatesInput, UserDeviceUncheckedCreateWithoutPlaybackStatesInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutPlaybackStatesInput
    connect?: UserDeviceWhereUniqueInput
  }

  export type EnumShuffleModeFieldUpdateOperationsInput = {
    set?: $Enums.ShuffleMode
  }

  export type EnumRepeatModeFieldUpdateOperationsInput = {
    set?: $Enums.RepeatMode
  }

  export type UserUpdateOneRequiredWithoutPlaybackStateNestedInput = {
    create?: XOR<UserCreateWithoutPlaybackStateInput, UserUncheckedCreateWithoutPlaybackStateInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaybackStateInput
    upsert?: UserUpsertWithoutPlaybackStateInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlaybackStateInput, UserUpdateWithoutPlaybackStateInput>, UserUncheckedUpdateWithoutPlaybackStateInput>
  }

  export type SongUpdateOneWithoutPlaybackStatesNestedInput = {
    create?: XOR<SongCreateWithoutPlaybackStatesInput, SongUncheckedCreateWithoutPlaybackStatesInput>
    connectOrCreate?: SongCreateOrConnectWithoutPlaybackStatesInput
    upsert?: SongUpsertWithoutPlaybackStatesInput
    disconnect?: SongWhereInput | boolean
    delete?: SongWhereInput | boolean
    connect?: SongWhereUniqueInput
    update?: XOR<XOR<SongUpdateToOneWithWhereWithoutPlaybackStatesInput, SongUpdateWithoutPlaybackStatesInput>, SongUncheckedUpdateWithoutPlaybackStatesInput>
  }

  export type UserDeviceUpdateOneWithoutPlaybackStatesNestedInput = {
    create?: XOR<UserDeviceCreateWithoutPlaybackStatesInput, UserDeviceUncheckedCreateWithoutPlaybackStatesInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutPlaybackStatesInput
    upsert?: UserDeviceUpsertWithoutPlaybackStatesInput
    disconnect?: UserDeviceWhereInput | boolean
    delete?: UserDeviceWhereInput | boolean
    connect?: UserDeviceWhereUniqueInput
    update?: XOR<XOR<UserDeviceUpdateToOneWithWhereWithoutPlaybackStatesInput, UserDeviceUpdateWithoutPlaybackStatesInput>, UserDeviceUncheckedUpdateWithoutPlaybackStatesInput>
  }

  export type UserCreateNestedOneWithoutOauthAccountsInput = {
    create?: XOR<UserCreateWithoutOauthAccountsInput, UserUncheckedCreateWithoutOauthAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOauthAccountsNestedInput = {
    create?: XOR<UserCreateWithoutOauthAccountsInput, UserUncheckedCreateWithoutOauthAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAccountsInput
    upsert?: UserUpsertWithoutOauthAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOauthAccountsInput, UserUpdateWithoutOauthAccountsInput>, UserUncheckedUpdateWithoutOauthAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserDeviceCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserDeviceCreateWithoutSessionsInput, UserDeviceUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutSessionsInput
    connect?: UserDeviceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserDeviceUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<UserDeviceCreateWithoutSessionsInput, UserDeviceUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutSessionsInput
    upsert?: UserDeviceUpsertWithoutSessionsInput
    disconnect?: UserDeviceWhereInput | boolean
    delete?: UserDeviceWhereInput | boolean
    connect?: UserDeviceWhereUniqueInput
    update?: XOR<XOR<UserDeviceUpdateToOneWithWhereWithoutSessionsInput, UserDeviceUpdateWithoutSessionsInput>, UserDeviceUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutDevicesInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    connect?: UserWhereUniqueInput
  }

  export type UserSessionCreateNestedManyWithoutDeviceInput = {
    create?: XOR<UserSessionCreateWithoutDeviceInput, UserSessionUncheckedCreateWithoutDeviceInput> | UserSessionCreateWithoutDeviceInput[] | UserSessionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutDeviceInput | UserSessionCreateOrConnectWithoutDeviceInput[]
    createMany?: UserSessionCreateManyDeviceInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type PlaybackStateCreateNestedManyWithoutActiveDeviceInput = {
    create?: XOR<PlaybackStateCreateWithoutActiveDeviceInput, PlaybackStateUncheckedCreateWithoutActiveDeviceInput> | PlaybackStateCreateWithoutActiveDeviceInput[] | PlaybackStateUncheckedCreateWithoutActiveDeviceInput[]
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutActiveDeviceInput | PlaybackStateCreateOrConnectWithoutActiveDeviceInput[]
    createMany?: PlaybackStateCreateManyActiveDeviceInputEnvelope
    connect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
  }

  export type DeviceSyncStateCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceSyncStateCreateWithoutDeviceInput, DeviceSyncStateUncheckedCreateWithoutDeviceInput> | DeviceSyncStateCreateWithoutDeviceInput[] | DeviceSyncStateUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceSyncStateCreateOrConnectWithoutDeviceInput | DeviceSyncStateCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceSyncStateCreateManyDeviceInputEnvelope
    connect?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
  }

  export type SyncLogCreateNestedManyWithoutSourceDeviceInput = {
    create?: XOR<SyncLogCreateWithoutSourceDeviceInput, SyncLogUncheckedCreateWithoutSourceDeviceInput> | SyncLogCreateWithoutSourceDeviceInput[] | SyncLogUncheckedCreateWithoutSourceDeviceInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutSourceDeviceInput | SyncLogCreateOrConnectWithoutSourceDeviceInput[]
    createMany?: SyncLogCreateManySourceDeviceInputEnvelope
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
  }

  export type DeviceTransferCreateNestedManyWithoutFromDeviceInput = {
    create?: XOR<DeviceTransferCreateWithoutFromDeviceInput, DeviceTransferUncheckedCreateWithoutFromDeviceInput> | DeviceTransferCreateWithoutFromDeviceInput[] | DeviceTransferUncheckedCreateWithoutFromDeviceInput[]
    connectOrCreate?: DeviceTransferCreateOrConnectWithoutFromDeviceInput | DeviceTransferCreateOrConnectWithoutFromDeviceInput[]
    createMany?: DeviceTransferCreateManyFromDeviceInputEnvelope
    connect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
  }

  export type DeviceTransferCreateNestedManyWithoutToDeviceInput = {
    create?: XOR<DeviceTransferCreateWithoutToDeviceInput, DeviceTransferUncheckedCreateWithoutToDeviceInput> | DeviceTransferCreateWithoutToDeviceInput[] | DeviceTransferUncheckedCreateWithoutToDeviceInput[]
    connectOrCreate?: DeviceTransferCreateOrConnectWithoutToDeviceInput | DeviceTransferCreateOrConnectWithoutToDeviceInput[]
    createMany?: DeviceTransferCreateManyToDeviceInputEnvelope
    connect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
  }

  export type AdImpressionCreateNestedManyWithoutDeviceInput = {
    create?: XOR<AdImpressionCreateWithoutDeviceInput, AdImpressionUncheckedCreateWithoutDeviceInput> | AdImpressionCreateWithoutDeviceInput[] | AdImpressionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutDeviceInput | AdImpressionCreateOrConnectWithoutDeviceInput[]
    createMany?: AdImpressionCreateManyDeviceInputEnvelope
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<UserSessionCreateWithoutDeviceInput, UserSessionUncheckedCreateWithoutDeviceInput> | UserSessionCreateWithoutDeviceInput[] | UserSessionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutDeviceInput | UserSessionCreateOrConnectWithoutDeviceInput[]
    createMany?: UserSessionCreateManyDeviceInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type PlaybackStateUncheckedCreateNestedManyWithoutActiveDeviceInput = {
    create?: XOR<PlaybackStateCreateWithoutActiveDeviceInput, PlaybackStateUncheckedCreateWithoutActiveDeviceInput> | PlaybackStateCreateWithoutActiveDeviceInput[] | PlaybackStateUncheckedCreateWithoutActiveDeviceInput[]
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutActiveDeviceInput | PlaybackStateCreateOrConnectWithoutActiveDeviceInput[]
    createMany?: PlaybackStateCreateManyActiveDeviceInputEnvelope
    connect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
  }

  export type DeviceSyncStateUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<DeviceSyncStateCreateWithoutDeviceInput, DeviceSyncStateUncheckedCreateWithoutDeviceInput> | DeviceSyncStateCreateWithoutDeviceInput[] | DeviceSyncStateUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceSyncStateCreateOrConnectWithoutDeviceInput | DeviceSyncStateCreateOrConnectWithoutDeviceInput[]
    createMany?: DeviceSyncStateCreateManyDeviceInputEnvelope
    connect?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
  }

  export type SyncLogUncheckedCreateNestedManyWithoutSourceDeviceInput = {
    create?: XOR<SyncLogCreateWithoutSourceDeviceInput, SyncLogUncheckedCreateWithoutSourceDeviceInput> | SyncLogCreateWithoutSourceDeviceInput[] | SyncLogUncheckedCreateWithoutSourceDeviceInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutSourceDeviceInput | SyncLogCreateOrConnectWithoutSourceDeviceInput[]
    createMany?: SyncLogCreateManySourceDeviceInputEnvelope
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
  }

  export type DeviceTransferUncheckedCreateNestedManyWithoutFromDeviceInput = {
    create?: XOR<DeviceTransferCreateWithoutFromDeviceInput, DeviceTransferUncheckedCreateWithoutFromDeviceInput> | DeviceTransferCreateWithoutFromDeviceInput[] | DeviceTransferUncheckedCreateWithoutFromDeviceInput[]
    connectOrCreate?: DeviceTransferCreateOrConnectWithoutFromDeviceInput | DeviceTransferCreateOrConnectWithoutFromDeviceInput[]
    createMany?: DeviceTransferCreateManyFromDeviceInputEnvelope
    connect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
  }

  export type DeviceTransferUncheckedCreateNestedManyWithoutToDeviceInput = {
    create?: XOR<DeviceTransferCreateWithoutToDeviceInput, DeviceTransferUncheckedCreateWithoutToDeviceInput> | DeviceTransferCreateWithoutToDeviceInput[] | DeviceTransferUncheckedCreateWithoutToDeviceInput[]
    connectOrCreate?: DeviceTransferCreateOrConnectWithoutToDeviceInput | DeviceTransferCreateOrConnectWithoutToDeviceInput[]
    createMany?: DeviceTransferCreateManyToDeviceInputEnvelope
    connect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
  }

  export type AdImpressionUncheckedCreateNestedManyWithoutDeviceInput = {
    create?: XOR<AdImpressionCreateWithoutDeviceInput, AdImpressionUncheckedCreateWithoutDeviceInput> | AdImpressionCreateWithoutDeviceInput[] | AdImpressionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutDeviceInput | AdImpressionCreateOrConnectWithoutDeviceInput[]
    createMany?: AdImpressionCreateManyDeviceInputEnvelope
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
  }

  export type EnumDeviceTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeviceType
  }

  export type UserUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    upsert?: UserUpsertWithoutDevicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDevicesInput, UserUpdateWithoutDevicesInput>, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserSessionUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<UserSessionCreateWithoutDeviceInput, UserSessionUncheckedCreateWithoutDeviceInput> | UserSessionCreateWithoutDeviceInput[] | UserSessionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutDeviceInput | UserSessionCreateOrConnectWithoutDeviceInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutDeviceInput | UserSessionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: UserSessionCreateManyDeviceInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutDeviceInput | UserSessionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutDeviceInput | UserSessionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type PlaybackStateUpdateManyWithoutActiveDeviceNestedInput = {
    create?: XOR<PlaybackStateCreateWithoutActiveDeviceInput, PlaybackStateUncheckedCreateWithoutActiveDeviceInput> | PlaybackStateCreateWithoutActiveDeviceInput[] | PlaybackStateUncheckedCreateWithoutActiveDeviceInput[]
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutActiveDeviceInput | PlaybackStateCreateOrConnectWithoutActiveDeviceInput[]
    upsert?: PlaybackStateUpsertWithWhereUniqueWithoutActiveDeviceInput | PlaybackStateUpsertWithWhereUniqueWithoutActiveDeviceInput[]
    createMany?: PlaybackStateCreateManyActiveDeviceInputEnvelope
    set?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    disconnect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    delete?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    connect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    update?: PlaybackStateUpdateWithWhereUniqueWithoutActiveDeviceInput | PlaybackStateUpdateWithWhereUniqueWithoutActiveDeviceInput[]
    updateMany?: PlaybackStateUpdateManyWithWhereWithoutActiveDeviceInput | PlaybackStateUpdateManyWithWhereWithoutActiveDeviceInput[]
    deleteMany?: PlaybackStateScalarWhereInput | PlaybackStateScalarWhereInput[]
  }

  export type DeviceSyncStateUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceSyncStateCreateWithoutDeviceInput, DeviceSyncStateUncheckedCreateWithoutDeviceInput> | DeviceSyncStateCreateWithoutDeviceInput[] | DeviceSyncStateUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceSyncStateCreateOrConnectWithoutDeviceInput | DeviceSyncStateCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceSyncStateUpsertWithWhereUniqueWithoutDeviceInput | DeviceSyncStateUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceSyncStateCreateManyDeviceInputEnvelope
    set?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
    disconnect?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
    delete?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
    connect?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
    update?: DeviceSyncStateUpdateWithWhereUniqueWithoutDeviceInput | DeviceSyncStateUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceSyncStateUpdateManyWithWhereWithoutDeviceInput | DeviceSyncStateUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceSyncStateScalarWhereInput | DeviceSyncStateScalarWhereInput[]
  }

  export type SyncLogUpdateManyWithoutSourceDeviceNestedInput = {
    create?: XOR<SyncLogCreateWithoutSourceDeviceInput, SyncLogUncheckedCreateWithoutSourceDeviceInput> | SyncLogCreateWithoutSourceDeviceInput[] | SyncLogUncheckedCreateWithoutSourceDeviceInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutSourceDeviceInput | SyncLogCreateOrConnectWithoutSourceDeviceInput[]
    upsert?: SyncLogUpsertWithWhereUniqueWithoutSourceDeviceInput | SyncLogUpsertWithWhereUniqueWithoutSourceDeviceInput[]
    createMany?: SyncLogCreateManySourceDeviceInputEnvelope
    set?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    disconnect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    delete?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    update?: SyncLogUpdateWithWhereUniqueWithoutSourceDeviceInput | SyncLogUpdateWithWhereUniqueWithoutSourceDeviceInput[]
    updateMany?: SyncLogUpdateManyWithWhereWithoutSourceDeviceInput | SyncLogUpdateManyWithWhereWithoutSourceDeviceInput[]
    deleteMany?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
  }

  export type DeviceTransferUpdateManyWithoutFromDeviceNestedInput = {
    create?: XOR<DeviceTransferCreateWithoutFromDeviceInput, DeviceTransferUncheckedCreateWithoutFromDeviceInput> | DeviceTransferCreateWithoutFromDeviceInput[] | DeviceTransferUncheckedCreateWithoutFromDeviceInput[]
    connectOrCreate?: DeviceTransferCreateOrConnectWithoutFromDeviceInput | DeviceTransferCreateOrConnectWithoutFromDeviceInput[]
    upsert?: DeviceTransferUpsertWithWhereUniqueWithoutFromDeviceInput | DeviceTransferUpsertWithWhereUniqueWithoutFromDeviceInput[]
    createMany?: DeviceTransferCreateManyFromDeviceInputEnvelope
    set?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    disconnect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    delete?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    connect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    update?: DeviceTransferUpdateWithWhereUniqueWithoutFromDeviceInput | DeviceTransferUpdateWithWhereUniqueWithoutFromDeviceInput[]
    updateMany?: DeviceTransferUpdateManyWithWhereWithoutFromDeviceInput | DeviceTransferUpdateManyWithWhereWithoutFromDeviceInput[]
    deleteMany?: DeviceTransferScalarWhereInput | DeviceTransferScalarWhereInput[]
  }

  export type DeviceTransferUpdateManyWithoutToDeviceNestedInput = {
    create?: XOR<DeviceTransferCreateWithoutToDeviceInput, DeviceTransferUncheckedCreateWithoutToDeviceInput> | DeviceTransferCreateWithoutToDeviceInput[] | DeviceTransferUncheckedCreateWithoutToDeviceInput[]
    connectOrCreate?: DeviceTransferCreateOrConnectWithoutToDeviceInput | DeviceTransferCreateOrConnectWithoutToDeviceInput[]
    upsert?: DeviceTransferUpsertWithWhereUniqueWithoutToDeviceInput | DeviceTransferUpsertWithWhereUniqueWithoutToDeviceInput[]
    createMany?: DeviceTransferCreateManyToDeviceInputEnvelope
    set?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    disconnect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    delete?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    connect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    update?: DeviceTransferUpdateWithWhereUniqueWithoutToDeviceInput | DeviceTransferUpdateWithWhereUniqueWithoutToDeviceInput[]
    updateMany?: DeviceTransferUpdateManyWithWhereWithoutToDeviceInput | DeviceTransferUpdateManyWithWhereWithoutToDeviceInput[]
    deleteMany?: DeviceTransferScalarWhereInput | DeviceTransferScalarWhereInput[]
  }

  export type AdImpressionUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<AdImpressionCreateWithoutDeviceInput, AdImpressionUncheckedCreateWithoutDeviceInput> | AdImpressionCreateWithoutDeviceInput[] | AdImpressionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutDeviceInput | AdImpressionCreateOrConnectWithoutDeviceInput[]
    upsert?: AdImpressionUpsertWithWhereUniqueWithoutDeviceInput | AdImpressionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: AdImpressionCreateManyDeviceInputEnvelope
    set?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    disconnect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    delete?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    update?: AdImpressionUpdateWithWhereUniqueWithoutDeviceInput | AdImpressionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: AdImpressionUpdateManyWithWhereWithoutDeviceInput | AdImpressionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: AdImpressionScalarWhereInput | AdImpressionScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<UserSessionCreateWithoutDeviceInput, UserSessionUncheckedCreateWithoutDeviceInput> | UserSessionCreateWithoutDeviceInput[] | UserSessionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutDeviceInput | UserSessionCreateOrConnectWithoutDeviceInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutDeviceInput | UserSessionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: UserSessionCreateManyDeviceInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutDeviceInput | UserSessionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutDeviceInput | UserSessionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type PlaybackStateUncheckedUpdateManyWithoutActiveDeviceNestedInput = {
    create?: XOR<PlaybackStateCreateWithoutActiveDeviceInput, PlaybackStateUncheckedCreateWithoutActiveDeviceInput> | PlaybackStateCreateWithoutActiveDeviceInput[] | PlaybackStateUncheckedCreateWithoutActiveDeviceInput[]
    connectOrCreate?: PlaybackStateCreateOrConnectWithoutActiveDeviceInput | PlaybackStateCreateOrConnectWithoutActiveDeviceInput[]
    upsert?: PlaybackStateUpsertWithWhereUniqueWithoutActiveDeviceInput | PlaybackStateUpsertWithWhereUniqueWithoutActiveDeviceInput[]
    createMany?: PlaybackStateCreateManyActiveDeviceInputEnvelope
    set?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    disconnect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    delete?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    connect?: PlaybackStateWhereUniqueInput | PlaybackStateWhereUniqueInput[]
    update?: PlaybackStateUpdateWithWhereUniqueWithoutActiveDeviceInput | PlaybackStateUpdateWithWhereUniqueWithoutActiveDeviceInput[]
    updateMany?: PlaybackStateUpdateManyWithWhereWithoutActiveDeviceInput | PlaybackStateUpdateManyWithWhereWithoutActiveDeviceInput[]
    deleteMany?: PlaybackStateScalarWhereInput | PlaybackStateScalarWhereInput[]
  }

  export type DeviceSyncStateUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<DeviceSyncStateCreateWithoutDeviceInput, DeviceSyncStateUncheckedCreateWithoutDeviceInput> | DeviceSyncStateCreateWithoutDeviceInput[] | DeviceSyncStateUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: DeviceSyncStateCreateOrConnectWithoutDeviceInput | DeviceSyncStateCreateOrConnectWithoutDeviceInput[]
    upsert?: DeviceSyncStateUpsertWithWhereUniqueWithoutDeviceInput | DeviceSyncStateUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: DeviceSyncStateCreateManyDeviceInputEnvelope
    set?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
    disconnect?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
    delete?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
    connect?: DeviceSyncStateWhereUniqueInput | DeviceSyncStateWhereUniqueInput[]
    update?: DeviceSyncStateUpdateWithWhereUniqueWithoutDeviceInput | DeviceSyncStateUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: DeviceSyncStateUpdateManyWithWhereWithoutDeviceInput | DeviceSyncStateUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: DeviceSyncStateScalarWhereInput | DeviceSyncStateScalarWhereInput[]
  }

  export type SyncLogUncheckedUpdateManyWithoutSourceDeviceNestedInput = {
    create?: XOR<SyncLogCreateWithoutSourceDeviceInput, SyncLogUncheckedCreateWithoutSourceDeviceInput> | SyncLogCreateWithoutSourceDeviceInput[] | SyncLogUncheckedCreateWithoutSourceDeviceInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutSourceDeviceInput | SyncLogCreateOrConnectWithoutSourceDeviceInput[]
    upsert?: SyncLogUpsertWithWhereUniqueWithoutSourceDeviceInput | SyncLogUpsertWithWhereUniqueWithoutSourceDeviceInput[]
    createMany?: SyncLogCreateManySourceDeviceInputEnvelope
    set?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    disconnect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    delete?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    update?: SyncLogUpdateWithWhereUniqueWithoutSourceDeviceInput | SyncLogUpdateWithWhereUniqueWithoutSourceDeviceInput[]
    updateMany?: SyncLogUpdateManyWithWhereWithoutSourceDeviceInput | SyncLogUpdateManyWithWhereWithoutSourceDeviceInput[]
    deleteMany?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
  }

  export type DeviceTransferUncheckedUpdateManyWithoutFromDeviceNestedInput = {
    create?: XOR<DeviceTransferCreateWithoutFromDeviceInput, DeviceTransferUncheckedCreateWithoutFromDeviceInput> | DeviceTransferCreateWithoutFromDeviceInput[] | DeviceTransferUncheckedCreateWithoutFromDeviceInput[]
    connectOrCreate?: DeviceTransferCreateOrConnectWithoutFromDeviceInput | DeviceTransferCreateOrConnectWithoutFromDeviceInput[]
    upsert?: DeviceTransferUpsertWithWhereUniqueWithoutFromDeviceInput | DeviceTransferUpsertWithWhereUniqueWithoutFromDeviceInput[]
    createMany?: DeviceTransferCreateManyFromDeviceInputEnvelope
    set?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    disconnect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    delete?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    connect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    update?: DeviceTransferUpdateWithWhereUniqueWithoutFromDeviceInput | DeviceTransferUpdateWithWhereUniqueWithoutFromDeviceInput[]
    updateMany?: DeviceTransferUpdateManyWithWhereWithoutFromDeviceInput | DeviceTransferUpdateManyWithWhereWithoutFromDeviceInput[]
    deleteMany?: DeviceTransferScalarWhereInput | DeviceTransferScalarWhereInput[]
  }

  export type DeviceTransferUncheckedUpdateManyWithoutToDeviceNestedInput = {
    create?: XOR<DeviceTransferCreateWithoutToDeviceInput, DeviceTransferUncheckedCreateWithoutToDeviceInput> | DeviceTransferCreateWithoutToDeviceInput[] | DeviceTransferUncheckedCreateWithoutToDeviceInput[]
    connectOrCreate?: DeviceTransferCreateOrConnectWithoutToDeviceInput | DeviceTransferCreateOrConnectWithoutToDeviceInput[]
    upsert?: DeviceTransferUpsertWithWhereUniqueWithoutToDeviceInput | DeviceTransferUpsertWithWhereUniqueWithoutToDeviceInput[]
    createMany?: DeviceTransferCreateManyToDeviceInputEnvelope
    set?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    disconnect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    delete?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    connect?: DeviceTransferWhereUniqueInput | DeviceTransferWhereUniqueInput[]
    update?: DeviceTransferUpdateWithWhereUniqueWithoutToDeviceInput | DeviceTransferUpdateWithWhereUniqueWithoutToDeviceInput[]
    updateMany?: DeviceTransferUpdateManyWithWhereWithoutToDeviceInput | DeviceTransferUpdateManyWithWhereWithoutToDeviceInput[]
    deleteMany?: DeviceTransferScalarWhereInput | DeviceTransferScalarWhereInput[]
  }

  export type AdImpressionUncheckedUpdateManyWithoutDeviceNestedInput = {
    create?: XOR<AdImpressionCreateWithoutDeviceInput, AdImpressionUncheckedCreateWithoutDeviceInput> | AdImpressionCreateWithoutDeviceInput[] | AdImpressionUncheckedCreateWithoutDeviceInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutDeviceInput | AdImpressionCreateOrConnectWithoutDeviceInput[]
    upsert?: AdImpressionUpsertWithWhereUniqueWithoutDeviceInput | AdImpressionUpsertWithWhereUniqueWithoutDeviceInput[]
    createMany?: AdImpressionCreateManyDeviceInputEnvelope
    set?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    disconnect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    delete?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    update?: AdImpressionUpdateWithWhereUniqueWithoutDeviceInput | AdImpressionUpdateWithWhereUniqueWithoutDeviceInput[]
    updateMany?: AdImpressionUpdateManyWithWhereWithoutDeviceInput | AdImpressionUpdateManyWithWhereWithoutDeviceInput[]
    deleteMany?: AdImpressionScalarWhereInput | AdImpressionScalarWhereInput[]
  }

  export type UserDeviceCreateNestedOneWithoutSyncStatesInput = {
    create?: XOR<UserDeviceCreateWithoutSyncStatesInput, UserDeviceUncheckedCreateWithoutSyncStatesInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutSyncStatesInput
    connect?: UserDeviceWhereUniqueInput
  }

  export type EnumSyncTypeFieldUpdateOperationsInput = {
    set?: $Enums.SyncType
  }

  export type UserDeviceUpdateOneRequiredWithoutSyncStatesNestedInput = {
    create?: XOR<UserDeviceCreateWithoutSyncStatesInput, UserDeviceUncheckedCreateWithoutSyncStatesInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutSyncStatesInput
    upsert?: UserDeviceUpsertWithoutSyncStatesInput
    connect?: UserDeviceWhereUniqueInput
    update?: XOR<XOR<UserDeviceUpdateToOneWithWhereWithoutSyncStatesInput, UserDeviceUpdateWithoutSyncStatesInput>, UserDeviceUncheckedUpdateWithoutSyncStatesInput>
  }

  export type UserDeviceCreateNestedOneWithoutSyncLogsInput = {
    create?: XOR<UserDeviceCreateWithoutSyncLogsInput, UserDeviceUncheckedCreateWithoutSyncLogsInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutSyncLogsInput
    connect?: UserDeviceWhereUniqueInput
  }

  export type EnumSyncActionFieldUpdateOperationsInput = {
    set?: $Enums.SyncAction
  }

  export type UserDeviceUpdateOneWithoutSyncLogsNestedInput = {
    create?: XOR<UserDeviceCreateWithoutSyncLogsInput, UserDeviceUncheckedCreateWithoutSyncLogsInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutSyncLogsInput
    upsert?: UserDeviceUpsertWithoutSyncLogsInput
    disconnect?: UserDeviceWhereInput | boolean
    delete?: UserDeviceWhereInput | boolean
    connect?: UserDeviceWhereUniqueInput
    update?: XOR<XOR<UserDeviceUpdateToOneWithWhereWithoutSyncLogsInput, UserDeviceUpdateWithoutSyncLogsInput>, UserDeviceUncheckedUpdateWithoutSyncLogsInput>
  }

  export type UserDeviceCreateNestedOneWithoutTransfersFromInput = {
    create?: XOR<UserDeviceCreateWithoutTransfersFromInput, UserDeviceUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutTransfersFromInput
    connect?: UserDeviceWhereUniqueInput
  }

  export type UserDeviceCreateNestedOneWithoutTransfersToInput = {
    create?: XOR<UserDeviceCreateWithoutTransfersToInput, UserDeviceUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutTransfersToInput
    connect?: UserDeviceWhereUniqueInput
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus
  }

  export type UserDeviceUpdateOneRequiredWithoutTransfersFromNestedInput = {
    create?: XOR<UserDeviceCreateWithoutTransfersFromInput, UserDeviceUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutTransfersFromInput
    upsert?: UserDeviceUpsertWithoutTransfersFromInput
    connect?: UserDeviceWhereUniqueInput
    update?: XOR<XOR<UserDeviceUpdateToOneWithWhereWithoutTransfersFromInput, UserDeviceUpdateWithoutTransfersFromInput>, UserDeviceUncheckedUpdateWithoutTransfersFromInput>
  }

  export type UserDeviceUpdateOneRequiredWithoutTransfersToNestedInput = {
    create?: XOR<UserDeviceCreateWithoutTransfersToInput, UserDeviceUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutTransfersToInput
    upsert?: UserDeviceUpsertWithoutTransfersToInput
    connect?: UserDeviceWhereUniqueInput
    update?: XOR<XOR<UserDeviceUpdateToOneWithWhereWithoutTransfersToInput, UserDeviceUpdateWithoutTransfersToInput>, UserDeviceUncheckedUpdateWithoutTransfersToInput>
  }

  export type UserSubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumAudioQualityFieldUpdateOperationsInput = {
    set?: $Enums.AudioQuality
  }

  export type UserSubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput | UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput | UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutPlanInput | UserSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput> | UserSubscriptionCreateWithoutPlanInput[] | UserSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutPlanInput | UserSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput | UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: UserSubscriptionCreateManyPlanInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput | UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutPlanInput | UserSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type EnumBillingCycleFieldUpdateOperationsInput = {
    set?: $Enums.BillingCycle
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: SubscriptionPlanUpsertWithoutSubscriptionsInput
    connect?: SubscriptionPlanWhereUniqueInput
    update?: XOR<XOR<SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput, SubscriptionPlanUpdateWithoutSubscriptionsInput>, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type AdvertisementCreatetargetCountriesInput = {
    set: string[]
  }

  export type AdvertisementCreatetargetGenresInput = {
    set: string[]
  }

  export type AdImpressionCreateNestedManyWithoutAdInput = {
    create?: XOR<AdImpressionCreateWithoutAdInput, AdImpressionUncheckedCreateWithoutAdInput> | AdImpressionCreateWithoutAdInput[] | AdImpressionUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutAdInput | AdImpressionCreateOrConnectWithoutAdInput[]
    createMany?: AdImpressionCreateManyAdInputEnvelope
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
  }

  export type AdImpressionUncheckedCreateNestedManyWithoutAdInput = {
    create?: XOR<AdImpressionCreateWithoutAdInput, AdImpressionUncheckedCreateWithoutAdInput> | AdImpressionCreateWithoutAdInput[] | AdImpressionUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutAdInput | AdImpressionCreateOrConnectWithoutAdInput[]
    createMany?: AdImpressionCreateManyAdInputEnvelope
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
  }

  export type EnumAdTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdType
  }

  export type AdvertisementUpdatetargetCountriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdvertisementUpdatetargetGenresInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AdImpressionUpdateManyWithoutAdNestedInput = {
    create?: XOR<AdImpressionCreateWithoutAdInput, AdImpressionUncheckedCreateWithoutAdInput> | AdImpressionCreateWithoutAdInput[] | AdImpressionUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutAdInput | AdImpressionCreateOrConnectWithoutAdInput[]
    upsert?: AdImpressionUpsertWithWhereUniqueWithoutAdInput | AdImpressionUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: AdImpressionCreateManyAdInputEnvelope
    set?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    disconnect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    delete?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    update?: AdImpressionUpdateWithWhereUniqueWithoutAdInput | AdImpressionUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: AdImpressionUpdateManyWithWhereWithoutAdInput | AdImpressionUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: AdImpressionScalarWhereInput | AdImpressionScalarWhereInput[]
  }

  export type AdImpressionUncheckedUpdateManyWithoutAdNestedInput = {
    create?: XOR<AdImpressionCreateWithoutAdInput, AdImpressionUncheckedCreateWithoutAdInput> | AdImpressionCreateWithoutAdInput[] | AdImpressionUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdImpressionCreateOrConnectWithoutAdInput | AdImpressionCreateOrConnectWithoutAdInput[]
    upsert?: AdImpressionUpsertWithWhereUniqueWithoutAdInput | AdImpressionUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: AdImpressionCreateManyAdInputEnvelope
    set?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    disconnect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    delete?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    connect?: AdImpressionWhereUniqueInput | AdImpressionWhereUniqueInput[]
    update?: AdImpressionUpdateWithWhereUniqueWithoutAdInput | AdImpressionUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: AdImpressionUpdateManyWithWhereWithoutAdInput | AdImpressionUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: AdImpressionScalarWhereInput | AdImpressionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdImpressionsInput = {
    create?: XOR<UserCreateWithoutAdImpressionsInput, UserUncheckedCreateWithoutAdImpressionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdImpressionsInput
    connect?: UserWhereUniqueInput
  }

  export type AdvertisementCreateNestedOneWithoutImpressionsInput = {
    create?: XOR<AdvertisementCreateWithoutImpressionsInput, AdvertisementUncheckedCreateWithoutImpressionsInput>
    connectOrCreate?: AdvertisementCreateOrConnectWithoutImpressionsInput
    connect?: AdvertisementWhereUniqueInput
  }

  export type UserDeviceCreateNestedOneWithoutAdImpressionsInput = {
    create?: XOR<UserDeviceCreateWithoutAdImpressionsInput, UserDeviceUncheckedCreateWithoutAdImpressionsInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutAdImpressionsInput
    connect?: UserDeviceWhereUniqueInput
  }

  export type EnumImpressionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ImpressionType
  }

  export type NullableEnumAdContextTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdContextType | null
  }

  export type UserUpdateOneRequiredWithoutAdImpressionsNestedInput = {
    create?: XOR<UserCreateWithoutAdImpressionsInput, UserUncheckedCreateWithoutAdImpressionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdImpressionsInput
    upsert?: UserUpsertWithoutAdImpressionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdImpressionsInput, UserUpdateWithoutAdImpressionsInput>, UserUncheckedUpdateWithoutAdImpressionsInput>
  }

  export type AdvertisementUpdateOneRequiredWithoutImpressionsNestedInput = {
    create?: XOR<AdvertisementCreateWithoutImpressionsInput, AdvertisementUncheckedCreateWithoutImpressionsInput>
    connectOrCreate?: AdvertisementCreateOrConnectWithoutImpressionsInput
    upsert?: AdvertisementUpsertWithoutImpressionsInput
    connect?: AdvertisementWhereUniqueInput
    update?: XOR<XOR<AdvertisementUpdateToOneWithWhereWithoutImpressionsInput, AdvertisementUpdateWithoutImpressionsInput>, AdvertisementUncheckedUpdateWithoutImpressionsInput>
  }

  export type UserDeviceUpdateOneWithoutAdImpressionsNestedInput = {
    create?: XOR<UserDeviceCreateWithoutAdImpressionsInput, UserDeviceUncheckedCreateWithoutAdImpressionsInput>
    connectOrCreate?: UserDeviceCreateOrConnectWithoutAdImpressionsInput
    upsert?: UserDeviceUpsertWithoutAdImpressionsInput
    disconnect?: UserDeviceWhereInput | boolean
    delete?: UserDeviceWhereInput | boolean
    connect?: UserDeviceWhereUniqueInput
    update?: XOR<XOR<UserDeviceUpdateToOneWithWhereWithoutAdImpressionsInput, UserDeviceUpdateWithoutAdImpressionsInput>, UserDeviceUncheckedUpdateWithoutAdImpressionsInput>
  }

  export type UserCreateNestedOneWithoutAdSettingsInput = {
    create?: XOR<UserCreateWithoutAdSettingsInput, UserUncheckedCreateWithoutAdSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdSettingsNestedInput = {
    create?: XOR<UserCreateWithoutAdSettingsInput, UserUncheckedCreateWithoutAdSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdSettingsInput
    upsert?: UserUpsertWithoutAdSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdSettingsInput, UserUpdateWithoutAdSettingsInput>, UserUncheckedUpdateWithoutAdSettingsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionType[] | ListEnumSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAlbumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlbumType | EnumAlbumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlbumTypeFilter<$PrismaModel> | $Enums.AlbumType
  }

  export type NestedEnumAlbumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlbumType | EnumAlbumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlbumType[] | ListEnumAlbumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlbumTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlbumType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlbumTypeFilter<$PrismaModel>
    _max?: NestedEnumAlbumTypeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumArtistRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistRole | EnumArtistRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistRoleFilter<$PrismaModel> | $Enums.ArtistRole
  }

  export type NestedEnumArtistRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtistRole | EnumArtistRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtistRole[] | ListEnumArtistRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumArtistRoleWithAggregatesFilter<$PrismaModel> | $Enums.ArtistRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtistRoleFilter<$PrismaModel>
    _max?: NestedEnumArtistRoleFilter<$PrismaModel>
  }

  export type NestedEnumFollowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowType | EnumFollowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FollowType[] | ListEnumFollowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowType[] | ListEnumFollowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowTypeFilter<$PrismaModel> | $Enums.FollowType
  }

  export type NestedEnumFollowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowType | EnumFollowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FollowType[] | ListEnumFollowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowType[] | ListEnumFollowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowTypeWithAggregatesFilter<$PrismaModel> | $Enums.FollowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowTypeFilter<$PrismaModel>
    _max?: NestedEnumFollowTypeFilter<$PrismaModel>
  }

  export type NestedEnumLibraryItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryItemType | EnumLibraryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLibraryItemTypeFilter<$PrismaModel> | $Enums.LibraryItemType
  }

  export type NestedEnumLibraryItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryItemType | EnumLibraryItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LibraryItemType[] | ListEnumLibraryItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLibraryItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.LibraryItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLibraryItemTypeFilter<$PrismaModel>
    _max?: NestedEnumLibraryItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumContextTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContextType | EnumContextTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContextTypeNullableFilter<$PrismaModel> | $Enums.ContextType | null
  }

  export type NestedEnumContextTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContextType | EnumContextTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContextTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContextType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContextTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumContextTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumShuffleModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShuffleMode | EnumShuffleModeFieldRefInput<$PrismaModel>
    in?: $Enums.ShuffleMode[] | ListEnumShuffleModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShuffleMode[] | ListEnumShuffleModeFieldRefInput<$PrismaModel>
    not?: NestedEnumShuffleModeFilter<$PrismaModel> | $Enums.ShuffleMode
  }

  export type NestedEnumRepeatModeFilter<$PrismaModel = never> = {
    equals?: $Enums.RepeatMode | EnumRepeatModeFieldRefInput<$PrismaModel>
    in?: $Enums.RepeatMode[] | ListEnumRepeatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RepeatMode[] | ListEnumRepeatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumRepeatModeFilter<$PrismaModel> | $Enums.RepeatMode
  }

  export type NestedEnumShuffleModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShuffleMode | EnumShuffleModeFieldRefInput<$PrismaModel>
    in?: $Enums.ShuffleMode[] | ListEnumShuffleModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShuffleMode[] | ListEnumShuffleModeFieldRefInput<$PrismaModel>
    not?: NestedEnumShuffleModeWithAggregatesFilter<$PrismaModel> | $Enums.ShuffleMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShuffleModeFilter<$PrismaModel>
    _max?: NestedEnumShuffleModeFilter<$PrismaModel>
  }

  export type NestedEnumRepeatModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RepeatMode | EnumRepeatModeFieldRefInput<$PrismaModel>
    in?: $Enums.RepeatMode[] | ListEnumRepeatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RepeatMode[] | ListEnumRepeatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumRepeatModeWithAggregatesFilter<$PrismaModel> | $Enums.RepeatMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRepeatModeFilter<$PrismaModel>
    _max?: NestedEnumRepeatModeFilter<$PrismaModel>
  }

  export type NestedEnumDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceTypeFilter<$PrismaModel> | $Enums.DeviceType
  }

  export type NestedEnumDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumDeviceTypeFilter<$PrismaModel>
  }

  export type NestedEnumSyncTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncTypeFilter<$PrismaModel> | $Enums.SyncType
  }

  export type NestedEnumSyncTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncType[] | ListEnumSyncTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncTypeWithAggregatesFilter<$PrismaModel> | $Enums.SyncType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncTypeFilter<$PrismaModel>
    _max?: NestedEnumSyncTypeFilter<$PrismaModel>
  }

  export type NestedEnumSyncActionFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncAction | EnumSyncActionFieldRefInput<$PrismaModel>
    in?: $Enums.SyncAction[] | ListEnumSyncActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncAction[] | ListEnumSyncActionFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncActionFilter<$PrismaModel> | $Enums.SyncAction
  }

  export type NestedEnumSyncActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncAction | EnumSyncActionFieldRefInput<$PrismaModel>
    in?: $Enums.SyncAction[] | ListEnumSyncActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncAction[] | ListEnumSyncActionFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncActionWithAggregatesFilter<$PrismaModel> | $Enums.SyncAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncActionFilter<$PrismaModel>
    _max?: NestedEnumSyncActionFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumAudioQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.AudioQuality | EnumAudioQualityFieldRefInput<$PrismaModel>
    in?: $Enums.AudioQuality[] | ListEnumAudioQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AudioQuality[] | ListEnumAudioQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumAudioQualityFilter<$PrismaModel> | $Enums.AudioQuality
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumAudioQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AudioQuality | EnumAudioQualityFieldRefInput<$PrismaModel>
    in?: $Enums.AudioQuality[] | ListEnumAudioQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AudioQuality[] | ListEnumAudioQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumAudioQualityWithAggregatesFilter<$PrismaModel> | $Enums.AudioQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAudioQualityFilter<$PrismaModel>
    _max?: NestedEnumAudioQualityFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumBillingCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleFilter<$PrismaModel> | $Enums.BillingCycle
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingCycle | EnumBillingCycleFieldRefInput<$PrismaModel>
    in?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingCycle[] | ListEnumBillingCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingCycleWithAggregatesFilter<$PrismaModel> | $Enums.BillingCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingCycleFilter<$PrismaModel>
    _max?: NestedEnumBillingCycleFilter<$PrismaModel>
  }

  export type NestedEnumAdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdType | EnumAdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdType[] | ListEnumAdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdType[] | ListEnumAdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdTypeFilter<$PrismaModel> | $Enums.AdType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumAdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdType | EnumAdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdType[] | ListEnumAdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdType[] | ListEnumAdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdTypeFilter<$PrismaModel>
    _max?: NestedEnumAdTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumImpressionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImpressionType | EnumImpressionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImpressionType[] | ListEnumImpressionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImpressionType[] | ListEnumImpressionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImpressionTypeFilter<$PrismaModel> | $Enums.ImpressionType
  }

  export type NestedEnumAdContextTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AdContextType | EnumAdContextTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdContextType[] | ListEnumAdContextTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdContextType[] | ListEnumAdContextTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdContextTypeNullableFilter<$PrismaModel> | $Enums.AdContextType | null
  }

  export type NestedEnumImpressionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImpressionType | EnumImpressionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImpressionType[] | ListEnumImpressionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImpressionType[] | ListEnumImpressionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImpressionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImpressionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImpressionTypeFilter<$PrismaModel>
    _max?: NestedEnumImpressionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAdContextTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdContextType | EnumAdContextTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AdContextType[] | ListEnumAdContextTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AdContextType[] | ListEnumAdContextTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAdContextTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AdContextType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAdContextTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAdContextTypeNullableFilter<$PrismaModel>
  }

  export type ArtistCreateWithoutUserInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumCreateNestedManyWithoutArtistInput
    songs?: SongCreateNestedManyWithoutPrimaryArtistInput
    songArtists?: SongArtistCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    songs?: SongUncheckedCreateNestedManyWithoutPrimaryArtistInput
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutUserInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutUserInput, ArtistUncheckedCreateWithoutUserInput>
  }

  export type UserOAuthAccountCreateWithoutUserInput = {
    id?: string
    provider: string
    providerUserId: string
    email?: string | null
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserOAuthAccountUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    providerUserId: string
    email?: string | null
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserOAuthAccountCreateOrConnectWithoutUserInput = {
    where: UserOAuthAccountWhereUniqueInput
    create: XOR<UserOAuthAccountCreateWithoutUserInput, UserOAuthAccountUncheckedCreateWithoutUserInput>
  }

  export type UserOAuthAccountCreateManyUserInputEnvelope = {
    data: UserOAuthAccountCreateManyUserInput | UserOAuthAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
    device?: UserDeviceCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    deviceId?: string | null
    tokenHash: string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserDeviceCreateWithoutUserInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceUncheckedCreateWithoutUserInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateUncheckedCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferUncheckedCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferUncheckedCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceCreateOrConnectWithoutUserInput = {
    where: UserDeviceWhereUniqueInput
    create: XOR<UserDeviceCreateWithoutUserInput, UserDeviceUncheckedCreateWithoutUserInput>
  }

  export type UserDeviceCreateManyUserInputEnvelope = {
    data: UserDeviceCreateManyUserInput | UserDeviceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlaylistCreateWithoutUserInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: PlaylistSongCreateNestedManyWithoutPlaylistInput
    followers?: UserFollowCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: PlaylistSongUncheckedCreateNestedManyWithoutPlaylistInput
    followers?: UserFollowUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutUserInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput>
  }

  export type PlaylistCreateManyUserInputEnvelope = {
    data: PlaylistCreateManyUserInput | PlaylistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFollowCreateWithoutFollowerInput = {
    id?: string
    followingType: $Enums.FollowType
    createdAt?: Date | string
    playlist?: PlaylistCreateNestedOneWithoutFollowersInput
  }

  export type UserFollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingType: $Enums.FollowType
    followingId: string
    createdAt?: Date | string
  }

  export type UserFollowCreateOrConnectWithoutFollowerInput = {
    where: UserFollowWhereUniqueInput
    create: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput>
  }

  export type UserFollowCreateManyFollowerInputEnvelope = {
    data: UserFollowCreateManyFollowerInput | UserFollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type UserLibraryCreateWithoutUserInput = {
    id?: string
    itemType: $Enums.LibraryItemType
    itemId: string
    addedAt?: Date | string
  }

  export type UserLibraryUncheckedCreateWithoutUserInput = {
    id?: string
    itemType: $Enums.LibraryItemType
    itemId: string
    addedAt?: Date | string
  }

  export type UserLibraryCreateOrConnectWithoutUserInput = {
    where: UserLibraryWhereUniqueInput
    create: XOR<UserLibraryCreateWithoutUserInput, UserLibraryUncheckedCreateWithoutUserInput>
  }

  export type UserLibraryCreateManyUserInputEnvelope = {
    data: UserLibraryCreateManyUserInput | UserLibraryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ListeningHistoryCreateWithoutUserInput = {
    id?: string
    playedAt?: Date | string
    durationMs: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    song: SongCreateNestedOneWithoutListeningHistoryInput
  }

  export type ListeningHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    songId: string
    playedAt?: Date | string
    durationMs: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type ListeningHistoryCreateOrConnectWithoutUserInput = {
    where: ListeningHistoryWhereUniqueInput
    create: XOR<ListeningHistoryCreateWithoutUserInput, ListeningHistoryUncheckedCreateWithoutUserInput>
  }

  export type ListeningHistoryCreateManyUserInputEnvelope = {
    data: ListeningHistoryCreateManyUserInput | ListeningHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RecentlyPlayedCreateWithoutUserInput = {
    id?: string
    playedAt?: Date | string
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    song: SongCreateNestedOneWithoutRecentlyPlayedInput
  }

  export type RecentlyPlayedUncheckedCreateWithoutUserInput = {
    id?: string
    songId: string
    playedAt?: Date | string
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type RecentlyPlayedCreateOrConnectWithoutUserInput = {
    where: RecentlyPlayedWhereUniqueInput
    create: XOR<RecentlyPlayedCreateWithoutUserInput, RecentlyPlayedUncheckedCreateWithoutUserInput>
  }

  export type RecentlyPlayedCreateManyUserInputEnvelope = {
    data: RecentlyPlayedCreateManyUserInput | RecentlyPlayedCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlaybackStateCreateWithoutUserInput = {
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    updatedAt?: Date | string
    currentSong?: SongCreateNestedOneWithoutPlaybackStatesInput
    activeDevice?: UserDeviceCreateNestedOneWithoutPlaybackStatesInput
  }

  export type PlaybackStateUncheckedCreateWithoutUserInput = {
    currentSongId?: string | null
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    activeDeviceId?: string | null
    updatedAt?: Date | string
  }

  export type PlaybackStateCreateOrConnectWithoutUserInput = {
    where: PlaybackStateWhereUniqueInput
    create: XOR<PlaybackStateCreateWithoutUserInput, PlaybackStateUncheckedCreateWithoutUserInput>
  }

  export type PlaybackQueueCreateWithoutUserInput = {
    id?: string
    position: number
    addedAt?: Date | string
    song: SongCreateNestedOneWithoutPlaybackQueuesInput
  }

  export type PlaybackQueueUncheckedCreateWithoutUserInput = {
    id?: string
    songId: string
    position: number
    addedAt?: Date | string
  }

  export type PlaybackQueueCreateOrConnectWithoutUserInput = {
    where: PlaybackQueueWhereUniqueInput
    create: XOR<PlaybackQueueCreateWithoutUserInput, PlaybackQueueUncheckedCreateWithoutUserInput>
  }

  export type PlaybackQueueCreateManyUserInputEnvelope = {
    data: PlaybackQueueCreateManyUserInput | PlaybackQueueCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionCreateWithoutUserInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    billingCycle?: $Enums.BillingCycle
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type UserSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    status?: $Enums.SubscriptionStatus
    billingCycle?: $Enums.BillingCycle
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionCreateOrConnectWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type UserSubscriptionCreateManyUserInputEnvelope = {
    data: UserSubscriptionCreateManyUserInput | UserSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdImpressionCreateWithoutUserInput = {
    id?: string
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    ad: AdvertisementCreateNestedOneWithoutImpressionsInput
    device?: UserDeviceCreateNestedOneWithoutAdImpressionsInput
  }

  export type AdImpressionUncheckedCreateWithoutUserInput = {
    id?: string
    adId: string
    deviceId?: string | null
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type AdImpressionCreateOrConnectWithoutUserInput = {
    where: AdImpressionWhereUniqueInput
    create: XOR<AdImpressionCreateWithoutUserInput, AdImpressionUncheckedCreateWithoutUserInput>
  }

  export type AdImpressionCreateManyUserInputEnvelope = {
    data: AdImpressionCreateManyUserInput | AdImpressionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAdSettingsCreateWithoutUserInput = {
    lastAdShownAt?: Date | string | null
    songsSinceLastAd?: number
    adsPerHour?: number
    skipCountToday?: number
    skipResetAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type UserAdSettingsUncheckedCreateWithoutUserInput = {
    lastAdShownAt?: Date | string | null
    songsSinceLastAd?: number
    adsPerHour?: number
    skipCountToday?: number
    skipResetAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type UserAdSettingsCreateOrConnectWithoutUserInput = {
    where: UserAdSettingsWhereUniqueInput
    create: XOR<UserAdSettingsCreateWithoutUserInput, UserAdSettingsUncheckedCreateWithoutUserInput>
  }

  export type ArtistUpsertWithoutUserInput = {
    update: XOR<ArtistUpdateWithoutUserInput, ArtistUncheckedUpdateWithoutUserInput>
    create: XOR<ArtistCreateWithoutUserInput, ArtistUncheckedCreateWithoutUserInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutUserInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutUserInput, ArtistUncheckedUpdateWithoutUserInput>
  }

  export type ArtistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    songs?: SongUpdateManyWithoutPrimaryArtistNestedInput
    songArtists?: SongArtistUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    songs?: SongUncheckedUpdateManyWithoutPrimaryArtistNestedInput
    songArtists?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type UserOAuthAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: UserOAuthAccountWhereUniqueInput
    update: XOR<UserOAuthAccountUpdateWithoutUserInput, UserOAuthAccountUncheckedUpdateWithoutUserInput>
    create: XOR<UserOAuthAccountCreateWithoutUserInput, UserOAuthAccountUncheckedCreateWithoutUserInput>
  }

  export type UserOAuthAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: UserOAuthAccountWhereUniqueInput
    data: XOR<UserOAuthAccountUpdateWithoutUserInput, UserOAuthAccountUncheckedUpdateWithoutUserInput>
  }

  export type UserOAuthAccountUpdateManyWithWhereWithoutUserInput = {
    where: UserOAuthAccountScalarWhereInput
    data: XOR<UserOAuthAccountUpdateManyMutationInput, UserOAuthAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type UserOAuthAccountScalarWhereInput = {
    AND?: UserOAuthAccountScalarWhereInput | UserOAuthAccountScalarWhereInput[]
    OR?: UserOAuthAccountScalarWhereInput[]
    NOT?: UserOAuthAccountScalarWhereInput | UserOAuthAccountScalarWhereInput[]
    id?: StringFilter<"UserOAuthAccount"> | string
    userId?: StringFilter<"UserOAuthAccount"> | string
    provider?: StringFilter<"UserOAuthAccount"> | string
    providerUserId?: StringFilter<"UserOAuthAccount"> | string
    email?: StringNullableFilter<"UserOAuthAccount"> | string | null
    name?: StringNullableFilter<"UserOAuthAccount"> | string | null
    avatarUrl?: StringNullableFilter<"UserOAuthAccount"> | string | null
    accessToken?: StringNullableFilter<"UserOAuthAccount"> | string | null
    refreshToken?: StringNullableFilter<"UserOAuthAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"UserOAuthAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"UserOAuthAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserOAuthAccount"> | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    deviceId?: StringNullableFilter<"UserSession"> | string | null
    tokenHash?: StringFilter<"UserSession"> | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserDeviceUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDeviceWhereUniqueInput
    update: XOR<UserDeviceUpdateWithoutUserInput, UserDeviceUncheckedUpdateWithoutUserInput>
    create: XOR<UserDeviceCreateWithoutUserInput, UserDeviceUncheckedCreateWithoutUserInput>
  }

  export type UserDeviceUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDeviceWhereUniqueInput
    data: XOR<UserDeviceUpdateWithoutUserInput, UserDeviceUncheckedUpdateWithoutUserInput>
  }

  export type UserDeviceUpdateManyWithWhereWithoutUserInput = {
    where: UserDeviceScalarWhereInput
    data: XOR<UserDeviceUpdateManyMutationInput, UserDeviceUncheckedUpdateManyWithoutUserInput>
  }

  export type UserDeviceScalarWhereInput = {
    AND?: UserDeviceScalarWhereInput | UserDeviceScalarWhereInput[]
    OR?: UserDeviceScalarWhereInput[]
    NOT?: UserDeviceScalarWhereInput | UserDeviceScalarWhereInput[]
    id?: StringFilter<"UserDevice"> | string
    userId?: StringFilter<"UserDevice"> | string
    deviceType?: EnumDeviceTypeFilter<"UserDevice"> | $Enums.DeviceType
    deviceName?: StringNullableFilter<"UserDevice"> | string | null
    deviceToken?: StringNullableFilter<"UserDevice"> | string | null
    appVersion?: StringNullableFilter<"UserDevice"> | string | null
    osVersion?: StringNullableFilter<"UserDevice"> | string | null
    isActive?: BoolFilter<"UserDevice"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"UserDevice"> | Date | string | null
    createdAt?: DateTimeFilter<"UserDevice"> | Date | string
    updatedAt?: DateTimeFilter<"UserDevice"> | Date | string
  }

  export type PlaylistUpsertWithWhereUniqueWithoutUserInput = {
    where: PlaylistWhereUniqueInput
    update: XOR<PlaylistUpdateWithoutUserInput, PlaylistUncheckedUpdateWithoutUserInput>
    create: XOR<PlaylistCreateWithoutUserInput, PlaylistUncheckedCreateWithoutUserInput>
  }

  export type PlaylistUpdateWithWhereUniqueWithoutUserInput = {
    where: PlaylistWhereUniqueInput
    data: XOR<PlaylistUpdateWithoutUserInput, PlaylistUncheckedUpdateWithoutUserInput>
  }

  export type PlaylistUpdateManyWithWhereWithoutUserInput = {
    where: PlaylistScalarWhereInput
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyWithoutUserInput>
  }

  export type PlaylistScalarWhereInput = {
    AND?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
    OR?: PlaylistScalarWhereInput[]
    NOT?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
    id?: StringFilter<"Playlist"> | string
    userId?: StringFilter<"Playlist"> | string
    name?: StringFilter<"Playlist"> | string
    slug?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    imageUrl?: StringNullableFilter<"Playlist"> | string | null
    isPublic?: BoolFilter<"Playlist"> | boolean
    isCollaborative?: BoolFilter<"Playlist"> | boolean
    totalTracks?: IntFilter<"Playlist"> | number
    durationMs?: IntFilter<"Playlist"> | number
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
  }

  export type UserFollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: UserFollowWhereUniqueInput
    update: XOR<UserFollowUpdateWithoutFollowerInput, UserFollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<UserFollowCreateWithoutFollowerInput, UserFollowUncheckedCreateWithoutFollowerInput>
  }

  export type UserFollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: UserFollowWhereUniqueInput
    data: XOR<UserFollowUpdateWithoutFollowerInput, UserFollowUncheckedUpdateWithoutFollowerInput>
  }

  export type UserFollowUpdateManyWithWhereWithoutFollowerInput = {
    where: UserFollowScalarWhereInput
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type UserFollowScalarWhereInput = {
    AND?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
    OR?: UserFollowScalarWhereInput[]
    NOT?: UserFollowScalarWhereInput | UserFollowScalarWhereInput[]
    id?: StringFilter<"UserFollow"> | string
    followerId?: StringFilter<"UserFollow"> | string
    followingType?: EnumFollowTypeFilter<"UserFollow"> | $Enums.FollowType
    followingId?: StringFilter<"UserFollow"> | string
    createdAt?: DateTimeFilter<"UserFollow"> | Date | string
  }

  export type UserLibraryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLibraryWhereUniqueInput
    update: XOR<UserLibraryUpdateWithoutUserInput, UserLibraryUncheckedUpdateWithoutUserInput>
    create: XOR<UserLibraryCreateWithoutUserInput, UserLibraryUncheckedCreateWithoutUserInput>
  }

  export type UserLibraryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLibraryWhereUniqueInput
    data: XOR<UserLibraryUpdateWithoutUserInput, UserLibraryUncheckedUpdateWithoutUserInput>
  }

  export type UserLibraryUpdateManyWithWhereWithoutUserInput = {
    where: UserLibraryScalarWhereInput
    data: XOR<UserLibraryUpdateManyMutationInput, UserLibraryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLibraryScalarWhereInput = {
    AND?: UserLibraryScalarWhereInput | UserLibraryScalarWhereInput[]
    OR?: UserLibraryScalarWhereInput[]
    NOT?: UserLibraryScalarWhereInput | UserLibraryScalarWhereInput[]
    id?: StringFilter<"UserLibrary"> | string
    userId?: StringFilter<"UserLibrary"> | string
    itemType?: EnumLibraryItemTypeFilter<"UserLibrary"> | $Enums.LibraryItemType
    itemId?: StringFilter<"UserLibrary"> | string
    addedAt?: DateTimeFilter<"UserLibrary"> | Date | string
  }

  export type ListeningHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ListeningHistoryWhereUniqueInput
    update: XOR<ListeningHistoryUpdateWithoutUserInput, ListeningHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<ListeningHistoryCreateWithoutUserInput, ListeningHistoryUncheckedCreateWithoutUserInput>
  }

  export type ListeningHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ListeningHistoryWhereUniqueInput
    data: XOR<ListeningHistoryUpdateWithoutUserInput, ListeningHistoryUncheckedUpdateWithoutUserInput>
  }

  export type ListeningHistoryUpdateManyWithWhereWithoutUserInput = {
    where: ListeningHistoryScalarWhereInput
    data: XOR<ListeningHistoryUpdateManyMutationInput, ListeningHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ListeningHistoryScalarWhereInput = {
    AND?: ListeningHistoryScalarWhereInput | ListeningHistoryScalarWhereInput[]
    OR?: ListeningHistoryScalarWhereInput[]
    NOT?: ListeningHistoryScalarWhereInput | ListeningHistoryScalarWhereInput[]
    id?: StringFilter<"ListeningHistory"> | string
    userId?: StringFilter<"ListeningHistory"> | string
    songId?: StringFilter<"ListeningHistory"> | string
    playedAt?: DateTimeFilter<"ListeningHistory"> | Date | string
    durationMs?: IntFilter<"ListeningHistory"> | number
    contextType?: EnumContextTypeNullableFilter<"ListeningHistory"> | $Enums.ContextType | null
    contextId?: StringNullableFilter<"ListeningHistory"> | string | null
  }

  export type RecentlyPlayedUpsertWithWhereUniqueWithoutUserInput = {
    where: RecentlyPlayedWhereUniqueInput
    update: XOR<RecentlyPlayedUpdateWithoutUserInput, RecentlyPlayedUncheckedUpdateWithoutUserInput>
    create: XOR<RecentlyPlayedCreateWithoutUserInput, RecentlyPlayedUncheckedCreateWithoutUserInput>
  }

  export type RecentlyPlayedUpdateWithWhereUniqueWithoutUserInput = {
    where: RecentlyPlayedWhereUniqueInput
    data: XOR<RecentlyPlayedUpdateWithoutUserInput, RecentlyPlayedUncheckedUpdateWithoutUserInput>
  }

  export type RecentlyPlayedUpdateManyWithWhereWithoutUserInput = {
    where: RecentlyPlayedScalarWhereInput
    data: XOR<RecentlyPlayedUpdateManyMutationInput, RecentlyPlayedUncheckedUpdateManyWithoutUserInput>
  }

  export type RecentlyPlayedScalarWhereInput = {
    AND?: RecentlyPlayedScalarWhereInput | RecentlyPlayedScalarWhereInput[]
    OR?: RecentlyPlayedScalarWhereInput[]
    NOT?: RecentlyPlayedScalarWhereInput | RecentlyPlayedScalarWhereInput[]
    id?: StringFilter<"RecentlyPlayed"> | string
    userId?: StringFilter<"RecentlyPlayed"> | string
    songId?: StringFilter<"RecentlyPlayed"> | string
    playedAt?: DateTimeFilter<"RecentlyPlayed"> | Date | string
    contextType?: EnumContextTypeNullableFilter<"RecentlyPlayed"> | $Enums.ContextType | null
    contextId?: StringNullableFilter<"RecentlyPlayed"> | string | null
  }

  export type PlaybackStateUpsertWithoutUserInput = {
    update: XOR<PlaybackStateUpdateWithoutUserInput, PlaybackStateUncheckedUpdateWithoutUserInput>
    create: XOR<PlaybackStateCreateWithoutUserInput, PlaybackStateUncheckedCreateWithoutUserInput>
    where?: PlaybackStateWhereInput
  }

  export type PlaybackStateUpdateToOneWithWhereWithoutUserInput = {
    where?: PlaybackStateWhereInput
    data: XOR<PlaybackStateUpdateWithoutUserInput, PlaybackStateUncheckedUpdateWithoutUserInput>
  }

  export type PlaybackStateUpdateWithoutUserInput = {
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentSong?: SongUpdateOneWithoutPlaybackStatesNestedInput
    activeDevice?: UserDeviceUpdateOneWithoutPlaybackStatesNestedInput
  }

  export type PlaybackStateUncheckedUpdateWithoutUserInput = {
    currentSongId?: NullableStringFieldUpdateOperationsInput | string | null
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    activeDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackQueueUpsertWithWhereUniqueWithoutUserInput = {
    where: PlaybackQueueWhereUniqueInput
    update: XOR<PlaybackQueueUpdateWithoutUserInput, PlaybackQueueUncheckedUpdateWithoutUserInput>
    create: XOR<PlaybackQueueCreateWithoutUserInput, PlaybackQueueUncheckedCreateWithoutUserInput>
  }

  export type PlaybackQueueUpdateWithWhereUniqueWithoutUserInput = {
    where: PlaybackQueueWhereUniqueInput
    data: XOR<PlaybackQueueUpdateWithoutUserInput, PlaybackQueueUncheckedUpdateWithoutUserInput>
  }

  export type PlaybackQueueUpdateManyWithWhereWithoutUserInput = {
    where: PlaybackQueueScalarWhereInput
    data: XOR<PlaybackQueueUpdateManyMutationInput, PlaybackQueueUncheckedUpdateManyWithoutUserInput>
  }

  export type PlaybackQueueScalarWhereInput = {
    AND?: PlaybackQueueScalarWhereInput | PlaybackQueueScalarWhereInput[]
    OR?: PlaybackQueueScalarWhereInput[]
    NOT?: PlaybackQueueScalarWhereInput | PlaybackQueueScalarWhereInput[]
    id?: StringFilter<"PlaybackQueue"> | string
    userId?: StringFilter<"PlaybackQueue"> | string
    songId?: StringFilter<"PlaybackQueue"> | string
    position?: IntFilter<"PlaybackQueue"> | number
    addedAt?: DateTimeFilter<"PlaybackQueue"> | Date | string
  }

  export type UserSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    update: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type UserSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    data: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UserSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: UserSubscriptionScalarWhereInput
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSubscriptionScalarWhereInput = {
    AND?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    OR?: UserSubscriptionScalarWhereInput[]
    NOT?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    id?: StringFilter<"UserSubscription"> | string
    userId?: StringFilter<"UserSubscription"> | string
    planId?: StringFilter<"UserSubscription"> | string
    status?: EnumSubscriptionStatusFilter<"UserSubscription"> | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFilter<"UserSubscription"> | $Enums.BillingCycle
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    paymentMethod?: StringNullableFilter<"UserSubscription"> | string | null
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
  }

  export type AdImpressionUpsertWithWhereUniqueWithoutUserInput = {
    where: AdImpressionWhereUniqueInput
    update: XOR<AdImpressionUpdateWithoutUserInput, AdImpressionUncheckedUpdateWithoutUserInput>
    create: XOR<AdImpressionCreateWithoutUserInput, AdImpressionUncheckedCreateWithoutUserInput>
  }

  export type AdImpressionUpdateWithWhereUniqueWithoutUserInput = {
    where: AdImpressionWhereUniqueInput
    data: XOR<AdImpressionUpdateWithoutUserInput, AdImpressionUncheckedUpdateWithoutUserInput>
  }

  export type AdImpressionUpdateManyWithWhereWithoutUserInput = {
    where: AdImpressionScalarWhereInput
    data: XOR<AdImpressionUpdateManyMutationInput, AdImpressionUncheckedUpdateManyWithoutUserInput>
  }

  export type AdImpressionScalarWhereInput = {
    AND?: AdImpressionScalarWhereInput | AdImpressionScalarWhereInput[]
    OR?: AdImpressionScalarWhereInput[]
    NOT?: AdImpressionScalarWhereInput | AdImpressionScalarWhereInput[]
    id?: StringFilter<"AdImpression"> | string
    userId?: StringFilter<"AdImpression"> | string
    adId?: StringFilter<"AdImpression"> | string
    deviceId?: StringNullableFilter<"AdImpression"> | string | null
    impressionType?: EnumImpressionTypeFilter<"AdImpression"> | $Enums.ImpressionType
    contextType?: EnumAdContextTypeNullableFilter<"AdImpression"> | $Enums.AdContextType | null
    revenue?: DecimalFilter<"AdImpression"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"AdImpression"> | Date | string
  }

  export type UserAdSettingsUpsertWithoutUserInput = {
    update: XOR<UserAdSettingsUpdateWithoutUserInput, UserAdSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserAdSettingsCreateWithoutUserInput, UserAdSettingsUncheckedCreateWithoutUserInput>
    where?: UserAdSettingsWhereInput
  }

  export type UserAdSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserAdSettingsWhereInput
    data: XOR<UserAdSettingsUpdateWithoutUserInput, UserAdSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserAdSettingsUpdateWithoutUserInput = {
    lastAdShownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    songsSinceLastAd?: IntFieldUpdateOperationsInput | number
    adsPerHour?: IntFieldUpdateOperationsInput | number
    skipCountToday?: IntFieldUpdateOperationsInput | number
    skipResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAdSettingsUncheckedUpdateWithoutUserInput = {
    lastAdShownAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    songsSinceLastAd?: IntFieldUpdateOperationsInput | number
    adsPerHour?: IntFieldUpdateOperationsInput | number
    skipCountToday?: IntFieldUpdateOperationsInput | number
    skipResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutArtistInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArtistInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArtistInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArtistInput, UserUncheckedCreateWithoutArtistInput>
  }

  export type AlbumCreateWithoutArtistInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    coverUrl?: string | null
    releaseDate?: Date | string | null
    albumType?: $Enums.AlbumType
    totalTracks?: number
    durationMs?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: SongCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutArtistInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    coverUrl?: string | null
    releaseDate?: Date | string | null
    albumType?: $Enums.AlbumType
    totalTracks?: number
    durationMs?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: SongUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutArtistInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput>
  }

  export type AlbumCreateManyArtistInputEnvelope = {
    data: AlbumCreateManyArtistInput | AlbumCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type SongCreateWithoutPrimaryArtistInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    album?: AlbumCreateNestedOneWithoutSongsInput
    songArtists?: SongArtistCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutPrimaryArtistInput = {
    id?: string
    albumId?: string | null
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongUncheckedCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutPrimaryArtistInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutPrimaryArtistInput, SongUncheckedCreateWithoutPrimaryArtistInput>
  }

  export type SongCreateManyPrimaryArtistInputEnvelope = {
    data: SongCreateManyPrimaryArtistInput | SongCreateManyPrimaryArtistInput[]
    skipDuplicates?: boolean
  }

  export type SongArtistCreateWithoutArtistInput = {
    role?: $Enums.ArtistRole
    song: SongCreateNestedOneWithoutSongArtistsInput
  }

  export type SongArtistUncheckedCreateWithoutArtistInput = {
    songId: string
    role?: $Enums.ArtistRole
  }

  export type SongArtistCreateOrConnectWithoutArtistInput = {
    where: SongArtistWhereUniqueInput
    create: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput>
  }

  export type SongArtistCreateManyArtistInputEnvelope = {
    data: SongArtistCreateManyArtistInput | SongArtistCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type ArtistGenreCreateWithoutArtistInput = {
    genre: GenreCreateNestedOneWithoutArtistsInput
  }

  export type ArtistGenreUncheckedCreateWithoutArtistInput = {
    genreId: string
  }

  export type ArtistGenreCreateOrConnectWithoutArtistInput = {
    where: ArtistGenreWhereUniqueInput
    create: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput>
  }

  export type ArtistGenreCreateManyArtistInputEnvelope = {
    data: ArtistGenreCreateManyArtistInput | ArtistGenreCreateManyArtistInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutArtistInput = {
    update: XOR<UserUpdateWithoutArtistInput, UserUncheckedUpdateWithoutArtistInput>
    create: XOR<UserCreateWithoutArtistInput, UserUncheckedCreateWithoutArtistInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArtistInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArtistInput, UserUncheckedUpdateWithoutArtistInput>
  }

  export type UserUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AlbumUpsertWithWhereUniqueWithoutArtistInput = {
    where: AlbumWhereUniqueInput
    update: XOR<AlbumUpdateWithoutArtistInput, AlbumUncheckedUpdateWithoutArtistInput>
    create: XOR<AlbumCreateWithoutArtistInput, AlbumUncheckedCreateWithoutArtistInput>
  }

  export type AlbumUpdateWithWhereUniqueWithoutArtistInput = {
    where: AlbumWhereUniqueInput
    data: XOR<AlbumUpdateWithoutArtistInput, AlbumUncheckedUpdateWithoutArtistInput>
  }

  export type AlbumUpdateManyWithWhereWithoutArtistInput = {
    where: AlbumScalarWhereInput
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyWithoutArtistInput>
  }

  export type AlbumScalarWhereInput = {
    AND?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
    OR?: AlbumScalarWhereInput[]
    NOT?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
    id?: StringFilter<"Album"> | string
    artistId?: StringFilter<"Album"> | string
    title?: StringFilter<"Album"> | string
    slug?: StringFilter<"Album"> | string
    description?: StringNullableFilter<"Album"> | string | null
    coverUrl?: StringNullableFilter<"Album"> | string | null
    releaseDate?: DateTimeNullableFilter<"Album"> | Date | string | null
    albumType?: EnumAlbumTypeFilter<"Album"> | $Enums.AlbumType
    totalTracks?: IntFilter<"Album"> | number
    durationMs?: IntFilter<"Album"> | number
    isPublished?: BoolFilter<"Album"> | boolean
    createdAt?: DateTimeFilter<"Album"> | Date | string
    updatedAt?: DateTimeFilter<"Album"> | Date | string
  }

  export type SongUpsertWithWhereUniqueWithoutPrimaryArtistInput = {
    where: SongWhereUniqueInput
    update: XOR<SongUpdateWithoutPrimaryArtistInput, SongUncheckedUpdateWithoutPrimaryArtistInput>
    create: XOR<SongCreateWithoutPrimaryArtistInput, SongUncheckedCreateWithoutPrimaryArtistInput>
  }

  export type SongUpdateWithWhereUniqueWithoutPrimaryArtistInput = {
    where: SongWhereUniqueInput
    data: XOR<SongUpdateWithoutPrimaryArtistInput, SongUncheckedUpdateWithoutPrimaryArtistInput>
  }

  export type SongUpdateManyWithWhereWithoutPrimaryArtistInput = {
    where: SongScalarWhereInput
    data: XOR<SongUpdateManyMutationInput, SongUncheckedUpdateManyWithoutPrimaryArtistInput>
  }

  export type SongScalarWhereInput = {
    AND?: SongScalarWhereInput | SongScalarWhereInput[]
    OR?: SongScalarWhereInput[]
    NOT?: SongScalarWhereInput | SongScalarWhereInput[]
    id?: StringFilter<"Song"> | string
    albumId?: StringNullableFilter<"Song"> | string | null
    artistId?: StringFilter<"Song"> | string
    title?: StringFilter<"Song"> | string
    slug?: StringFilter<"Song"> | string
    trackNumber?: IntNullableFilter<"Song"> | number | null
    discNumber?: IntFilter<"Song"> | number
    durationMs?: IntFilter<"Song"> | number
    audioUrl?: StringFilter<"Song"> | string
    previewUrl?: StringNullableFilter<"Song"> | string | null
    lyricsUrl?: StringNullableFilter<"Song"> | string | null
    isExplicit?: BoolFilter<"Song"> | boolean
    isPlayable?: BoolFilter<"Song"> | boolean
    playCount?: BigIntFilter<"Song"> | bigint | number
    createdAt?: DateTimeFilter<"Song"> | Date | string
    updatedAt?: DateTimeFilter<"Song"> | Date | string
  }

  export type SongArtistUpsertWithWhereUniqueWithoutArtistInput = {
    where: SongArtistWhereUniqueInput
    update: XOR<SongArtistUpdateWithoutArtistInput, SongArtistUncheckedUpdateWithoutArtistInput>
    create: XOR<SongArtistCreateWithoutArtistInput, SongArtistUncheckedCreateWithoutArtistInput>
  }

  export type SongArtistUpdateWithWhereUniqueWithoutArtistInput = {
    where: SongArtistWhereUniqueInput
    data: XOR<SongArtistUpdateWithoutArtistInput, SongArtistUncheckedUpdateWithoutArtistInput>
  }

  export type SongArtistUpdateManyWithWhereWithoutArtistInput = {
    where: SongArtistScalarWhereInput
    data: XOR<SongArtistUpdateManyMutationInput, SongArtistUncheckedUpdateManyWithoutArtistInput>
  }

  export type SongArtistScalarWhereInput = {
    AND?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
    OR?: SongArtistScalarWhereInput[]
    NOT?: SongArtistScalarWhereInput | SongArtistScalarWhereInput[]
    songId?: StringFilter<"SongArtist"> | string
    artistId?: StringFilter<"SongArtist"> | string
    role?: EnumArtistRoleFilter<"SongArtist"> | $Enums.ArtistRole
  }

  export type ArtistGenreUpsertWithWhereUniqueWithoutArtistInput = {
    where: ArtistGenreWhereUniqueInput
    update: XOR<ArtistGenreUpdateWithoutArtistInput, ArtistGenreUncheckedUpdateWithoutArtistInput>
    create: XOR<ArtistGenreCreateWithoutArtistInput, ArtistGenreUncheckedCreateWithoutArtistInput>
  }

  export type ArtistGenreUpdateWithWhereUniqueWithoutArtistInput = {
    where: ArtistGenreWhereUniqueInput
    data: XOR<ArtistGenreUpdateWithoutArtistInput, ArtistGenreUncheckedUpdateWithoutArtistInput>
  }

  export type ArtistGenreUpdateManyWithWhereWithoutArtistInput = {
    where: ArtistGenreScalarWhereInput
    data: XOR<ArtistGenreUpdateManyMutationInput, ArtistGenreUncheckedUpdateManyWithoutArtistInput>
  }

  export type ArtistGenreScalarWhereInput = {
    AND?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
    OR?: ArtistGenreScalarWhereInput[]
    NOT?: ArtistGenreScalarWhereInput | ArtistGenreScalarWhereInput[]
    artistId?: StringFilter<"ArtistGenre"> | string
    genreId?: StringFilter<"ArtistGenre"> | string
  }

  export type ArtistCreateWithoutAlbumsInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutArtistInput
    songs?: SongCreateNestedManyWithoutPrimaryArtistInput
    songArtists?: SongArtistCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutAlbumsInput = {
    id?: string
    userId?: string | null
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: SongUncheckedCreateNestedManyWithoutPrimaryArtistInput
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutAlbumsInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutAlbumsInput, ArtistUncheckedCreateWithoutAlbumsInput>
  }

  export type SongCreateWithoutAlbumInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryArtist: ArtistCreateNestedOneWithoutSongsInput
    songArtists?: SongArtistCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutAlbumInput = {
    id?: string
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongUncheckedCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutAlbumInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput>
  }

  export type SongCreateManyAlbumInputEnvelope = {
    data: SongCreateManyAlbumInput | SongCreateManyAlbumInput[]
    skipDuplicates?: boolean
  }

  export type ArtistUpsertWithoutAlbumsInput = {
    update: XOR<ArtistUpdateWithoutAlbumsInput, ArtistUncheckedUpdateWithoutAlbumsInput>
    create: XOR<ArtistCreateWithoutAlbumsInput, ArtistUncheckedCreateWithoutAlbumsInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutAlbumsInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutAlbumsInput, ArtistUncheckedUpdateWithoutAlbumsInput>
  }

  export type ArtistUpdateWithoutAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutArtistNestedInput
    songs?: SongUpdateManyWithoutPrimaryArtistNestedInput
    songArtists?: SongArtistUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutAlbumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongUncheckedUpdateManyWithoutPrimaryArtistNestedInput
    songArtists?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type SongUpsertWithWhereUniqueWithoutAlbumInput = {
    where: SongWhereUniqueInput
    update: XOR<SongUpdateWithoutAlbumInput, SongUncheckedUpdateWithoutAlbumInput>
    create: XOR<SongCreateWithoutAlbumInput, SongUncheckedCreateWithoutAlbumInput>
  }

  export type SongUpdateWithWhereUniqueWithoutAlbumInput = {
    where: SongWhereUniqueInput
    data: XOR<SongUpdateWithoutAlbumInput, SongUncheckedUpdateWithoutAlbumInput>
  }

  export type SongUpdateManyWithWhereWithoutAlbumInput = {
    where: SongScalarWhereInput
    data: XOR<SongUpdateManyMutationInput, SongUncheckedUpdateManyWithoutAlbumInput>
  }

  export type AlbumCreateWithoutSongsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    coverUrl?: string | null
    releaseDate?: Date | string | null
    albumType?: $Enums.AlbumType
    totalTracks?: number
    durationMs?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist: ArtistCreateNestedOneWithoutAlbumsInput
  }

  export type AlbumUncheckedCreateWithoutSongsInput = {
    id?: string
    artistId: string
    title: string
    slug: string
    description?: string | null
    coverUrl?: string | null
    releaseDate?: Date | string | null
    albumType?: $Enums.AlbumType
    totalTracks?: number
    durationMs?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlbumCreateOrConnectWithoutSongsInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutSongsInput, AlbumUncheckedCreateWithoutSongsInput>
  }

  export type ArtistCreateWithoutSongsInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutArtistInput
    albums?: AlbumCreateNestedManyWithoutArtistInput
    songArtists?: SongArtistCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutSongsInput = {
    id?: string
    userId?: string | null
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutSongsInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutSongsInput, ArtistUncheckedCreateWithoutSongsInput>
  }

  export type SongArtistCreateWithoutSongInput = {
    role?: $Enums.ArtistRole
    artist: ArtistCreateNestedOneWithoutSongArtistsInput
  }

  export type SongArtistUncheckedCreateWithoutSongInput = {
    artistId: string
    role?: $Enums.ArtistRole
  }

  export type SongArtistCreateOrConnectWithoutSongInput = {
    where: SongArtistWhereUniqueInput
    create: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput>
  }

  export type SongArtistCreateManySongInputEnvelope = {
    data: SongArtistCreateManySongInput | SongArtistCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type SongGenreCreateWithoutSongInput = {
    genre: GenreCreateNestedOneWithoutSongsInput
  }

  export type SongGenreUncheckedCreateWithoutSongInput = {
    genreId: string
  }

  export type SongGenreCreateOrConnectWithoutSongInput = {
    where: SongGenreWhereUniqueInput
    create: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput>
  }

  export type SongGenreCreateManySongInputEnvelope = {
    data: SongGenreCreateManySongInput | SongGenreCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type PlaylistSongCreateWithoutSongInput = {
    id?: string
    position: number
    addedBy?: string | null
    addedAt?: Date | string
    playlist: PlaylistCreateNestedOneWithoutSongsInput
  }

  export type PlaylistSongUncheckedCreateWithoutSongInput = {
    id?: string
    playlistId: string
    position: number
    addedBy?: string | null
    addedAt?: Date | string
  }

  export type PlaylistSongCreateOrConnectWithoutSongInput = {
    where: PlaylistSongWhereUniqueInput
    create: XOR<PlaylistSongCreateWithoutSongInput, PlaylistSongUncheckedCreateWithoutSongInput>
  }

  export type PlaylistSongCreateManySongInputEnvelope = {
    data: PlaylistSongCreateManySongInput | PlaylistSongCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type ListeningHistoryCreateWithoutSongInput = {
    id?: string
    playedAt?: Date | string
    durationMs: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    user: UserCreateNestedOneWithoutListeningHistoryInput
  }

  export type ListeningHistoryUncheckedCreateWithoutSongInput = {
    id?: string
    userId: string
    playedAt?: Date | string
    durationMs: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type ListeningHistoryCreateOrConnectWithoutSongInput = {
    where: ListeningHistoryWhereUniqueInput
    create: XOR<ListeningHistoryCreateWithoutSongInput, ListeningHistoryUncheckedCreateWithoutSongInput>
  }

  export type ListeningHistoryCreateManySongInputEnvelope = {
    data: ListeningHistoryCreateManySongInput | ListeningHistoryCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type RecentlyPlayedCreateWithoutSongInput = {
    id?: string
    playedAt?: Date | string
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    user: UserCreateNestedOneWithoutRecentlyPlayedInput
  }

  export type RecentlyPlayedUncheckedCreateWithoutSongInput = {
    id?: string
    userId: string
    playedAt?: Date | string
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type RecentlyPlayedCreateOrConnectWithoutSongInput = {
    where: RecentlyPlayedWhereUniqueInput
    create: XOR<RecentlyPlayedCreateWithoutSongInput, RecentlyPlayedUncheckedCreateWithoutSongInput>
  }

  export type RecentlyPlayedCreateManySongInputEnvelope = {
    data: RecentlyPlayedCreateManySongInput | RecentlyPlayedCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type PlaybackStateCreateWithoutCurrentSongInput = {
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaybackStateInput
    activeDevice?: UserDeviceCreateNestedOneWithoutPlaybackStatesInput
  }

  export type PlaybackStateUncheckedCreateWithoutCurrentSongInput = {
    userId: string
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    activeDeviceId?: string | null
    updatedAt?: Date | string
  }

  export type PlaybackStateCreateOrConnectWithoutCurrentSongInput = {
    where: PlaybackStateWhereUniqueInput
    create: XOR<PlaybackStateCreateWithoutCurrentSongInput, PlaybackStateUncheckedCreateWithoutCurrentSongInput>
  }

  export type PlaybackStateCreateManyCurrentSongInputEnvelope = {
    data: PlaybackStateCreateManyCurrentSongInput | PlaybackStateCreateManyCurrentSongInput[]
    skipDuplicates?: boolean
  }

  export type PlaybackQueueCreateWithoutSongInput = {
    id?: string
    position: number
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaybackQueueInput
  }

  export type PlaybackQueueUncheckedCreateWithoutSongInput = {
    id?: string
    userId: string
    position: number
    addedAt?: Date | string
  }

  export type PlaybackQueueCreateOrConnectWithoutSongInput = {
    where: PlaybackQueueWhereUniqueInput
    create: XOR<PlaybackQueueCreateWithoutSongInput, PlaybackQueueUncheckedCreateWithoutSongInput>
  }

  export type PlaybackQueueCreateManySongInputEnvelope = {
    data: PlaybackQueueCreateManySongInput | PlaybackQueueCreateManySongInput[]
    skipDuplicates?: boolean
  }

  export type AlbumUpsertWithoutSongsInput = {
    update: XOR<AlbumUpdateWithoutSongsInput, AlbumUncheckedUpdateWithoutSongsInput>
    create: XOR<AlbumCreateWithoutSongsInput, AlbumUncheckedCreateWithoutSongsInput>
    where?: AlbumWhereInput
  }

  export type AlbumUpdateToOneWithWhereWithoutSongsInput = {
    where?: AlbumWhereInput
    data: XOR<AlbumUpdateWithoutSongsInput, AlbumUncheckedUpdateWithoutSongsInput>
  }

  export type AlbumUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneRequiredWithoutAlbumsNestedInput
  }

  export type AlbumUncheckedUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtistUpsertWithoutSongsInput = {
    update: XOR<ArtistUpdateWithoutSongsInput, ArtistUncheckedUpdateWithoutSongsInput>
    create: XOR<ArtistCreateWithoutSongsInput, ArtistUncheckedCreateWithoutSongsInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutSongsInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutSongsInput, ArtistUncheckedUpdateWithoutSongsInput>
  }

  export type ArtistUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutArtistNestedInput
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    songArtists?: SongArtistUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    songArtists?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type SongArtistUpsertWithWhereUniqueWithoutSongInput = {
    where: SongArtistWhereUniqueInput
    update: XOR<SongArtistUpdateWithoutSongInput, SongArtistUncheckedUpdateWithoutSongInput>
    create: XOR<SongArtistCreateWithoutSongInput, SongArtistUncheckedCreateWithoutSongInput>
  }

  export type SongArtistUpdateWithWhereUniqueWithoutSongInput = {
    where: SongArtistWhereUniqueInput
    data: XOR<SongArtistUpdateWithoutSongInput, SongArtistUncheckedUpdateWithoutSongInput>
  }

  export type SongArtistUpdateManyWithWhereWithoutSongInput = {
    where: SongArtistScalarWhereInput
    data: XOR<SongArtistUpdateManyMutationInput, SongArtistUncheckedUpdateManyWithoutSongInput>
  }

  export type SongGenreUpsertWithWhereUniqueWithoutSongInput = {
    where: SongGenreWhereUniqueInput
    update: XOR<SongGenreUpdateWithoutSongInput, SongGenreUncheckedUpdateWithoutSongInput>
    create: XOR<SongGenreCreateWithoutSongInput, SongGenreUncheckedCreateWithoutSongInput>
  }

  export type SongGenreUpdateWithWhereUniqueWithoutSongInput = {
    where: SongGenreWhereUniqueInput
    data: XOR<SongGenreUpdateWithoutSongInput, SongGenreUncheckedUpdateWithoutSongInput>
  }

  export type SongGenreUpdateManyWithWhereWithoutSongInput = {
    where: SongGenreScalarWhereInput
    data: XOR<SongGenreUpdateManyMutationInput, SongGenreUncheckedUpdateManyWithoutSongInput>
  }

  export type SongGenreScalarWhereInput = {
    AND?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
    OR?: SongGenreScalarWhereInput[]
    NOT?: SongGenreScalarWhereInput | SongGenreScalarWhereInput[]
    songId?: StringFilter<"SongGenre"> | string
    genreId?: StringFilter<"SongGenre"> | string
  }

  export type PlaylistSongUpsertWithWhereUniqueWithoutSongInput = {
    where: PlaylistSongWhereUniqueInput
    update: XOR<PlaylistSongUpdateWithoutSongInput, PlaylistSongUncheckedUpdateWithoutSongInput>
    create: XOR<PlaylistSongCreateWithoutSongInput, PlaylistSongUncheckedCreateWithoutSongInput>
  }

  export type PlaylistSongUpdateWithWhereUniqueWithoutSongInput = {
    where: PlaylistSongWhereUniqueInput
    data: XOR<PlaylistSongUpdateWithoutSongInput, PlaylistSongUncheckedUpdateWithoutSongInput>
  }

  export type PlaylistSongUpdateManyWithWhereWithoutSongInput = {
    where: PlaylistSongScalarWhereInput
    data: XOR<PlaylistSongUpdateManyMutationInput, PlaylistSongUncheckedUpdateManyWithoutSongInput>
  }

  export type PlaylistSongScalarWhereInput = {
    AND?: PlaylistSongScalarWhereInput | PlaylistSongScalarWhereInput[]
    OR?: PlaylistSongScalarWhereInput[]
    NOT?: PlaylistSongScalarWhereInput | PlaylistSongScalarWhereInput[]
    id?: StringFilter<"PlaylistSong"> | string
    playlistId?: StringFilter<"PlaylistSong"> | string
    songId?: StringFilter<"PlaylistSong"> | string
    position?: IntFilter<"PlaylistSong"> | number
    addedBy?: StringNullableFilter<"PlaylistSong"> | string | null
    addedAt?: DateTimeFilter<"PlaylistSong"> | Date | string
  }

  export type ListeningHistoryUpsertWithWhereUniqueWithoutSongInput = {
    where: ListeningHistoryWhereUniqueInput
    update: XOR<ListeningHistoryUpdateWithoutSongInput, ListeningHistoryUncheckedUpdateWithoutSongInput>
    create: XOR<ListeningHistoryCreateWithoutSongInput, ListeningHistoryUncheckedCreateWithoutSongInput>
  }

  export type ListeningHistoryUpdateWithWhereUniqueWithoutSongInput = {
    where: ListeningHistoryWhereUniqueInput
    data: XOR<ListeningHistoryUpdateWithoutSongInput, ListeningHistoryUncheckedUpdateWithoutSongInput>
  }

  export type ListeningHistoryUpdateManyWithWhereWithoutSongInput = {
    where: ListeningHistoryScalarWhereInput
    data: XOR<ListeningHistoryUpdateManyMutationInput, ListeningHistoryUncheckedUpdateManyWithoutSongInput>
  }

  export type RecentlyPlayedUpsertWithWhereUniqueWithoutSongInput = {
    where: RecentlyPlayedWhereUniqueInput
    update: XOR<RecentlyPlayedUpdateWithoutSongInput, RecentlyPlayedUncheckedUpdateWithoutSongInput>
    create: XOR<RecentlyPlayedCreateWithoutSongInput, RecentlyPlayedUncheckedCreateWithoutSongInput>
  }

  export type RecentlyPlayedUpdateWithWhereUniqueWithoutSongInput = {
    where: RecentlyPlayedWhereUniqueInput
    data: XOR<RecentlyPlayedUpdateWithoutSongInput, RecentlyPlayedUncheckedUpdateWithoutSongInput>
  }

  export type RecentlyPlayedUpdateManyWithWhereWithoutSongInput = {
    where: RecentlyPlayedScalarWhereInput
    data: XOR<RecentlyPlayedUpdateManyMutationInput, RecentlyPlayedUncheckedUpdateManyWithoutSongInput>
  }

  export type PlaybackStateUpsertWithWhereUniqueWithoutCurrentSongInput = {
    where: PlaybackStateWhereUniqueInput
    update: XOR<PlaybackStateUpdateWithoutCurrentSongInput, PlaybackStateUncheckedUpdateWithoutCurrentSongInput>
    create: XOR<PlaybackStateCreateWithoutCurrentSongInput, PlaybackStateUncheckedCreateWithoutCurrentSongInput>
  }

  export type PlaybackStateUpdateWithWhereUniqueWithoutCurrentSongInput = {
    where: PlaybackStateWhereUniqueInput
    data: XOR<PlaybackStateUpdateWithoutCurrentSongInput, PlaybackStateUncheckedUpdateWithoutCurrentSongInput>
  }

  export type PlaybackStateUpdateManyWithWhereWithoutCurrentSongInput = {
    where: PlaybackStateScalarWhereInput
    data: XOR<PlaybackStateUpdateManyMutationInput, PlaybackStateUncheckedUpdateManyWithoutCurrentSongInput>
  }

  export type PlaybackStateScalarWhereInput = {
    AND?: PlaybackStateScalarWhereInput | PlaybackStateScalarWhereInput[]
    OR?: PlaybackStateScalarWhereInput[]
    NOT?: PlaybackStateScalarWhereInput | PlaybackStateScalarWhereInput[]
    userId?: StringFilter<"PlaybackState"> | string
    currentSongId?: StringNullableFilter<"PlaybackState"> | string | null
    progressMs?: IntFilter<"PlaybackState"> | number
    isPlaying?: BoolFilter<"PlaybackState"> | boolean
    shuffleMode?: EnumShuffleModeFilter<"PlaybackState"> | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFilter<"PlaybackState"> | $Enums.RepeatMode
    volume?: IntFilter<"PlaybackState"> | number
    contextType?: EnumContextTypeNullableFilter<"PlaybackState"> | $Enums.ContextType | null
    contextId?: StringNullableFilter<"PlaybackState"> | string | null
    activeDeviceId?: StringNullableFilter<"PlaybackState"> | string | null
    updatedAt?: DateTimeFilter<"PlaybackState"> | Date | string
  }

  export type PlaybackQueueUpsertWithWhereUniqueWithoutSongInput = {
    where: PlaybackQueueWhereUniqueInput
    update: XOR<PlaybackQueueUpdateWithoutSongInput, PlaybackQueueUncheckedUpdateWithoutSongInput>
    create: XOR<PlaybackQueueCreateWithoutSongInput, PlaybackQueueUncheckedCreateWithoutSongInput>
  }

  export type PlaybackQueueUpdateWithWhereUniqueWithoutSongInput = {
    where: PlaybackQueueWhereUniqueInput
    data: XOR<PlaybackQueueUpdateWithoutSongInput, PlaybackQueueUncheckedUpdateWithoutSongInput>
  }

  export type PlaybackQueueUpdateManyWithWhereWithoutSongInput = {
    where: PlaybackQueueScalarWhereInput
    data: XOR<PlaybackQueueUpdateManyMutationInput, PlaybackQueueUncheckedUpdateManyWithoutSongInput>
  }

  export type SongGenreCreateWithoutGenreInput = {
    song: SongCreateNestedOneWithoutGenresInput
  }

  export type SongGenreUncheckedCreateWithoutGenreInput = {
    songId: string
  }

  export type SongGenreCreateOrConnectWithoutGenreInput = {
    where: SongGenreWhereUniqueInput
    create: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput>
  }

  export type SongGenreCreateManyGenreInputEnvelope = {
    data: SongGenreCreateManyGenreInput | SongGenreCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type ArtistGenreCreateWithoutGenreInput = {
    artist: ArtistCreateNestedOneWithoutGenresInput
  }

  export type ArtistGenreUncheckedCreateWithoutGenreInput = {
    artistId: string
  }

  export type ArtistGenreCreateOrConnectWithoutGenreInput = {
    where: ArtistGenreWhereUniqueInput
    create: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput>
  }

  export type ArtistGenreCreateManyGenreInputEnvelope = {
    data: ArtistGenreCreateManyGenreInput | ArtistGenreCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type SongGenreUpsertWithWhereUniqueWithoutGenreInput = {
    where: SongGenreWhereUniqueInput
    update: XOR<SongGenreUpdateWithoutGenreInput, SongGenreUncheckedUpdateWithoutGenreInput>
    create: XOR<SongGenreCreateWithoutGenreInput, SongGenreUncheckedCreateWithoutGenreInput>
  }

  export type SongGenreUpdateWithWhereUniqueWithoutGenreInput = {
    where: SongGenreWhereUniqueInput
    data: XOR<SongGenreUpdateWithoutGenreInput, SongGenreUncheckedUpdateWithoutGenreInput>
  }

  export type SongGenreUpdateManyWithWhereWithoutGenreInput = {
    where: SongGenreScalarWhereInput
    data: XOR<SongGenreUpdateManyMutationInput, SongGenreUncheckedUpdateManyWithoutGenreInput>
  }

  export type ArtistGenreUpsertWithWhereUniqueWithoutGenreInput = {
    where: ArtistGenreWhereUniqueInput
    update: XOR<ArtistGenreUpdateWithoutGenreInput, ArtistGenreUncheckedUpdateWithoutGenreInput>
    create: XOR<ArtistGenreCreateWithoutGenreInput, ArtistGenreUncheckedCreateWithoutGenreInput>
  }

  export type ArtistGenreUpdateWithWhereUniqueWithoutGenreInput = {
    where: ArtistGenreWhereUniqueInput
    data: XOR<ArtistGenreUpdateWithoutGenreInput, ArtistGenreUncheckedUpdateWithoutGenreInput>
  }

  export type ArtistGenreUpdateManyWithWhereWithoutGenreInput = {
    where: ArtistGenreScalarWhereInput
    data: XOR<ArtistGenreUpdateManyMutationInput, ArtistGenreUncheckedUpdateManyWithoutGenreInput>
  }

  export type SongCreateWithoutGenresInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    album?: AlbumCreateNestedOneWithoutSongsInput
    primaryArtist: ArtistCreateNestedOneWithoutSongsInput
    songArtists?: SongArtistCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutGenresInput = {
    id?: string
    albumId?: string | null
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongUncheckedCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutGenresInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutGenresInput, SongUncheckedCreateWithoutGenresInput>
  }

  export type GenreCreateWithoutSongsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    color?: string | null
    createdAt?: Date | string
    artists?: ArtistGenreCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateWithoutSongsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    color?: string | null
    createdAt?: Date | string
    artists?: ArtistGenreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreCreateOrConnectWithoutSongsInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutSongsInput, GenreUncheckedCreateWithoutSongsInput>
  }

  export type SongUpsertWithoutGenresInput = {
    update: XOR<SongUpdateWithoutGenresInput, SongUncheckedUpdateWithoutGenresInput>
    create: XOR<SongCreateWithoutGenresInput, SongUncheckedCreateWithoutGenresInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutGenresInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutGenresInput, SongUncheckedUpdateWithoutGenresInput>
  }

  export type SongUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneWithoutSongsNestedInput
    primaryArtist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
    songArtists?: SongArtistUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songArtists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUncheckedUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput
  }

  export type GenreUpsertWithoutSongsInput = {
    update: XOR<GenreUpdateWithoutSongsInput, GenreUncheckedUpdateWithoutSongsInput>
    create: XOR<GenreCreateWithoutSongsInput, GenreUncheckedCreateWithoutSongsInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutSongsInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutSongsInput, GenreUncheckedUpdateWithoutSongsInput>
  }

  export type GenreUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artists?: ArtistGenreUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artists?: ArtistGenreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type ArtistCreateWithoutGenresInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutArtistInput
    albums?: AlbumCreateNestedManyWithoutArtistInput
    songs?: SongCreateNestedManyWithoutPrimaryArtistInput
    songArtists?: SongArtistCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutGenresInput = {
    id?: string
    userId?: string | null
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    songs?: SongUncheckedCreateNestedManyWithoutPrimaryArtistInput
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutGenresInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutGenresInput, ArtistUncheckedCreateWithoutGenresInput>
  }

  export type GenreCreateWithoutArtistsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    color?: string | null
    createdAt?: Date | string
    songs?: SongGenreCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateWithoutArtistsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    color?: string | null
    createdAt?: Date | string
    songs?: SongGenreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreCreateOrConnectWithoutArtistsInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutArtistsInput, GenreUncheckedCreateWithoutArtistsInput>
  }

  export type ArtistUpsertWithoutGenresInput = {
    update: XOR<ArtistUpdateWithoutGenresInput, ArtistUncheckedUpdateWithoutGenresInput>
    create: XOR<ArtistCreateWithoutGenresInput, ArtistUncheckedCreateWithoutGenresInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutGenresInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutGenresInput, ArtistUncheckedUpdateWithoutGenresInput>
  }

  export type ArtistUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutArtistNestedInput
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    songs?: SongUpdateManyWithoutPrimaryArtistNestedInput
    songArtists?: SongArtistUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    songs?: SongUncheckedUpdateManyWithoutPrimaryArtistNestedInput
    songArtists?: SongArtistUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type GenreUpsertWithoutArtistsInput = {
    update: XOR<GenreUpdateWithoutArtistsInput, GenreUncheckedUpdateWithoutArtistsInput>
    create: XOR<GenreCreateWithoutArtistsInput, GenreUncheckedCreateWithoutArtistsInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutArtistsInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutArtistsInput, GenreUncheckedUpdateWithoutArtistsInput>
  }

  export type GenreUpdateWithoutArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongGenreUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateWithoutArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongGenreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type SongCreateWithoutSongArtistsInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    album?: AlbumCreateNestedOneWithoutSongsInput
    primaryArtist: ArtistCreateNestedOneWithoutSongsInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutSongArtistsInput = {
    id?: string
    albumId?: string | null
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongUncheckedCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutSongArtistsInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutSongArtistsInput, SongUncheckedCreateWithoutSongArtistsInput>
  }

  export type ArtistCreateWithoutSongArtistsInput = {
    id?: string
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutArtistInput
    albums?: AlbumCreateNestedManyWithoutArtistInput
    songs?: SongCreateNestedManyWithoutPrimaryArtistInput
    genres?: ArtistGenreCreateNestedManyWithoutArtistInput
  }

  export type ArtistUncheckedCreateWithoutSongArtistsInput = {
    id?: string
    userId?: string | null
    name: string
    slug: string
    bio?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    verified?: boolean
    monthlyListeners?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    albums?: AlbumUncheckedCreateNestedManyWithoutArtistInput
    songs?: SongUncheckedCreateNestedManyWithoutPrimaryArtistInput
    genres?: ArtistGenreUncheckedCreateNestedManyWithoutArtistInput
  }

  export type ArtistCreateOrConnectWithoutSongArtistsInput = {
    where: ArtistWhereUniqueInput
    create: XOR<ArtistCreateWithoutSongArtistsInput, ArtistUncheckedCreateWithoutSongArtistsInput>
  }

  export type SongUpsertWithoutSongArtistsInput = {
    update: XOR<SongUpdateWithoutSongArtistsInput, SongUncheckedUpdateWithoutSongArtistsInput>
    create: XOR<SongCreateWithoutSongArtistsInput, SongUncheckedCreateWithoutSongArtistsInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutSongArtistsInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutSongArtistsInput, SongUncheckedUpdateWithoutSongArtistsInput>
  }

  export type SongUpdateWithoutSongArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneWithoutSongsNestedInput
    primaryArtist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutSongArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUncheckedUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput
  }

  export type ArtistUpsertWithoutSongArtistsInput = {
    update: XOR<ArtistUpdateWithoutSongArtistsInput, ArtistUncheckedUpdateWithoutSongArtistsInput>
    create: XOR<ArtistCreateWithoutSongArtistsInput, ArtistUncheckedCreateWithoutSongArtistsInput>
    where?: ArtistWhereInput
  }

  export type ArtistUpdateToOneWithWhereWithoutSongArtistsInput = {
    where?: ArtistWhereInput
    data: XOR<ArtistUpdateWithoutSongArtistsInput, ArtistUncheckedUpdateWithoutSongArtistsInput>
  }

  export type ArtistUpdateWithoutSongArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutArtistNestedInput
    albums?: AlbumUpdateManyWithoutArtistNestedInput
    songs?: SongUpdateManyWithoutPrimaryArtistNestedInput
    genres?: ArtistGenreUpdateManyWithoutArtistNestedInput
  }

  export type ArtistUncheckedUpdateWithoutSongArtistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    monthlyListeners?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albums?: AlbumUncheckedUpdateManyWithoutArtistNestedInput
    songs?: SongUncheckedUpdateManyWithoutPrimaryArtistNestedInput
    genres?: ArtistGenreUncheckedUpdateManyWithoutArtistNestedInput
  }

  export type UserCreateWithoutPlaylistsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlaylistsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlaylistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
  }

  export type PlaylistSongCreateWithoutPlaylistInput = {
    id?: string
    position: number
    addedBy?: string | null
    addedAt?: Date | string
    song: SongCreateNestedOneWithoutPlaylistSongsInput
  }

  export type PlaylistSongUncheckedCreateWithoutPlaylistInput = {
    id?: string
    songId: string
    position: number
    addedBy?: string | null
    addedAt?: Date | string
  }

  export type PlaylistSongCreateOrConnectWithoutPlaylistInput = {
    where: PlaylistSongWhereUniqueInput
    create: XOR<PlaylistSongCreateWithoutPlaylistInput, PlaylistSongUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistSongCreateManyPlaylistInputEnvelope = {
    data: PlaylistSongCreateManyPlaylistInput | PlaylistSongCreateManyPlaylistInput[]
    skipDuplicates?: boolean
  }

  export type UserFollowCreateWithoutPlaylistInput = {
    id?: string
    followingType: $Enums.FollowType
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowsInput
  }

  export type UserFollowUncheckedCreateWithoutPlaylistInput = {
    id?: string
    followerId: string
    followingType: $Enums.FollowType
    createdAt?: Date | string
  }

  export type UserFollowCreateOrConnectWithoutPlaylistInput = {
    where: UserFollowWhereUniqueInput
    create: XOR<UserFollowCreateWithoutPlaylistInput, UserFollowUncheckedCreateWithoutPlaylistInput>
  }

  export type UserFollowCreateManyPlaylistInputEnvelope = {
    data: UserFollowCreateManyPlaylistInput | UserFollowCreateManyPlaylistInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPlaylistsInput = {
    update: XOR<UserUpdateWithoutPlaylistsInput, UserUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<UserCreateWithoutPlaylistsInput, UserUncheckedCreateWithoutPlaylistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlaylistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlaylistsInput, UserUncheckedUpdateWithoutPlaylistsInput>
  }

  export type UserUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PlaylistSongUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistSongWhereUniqueInput
    update: XOR<PlaylistSongUpdateWithoutPlaylistInput, PlaylistSongUncheckedUpdateWithoutPlaylistInput>
    create: XOR<PlaylistSongCreateWithoutPlaylistInput, PlaylistSongUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistSongUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistSongWhereUniqueInput
    data: XOR<PlaylistSongUpdateWithoutPlaylistInput, PlaylistSongUncheckedUpdateWithoutPlaylistInput>
  }

  export type PlaylistSongUpdateManyWithWhereWithoutPlaylistInput = {
    where: PlaylistSongScalarWhereInput
    data: XOR<PlaylistSongUpdateManyMutationInput, PlaylistSongUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type UserFollowUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: UserFollowWhereUniqueInput
    update: XOR<UserFollowUpdateWithoutPlaylistInput, UserFollowUncheckedUpdateWithoutPlaylistInput>
    create: XOR<UserFollowCreateWithoutPlaylistInput, UserFollowUncheckedCreateWithoutPlaylistInput>
  }

  export type UserFollowUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: UserFollowWhereUniqueInput
    data: XOR<UserFollowUpdateWithoutPlaylistInput, UserFollowUncheckedUpdateWithoutPlaylistInput>
  }

  export type UserFollowUpdateManyWithWhereWithoutPlaylistInput = {
    where: UserFollowScalarWhereInput
    data: XOR<UserFollowUpdateManyMutationInput, UserFollowUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type PlaylistCreateWithoutSongsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaylistsInput
    followers?: UserFollowCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateWithoutSongsInput = {
    id?: string
    userId: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    followers?: UserFollowUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutSongsInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutSongsInput, PlaylistUncheckedCreateWithoutSongsInput>
  }

  export type SongCreateWithoutPlaylistSongsInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    album?: AlbumCreateNestedOneWithoutSongsInput
    primaryArtist: ArtistCreateNestedOneWithoutSongsInput
    songArtists?: SongArtistCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutPlaylistSongsInput = {
    id?: string
    albumId?: string | null
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutPlaylistSongsInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutPlaylistSongsInput, SongUncheckedCreateWithoutPlaylistSongsInput>
  }

  export type PlaylistUpsertWithoutSongsInput = {
    update: XOR<PlaylistUpdateWithoutSongsInput, PlaylistUncheckedUpdateWithoutSongsInput>
    create: XOR<PlaylistCreateWithoutSongsInput, PlaylistUncheckedCreateWithoutSongsInput>
    where?: PlaylistWhereInput
  }

  export type PlaylistUpdateToOneWithWhereWithoutSongsInput = {
    where?: PlaylistWhereInput
    data: XOR<PlaylistUpdateWithoutSongsInput, PlaylistUncheckedUpdateWithoutSongsInput>
  }

  export type PlaylistUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaylistsNestedInput
    followers?: UserFollowUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: UserFollowUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type SongUpsertWithoutPlaylistSongsInput = {
    update: XOR<SongUpdateWithoutPlaylistSongsInput, SongUncheckedUpdateWithoutPlaylistSongsInput>
    create: XOR<SongCreateWithoutPlaylistSongsInput, SongUncheckedCreateWithoutPlaylistSongsInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutPlaylistSongsInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutPlaylistSongsInput, SongUncheckedUpdateWithoutPlaylistSongsInput>
  }

  export type SongUpdateWithoutPlaylistSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneWithoutSongsNestedInput
    primaryArtist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
    songArtists?: SongArtistUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutPlaylistSongsInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songArtists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput
  }

  export type UserCreateWithoutFollowsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowsInput, UserUncheckedCreateWithoutFollowsInput>
  }

  export type PlaylistCreateWithoutFollowersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaylistsInput
    songs?: PlaylistSongCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateWithoutFollowersInput = {
    id?: string
    userId: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    songs?: PlaylistSongUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutFollowersInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutFollowersInput, PlaylistUncheckedCreateWithoutFollowersInput>
  }

  export type UserUpsertWithoutFollowsInput = {
    update: XOR<UserUpdateWithoutFollowsInput, UserUncheckedUpdateWithoutFollowsInput>
    create: XOR<UserCreateWithoutFollowsInput, UserUncheckedCreateWithoutFollowsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowsInput, UserUncheckedUpdateWithoutFollowsInput>
  }

  export type UserUpdateWithoutFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PlaylistUpsertWithoutFollowersInput = {
    update: XOR<PlaylistUpdateWithoutFollowersInput, PlaylistUncheckedUpdateWithoutFollowersInput>
    create: XOR<PlaylistCreateWithoutFollowersInput, PlaylistUncheckedCreateWithoutFollowersInput>
    where?: PlaylistWhereInput
  }

  export type PlaylistUpdateToOneWithWhereWithoutFollowersInput = {
    where?: PlaylistWhereInput
    data: XOR<PlaylistUpdateWithoutFollowersInput, PlaylistUncheckedUpdateWithoutFollowersInput>
  }

  export type PlaylistUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaylistsNestedInput
    songs?: PlaylistSongUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: PlaylistSongUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type UserCreateWithoutLibraryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLibraryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLibraryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLibraryInput, UserUncheckedCreateWithoutLibraryInput>
  }

  export type UserUpsertWithoutLibraryInput = {
    update: XOR<UserUpdateWithoutLibraryInput, UserUncheckedUpdateWithoutLibraryInput>
    create: XOR<UserCreateWithoutLibraryInput, UserUncheckedCreateWithoutLibraryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLibraryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLibraryInput, UserUncheckedUpdateWithoutLibraryInput>
  }

  export type UserUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutListeningHistoryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutListeningHistoryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutListeningHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListeningHistoryInput, UserUncheckedCreateWithoutListeningHistoryInput>
  }

  export type SongCreateWithoutListeningHistoryInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    album?: AlbumCreateNestedOneWithoutSongsInput
    primaryArtist: ArtistCreateNestedOneWithoutSongsInput
    songArtists?: SongArtistCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutListeningHistoryInput = {
    id?: string
    albumId?: string | null
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongUncheckedCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutListeningHistoryInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutListeningHistoryInput, SongUncheckedCreateWithoutListeningHistoryInput>
  }

  export type UserUpsertWithoutListeningHistoryInput = {
    update: XOR<UserUpdateWithoutListeningHistoryInput, UserUncheckedUpdateWithoutListeningHistoryInput>
    create: XOR<UserCreateWithoutListeningHistoryInput, UserUncheckedCreateWithoutListeningHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListeningHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListeningHistoryInput, UserUncheckedUpdateWithoutListeningHistoryInput>
  }

  export type UserUpdateWithoutListeningHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListeningHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SongUpsertWithoutListeningHistoryInput = {
    update: XOR<SongUpdateWithoutListeningHistoryInput, SongUncheckedUpdateWithoutListeningHistoryInput>
    create: XOR<SongCreateWithoutListeningHistoryInput, SongUncheckedCreateWithoutListeningHistoryInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutListeningHistoryInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutListeningHistoryInput, SongUncheckedUpdateWithoutListeningHistoryInput>
  }

  export type SongUpdateWithoutListeningHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneWithoutSongsNestedInput
    primaryArtist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
    songArtists?: SongArtistUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutListeningHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songArtists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUncheckedUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput
  }

  export type UserCreateWithoutRecentlyPlayedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecentlyPlayedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecentlyPlayedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecentlyPlayedInput, UserUncheckedCreateWithoutRecentlyPlayedInput>
  }

  export type SongCreateWithoutRecentlyPlayedInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    album?: AlbumCreateNestedOneWithoutSongsInput
    primaryArtist: ArtistCreateNestedOneWithoutSongsInput
    songArtists?: SongArtistCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutRecentlyPlayedInput = {
    id?: string
    albumId?: string | null
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongUncheckedCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput
    playbackQueues?: PlaybackQueueUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutRecentlyPlayedInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutRecentlyPlayedInput, SongUncheckedCreateWithoutRecentlyPlayedInput>
  }

  export type UserUpsertWithoutRecentlyPlayedInput = {
    update: XOR<UserUpdateWithoutRecentlyPlayedInput, UserUncheckedUpdateWithoutRecentlyPlayedInput>
    create: XOR<UserCreateWithoutRecentlyPlayedInput, UserUncheckedCreateWithoutRecentlyPlayedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecentlyPlayedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecentlyPlayedInput, UserUncheckedUpdateWithoutRecentlyPlayedInput>
  }

  export type UserUpdateWithoutRecentlyPlayedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecentlyPlayedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SongUpsertWithoutRecentlyPlayedInput = {
    update: XOR<SongUpdateWithoutRecentlyPlayedInput, SongUncheckedUpdateWithoutRecentlyPlayedInput>
    create: XOR<SongCreateWithoutRecentlyPlayedInput, SongUncheckedCreateWithoutRecentlyPlayedInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutRecentlyPlayedInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutRecentlyPlayedInput, SongUncheckedUpdateWithoutRecentlyPlayedInput>
  }

  export type SongUpdateWithoutRecentlyPlayedInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneWithoutSongsNestedInput
    primaryArtist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
    songArtists?: SongArtistUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutRecentlyPlayedInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songArtists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUncheckedUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput
  }

  export type UserCreateWithoutPlaybackQueueInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlaybackQueueInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlaybackQueueInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlaybackQueueInput, UserUncheckedCreateWithoutPlaybackQueueInput>
  }

  export type SongCreateWithoutPlaybackQueuesInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    album?: AlbumCreateNestedOneWithoutSongsInput
    primaryArtist: ArtistCreateNestedOneWithoutSongsInput
    songArtists?: SongArtistCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutCurrentSongInput
  }

  export type SongUncheckedCreateWithoutPlaybackQueuesInput = {
    id?: string
    albumId?: string | null
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongUncheckedCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutCurrentSongInput
  }

  export type SongCreateOrConnectWithoutPlaybackQueuesInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutPlaybackQueuesInput, SongUncheckedCreateWithoutPlaybackQueuesInput>
  }

  export type UserUpsertWithoutPlaybackQueueInput = {
    update: XOR<UserUpdateWithoutPlaybackQueueInput, UserUncheckedUpdateWithoutPlaybackQueueInput>
    create: XOR<UserCreateWithoutPlaybackQueueInput, UserUncheckedCreateWithoutPlaybackQueueInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlaybackQueueInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlaybackQueueInput, UserUncheckedUpdateWithoutPlaybackQueueInput>
  }

  export type UserUpdateWithoutPlaybackQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlaybackQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SongUpsertWithoutPlaybackQueuesInput = {
    update: XOR<SongUpdateWithoutPlaybackQueuesInput, SongUncheckedUpdateWithoutPlaybackQueuesInput>
    create: XOR<SongCreateWithoutPlaybackQueuesInput, SongUncheckedCreateWithoutPlaybackQueuesInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutPlaybackQueuesInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutPlaybackQueuesInput, SongUncheckedUpdateWithoutPlaybackQueuesInput>
  }

  export type SongUpdateWithoutPlaybackQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneWithoutSongsNestedInput
    primaryArtist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
    songArtists?: SongArtistUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutCurrentSongNestedInput
  }

  export type SongUncheckedUpdateWithoutPlaybackQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songArtists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUncheckedUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput
  }

  export type UserCreateWithoutPlaybackStateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlaybackStateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlaybackStateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlaybackStateInput, UserUncheckedCreateWithoutPlaybackStateInput>
  }

  export type SongCreateWithoutPlaybackStatesInput = {
    id?: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    album?: AlbumCreateNestedOneWithoutSongsInput
    primaryArtist: ArtistCreateNestedOneWithoutSongsInput
    songArtists?: SongArtistCreateNestedManyWithoutSongInput
    genres?: SongGenreCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutSongInput
    playbackQueues?: PlaybackQueueCreateNestedManyWithoutSongInput
  }

  export type SongUncheckedCreateWithoutPlaybackStatesInput = {
    id?: string
    albumId?: string | null
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    songArtists?: SongArtistUncheckedCreateNestedManyWithoutSongInput
    genres?: SongGenreUncheckedCreateNestedManyWithoutSongInput
    playlistSongs?: PlaylistSongUncheckedCreateNestedManyWithoutSongInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutSongInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutSongInput
    playbackQueues?: PlaybackQueueUncheckedCreateNestedManyWithoutSongInput
  }

  export type SongCreateOrConnectWithoutPlaybackStatesInput = {
    where: SongWhereUniqueInput
    create: XOR<SongCreateWithoutPlaybackStatesInput, SongUncheckedCreateWithoutPlaybackStatesInput>
  }

  export type UserDeviceCreateWithoutPlaybackStatesInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
    sessions?: UserSessionCreateNestedManyWithoutDeviceInput
    syncStates?: DeviceSyncStateCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceUncheckedCreateWithoutPlaybackStatesInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutDeviceInput
    syncStates?: DeviceSyncStateUncheckedCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferUncheckedCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferUncheckedCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceCreateOrConnectWithoutPlaybackStatesInput = {
    where: UserDeviceWhereUniqueInput
    create: XOR<UserDeviceCreateWithoutPlaybackStatesInput, UserDeviceUncheckedCreateWithoutPlaybackStatesInput>
  }

  export type UserUpsertWithoutPlaybackStateInput = {
    update: XOR<UserUpdateWithoutPlaybackStateInput, UserUncheckedUpdateWithoutPlaybackStateInput>
    create: XOR<UserCreateWithoutPlaybackStateInput, UserUncheckedCreateWithoutPlaybackStateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlaybackStateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlaybackStateInput, UserUncheckedUpdateWithoutPlaybackStateInput>
  }

  export type UserUpdateWithoutPlaybackStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlaybackStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SongUpsertWithoutPlaybackStatesInput = {
    update: XOR<SongUpdateWithoutPlaybackStatesInput, SongUncheckedUpdateWithoutPlaybackStatesInput>
    create: XOR<SongCreateWithoutPlaybackStatesInput, SongUncheckedCreateWithoutPlaybackStatesInput>
    where?: SongWhereInput
  }

  export type SongUpdateToOneWithWhereWithoutPlaybackStatesInput = {
    where?: SongWhereInput
    data: XOR<SongUpdateWithoutPlaybackStatesInput, SongUncheckedUpdateWithoutPlaybackStatesInput>
  }

  export type SongUpdateWithoutPlaybackStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneWithoutSongsNestedInput
    primaryArtist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
    songArtists?: SongArtistUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutSongNestedInput
    playbackQueues?: PlaybackQueueUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutPlaybackStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songArtists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUncheckedUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput
    playbackQueues?: PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput
  }

  export type UserDeviceUpsertWithoutPlaybackStatesInput = {
    update: XOR<UserDeviceUpdateWithoutPlaybackStatesInput, UserDeviceUncheckedUpdateWithoutPlaybackStatesInput>
    create: XOR<UserDeviceCreateWithoutPlaybackStatesInput, UserDeviceUncheckedCreateWithoutPlaybackStatesInput>
    where?: UserDeviceWhereInput
  }

  export type UserDeviceUpdateToOneWithWhereWithoutPlaybackStatesInput = {
    where?: UserDeviceWhereInput
    data: XOR<UserDeviceUpdateWithoutPlaybackStatesInput, UserDeviceUncheckedUpdateWithoutPlaybackStatesInput>
  }

  export type UserDeviceUpdateWithoutPlaybackStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
    sessions?: UserSessionUpdateManyWithoutDeviceNestedInput
    syncStates?: DeviceSyncStateUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateWithoutPlaybackStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutDeviceNestedInput
    syncStates?: DeviceSyncStateUncheckedUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUncheckedUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUncheckedUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserCreateWithoutOauthAccountsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOauthAccountsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOauthAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOauthAccountsInput, UserUncheckedCreateWithoutOauthAccountsInput>
  }

  export type UserUpsertWithoutOauthAccountsInput = {
    update: XOR<UserUpdateWithoutOauthAccountsInput, UserUncheckedUpdateWithoutOauthAccountsInput>
    create: XOR<UserCreateWithoutOauthAccountsInput, UserUncheckedCreateWithoutOauthAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOauthAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOauthAccountsInput, UserUncheckedUpdateWithoutOauthAccountsInput>
  }

  export type UserUpdateWithoutOauthAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOauthAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserDeviceCreateWithoutSessionsInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceUncheckedCreateWithoutSessionsInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateUncheckedCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferUncheckedCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferUncheckedCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceCreateOrConnectWithoutSessionsInput = {
    where: UserDeviceWhereUniqueInput
    create: XOR<UserDeviceCreateWithoutSessionsInput, UserDeviceUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserDeviceUpsertWithoutSessionsInput = {
    update: XOR<UserDeviceUpdateWithoutSessionsInput, UserDeviceUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserDeviceCreateWithoutSessionsInput, UserDeviceUncheckedCreateWithoutSessionsInput>
    where?: UserDeviceWhereInput
  }

  export type UserDeviceUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserDeviceWhereInput
    data: XOR<UserDeviceUpdateWithoutSessionsInput, UserDeviceUncheckedUpdateWithoutSessionsInput>
  }

  export type UserDeviceUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUncheckedUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUncheckedUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUncheckedUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserCreateWithoutDevicesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDevicesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDevicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
  }

  export type UserSessionCreateWithoutDeviceInput = {
    id?: string
    tokenHash: string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateWithoutDeviceInput = {
    id?: string
    userId: string
    tokenHash: string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutDeviceInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutDeviceInput, UserSessionUncheckedCreateWithoutDeviceInput>
  }

  export type UserSessionCreateManyDeviceInputEnvelope = {
    data: UserSessionCreateManyDeviceInput | UserSessionCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type PlaybackStateCreateWithoutActiveDeviceInput = {
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlaybackStateInput
    currentSong?: SongCreateNestedOneWithoutPlaybackStatesInput
  }

  export type PlaybackStateUncheckedCreateWithoutActiveDeviceInput = {
    userId: string
    currentSongId?: string | null
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    updatedAt?: Date | string
  }

  export type PlaybackStateCreateOrConnectWithoutActiveDeviceInput = {
    where: PlaybackStateWhereUniqueInput
    create: XOR<PlaybackStateCreateWithoutActiveDeviceInput, PlaybackStateUncheckedCreateWithoutActiveDeviceInput>
  }

  export type PlaybackStateCreateManyActiveDeviceInputEnvelope = {
    data: PlaybackStateCreateManyActiveDeviceInput | PlaybackStateCreateManyActiveDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DeviceSyncStateCreateWithoutDeviceInput = {
    id?: string
    userId: string
    syncType: $Enums.SyncType
    lastSyncVersion?: bigint | number
    lastSyncAt?: Date | string | null
    pendingChanges?: number
  }

  export type DeviceSyncStateUncheckedCreateWithoutDeviceInput = {
    id?: string
    userId: string
    syncType: $Enums.SyncType
    lastSyncVersion?: bigint | number
    lastSyncAt?: Date | string | null
    pendingChanges?: number
  }

  export type DeviceSyncStateCreateOrConnectWithoutDeviceInput = {
    where: DeviceSyncStateWhereUniqueInput
    create: XOR<DeviceSyncStateCreateWithoutDeviceInput, DeviceSyncStateUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceSyncStateCreateManyDeviceInputEnvelope = {
    data: DeviceSyncStateCreateManyDeviceInput | DeviceSyncStateCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type SyncLogCreateWithoutSourceDeviceInput = {
    id?: string
    userId: string
    entityType: string
    entityId: string
    action: $Enums.SyncAction
    version: bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SyncLogUncheckedCreateWithoutSourceDeviceInput = {
    id?: string
    userId: string
    entityType: string
    entityId: string
    action: $Enums.SyncAction
    version: bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SyncLogCreateOrConnectWithoutSourceDeviceInput = {
    where: SyncLogWhereUniqueInput
    create: XOR<SyncLogCreateWithoutSourceDeviceInput, SyncLogUncheckedCreateWithoutSourceDeviceInput>
  }

  export type SyncLogCreateManySourceDeviceInputEnvelope = {
    data: SyncLogCreateManySourceDeviceInput | SyncLogCreateManySourceDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DeviceTransferCreateWithoutFromDeviceInput = {
    id?: string
    userId: string
    status?: $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
    toDevice: UserDeviceCreateNestedOneWithoutTransfersToInput
  }

  export type DeviceTransferUncheckedCreateWithoutFromDeviceInput = {
    id?: string
    userId: string
    toDeviceId: string
    status?: $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type DeviceTransferCreateOrConnectWithoutFromDeviceInput = {
    where: DeviceTransferWhereUniqueInput
    create: XOR<DeviceTransferCreateWithoutFromDeviceInput, DeviceTransferUncheckedCreateWithoutFromDeviceInput>
  }

  export type DeviceTransferCreateManyFromDeviceInputEnvelope = {
    data: DeviceTransferCreateManyFromDeviceInput | DeviceTransferCreateManyFromDeviceInput[]
    skipDuplicates?: boolean
  }

  export type DeviceTransferCreateWithoutToDeviceInput = {
    id?: string
    userId: string
    status?: $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
    fromDevice: UserDeviceCreateNestedOneWithoutTransfersFromInput
  }

  export type DeviceTransferUncheckedCreateWithoutToDeviceInput = {
    id?: string
    userId: string
    fromDeviceId: string
    status?: $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type DeviceTransferCreateOrConnectWithoutToDeviceInput = {
    where: DeviceTransferWhereUniqueInput
    create: XOR<DeviceTransferCreateWithoutToDeviceInput, DeviceTransferUncheckedCreateWithoutToDeviceInput>
  }

  export type DeviceTransferCreateManyToDeviceInputEnvelope = {
    data: DeviceTransferCreateManyToDeviceInput | DeviceTransferCreateManyToDeviceInput[]
    skipDuplicates?: boolean
  }

  export type AdImpressionCreateWithoutDeviceInput = {
    id?: string
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdImpressionsInput
    ad: AdvertisementCreateNestedOneWithoutImpressionsInput
  }

  export type AdImpressionUncheckedCreateWithoutDeviceInput = {
    id?: string
    userId: string
    adId: string
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type AdImpressionCreateOrConnectWithoutDeviceInput = {
    where: AdImpressionWhereUniqueInput
    create: XOR<AdImpressionCreateWithoutDeviceInput, AdImpressionUncheckedCreateWithoutDeviceInput>
  }

  export type AdImpressionCreateManyDeviceInputEnvelope = {
    data: AdImpressionCreateManyDeviceInput | AdImpressionCreateManyDeviceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDevicesInput = {
    update: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDevicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserSessionUpsertWithWhereUniqueWithoutDeviceInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutDeviceInput, UserSessionUncheckedUpdateWithoutDeviceInput>
    create: XOR<UserSessionCreateWithoutDeviceInput, UserSessionUncheckedCreateWithoutDeviceInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutDeviceInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutDeviceInput, UserSessionUncheckedUpdateWithoutDeviceInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutDeviceInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutDeviceInput>
  }

  export type PlaybackStateUpsertWithWhereUniqueWithoutActiveDeviceInput = {
    where: PlaybackStateWhereUniqueInput
    update: XOR<PlaybackStateUpdateWithoutActiveDeviceInput, PlaybackStateUncheckedUpdateWithoutActiveDeviceInput>
    create: XOR<PlaybackStateCreateWithoutActiveDeviceInput, PlaybackStateUncheckedCreateWithoutActiveDeviceInput>
  }

  export type PlaybackStateUpdateWithWhereUniqueWithoutActiveDeviceInput = {
    where: PlaybackStateWhereUniqueInput
    data: XOR<PlaybackStateUpdateWithoutActiveDeviceInput, PlaybackStateUncheckedUpdateWithoutActiveDeviceInput>
  }

  export type PlaybackStateUpdateManyWithWhereWithoutActiveDeviceInput = {
    where: PlaybackStateScalarWhereInput
    data: XOR<PlaybackStateUpdateManyMutationInput, PlaybackStateUncheckedUpdateManyWithoutActiveDeviceInput>
  }

  export type DeviceSyncStateUpsertWithWhereUniqueWithoutDeviceInput = {
    where: DeviceSyncStateWhereUniqueInput
    update: XOR<DeviceSyncStateUpdateWithoutDeviceInput, DeviceSyncStateUncheckedUpdateWithoutDeviceInput>
    create: XOR<DeviceSyncStateCreateWithoutDeviceInput, DeviceSyncStateUncheckedCreateWithoutDeviceInput>
  }

  export type DeviceSyncStateUpdateWithWhereUniqueWithoutDeviceInput = {
    where: DeviceSyncStateWhereUniqueInput
    data: XOR<DeviceSyncStateUpdateWithoutDeviceInput, DeviceSyncStateUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceSyncStateUpdateManyWithWhereWithoutDeviceInput = {
    where: DeviceSyncStateScalarWhereInput
    data: XOR<DeviceSyncStateUpdateManyMutationInput, DeviceSyncStateUncheckedUpdateManyWithoutDeviceInput>
  }

  export type DeviceSyncStateScalarWhereInput = {
    AND?: DeviceSyncStateScalarWhereInput | DeviceSyncStateScalarWhereInput[]
    OR?: DeviceSyncStateScalarWhereInput[]
    NOT?: DeviceSyncStateScalarWhereInput | DeviceSyncStateScalarWhereInput[]
    id?: StringFilter<"DeviceSyncState"> | string
    userId?: StringFilter<"DeviceSyncState"> | string
    deviceId?: StringFilter<"DeviceSyncState"> | string
    syncType?: EnumSyncTypeFilter<"DeviceSyncState"> | $Enums.SyncType
    lastSyncVersion?: BigIntFilter<"DeviceSyncState"> | bigint | number
    lastSyncAt?: DateTimeNullableFilter<"DeviceSyncState"> | Date | string | null
    pendingChanges?: IntFilter<"DeviceSyncState"> | number
  }

  export type SyncLogUpsertWithWhereUniqueWithoutSourceDeviceInput = {
    where: SyncLogWhereUniqueInput
    update: XOR<SyncLogUpdateWithoutSourceDeviceInput, SyncLogUncheckedUpdateWithoutSourceDeviceInput>
    create: XOR<SyncLogCreateWithoutSourceDeviceInput, SyncLogUncheckedCreateWithoutSourceDeviceInput>
  }

  export type SyncLogUpdateWithWhereUniqueWithoutSourceDeviceInput = {
    where: SyncLogWhereUniqueInput
    data: XOR<SyncLogUpdateWithoutSourceDeviceInput, SyncLogUncheckedUpdateWithoutSourceDeviceInput>
  }

  export type SyncLogUpdateManyWithWhereWithoutSourceDeviceInput = {
    where: SyncLogScalarWhereInput
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyWithoutSourceDeviceInput>
  }

  export type SyncLogScalarWhereInput = {
    AND?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
    OR?: SyncLogScalarWhereInput[]
    NOT?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    userId?: StringFilter<"SyncLog"> | string
    entityType?: StringFilter<"SyncLog"> | string
    entityId?: StringFilter<"SyncLog"> | string
    action?: EnumSyncActionFilter<"SyncLog"> | $Enums.SyncAction
    version?: BigIntFilter<"SyncLog"> | bigint | number
    payload?: JsonNullableFilter<"SyncLog">
    sourceDeviceId?: StringNullableFilter<"SyncLog"> | string | null
    createdAt?: DateTimeFilter<"SyncLog"> | Date | string
  }

  export type DeviceTransferUpsertWithWhereUniqueWithoutFromDeviceInput = {
    where: DeviceTransferWhereUniqueInput
    update: XOR<DeviceTransferUpdateWithoutFromDeviceInput, DeviceTransferUncheckedUpdateWithoutFromDeviceInput>
    create: XOR<DeviceTransferCreateWithoutFromDeviceInput, DeviceTransferUncheckedCreateWithoutFromDeviceInput>
  }

  export type DeviceTransferUpdateWithWhereUniqueWithoutFromDeviceInput = {
    where: DeviceTransferWhereUniqueInput
    data: XOR<DeviceTransferUpdateWithoutFromDeviceInput, DeviceTransferUncheckedUpdateWithoutFromDeviceInput>
  }

  export type DeviceTransferUpdateManyWithWhereWithoutFromDeviceInput = {
    where: DeviceTransferScalarWhereInput
    data: XOR<DeviceTransferUpdateManyMutationInput, DeviceTransferUncheckedUpdateManyWithoutFromDeviceInput>
  }

  export type DeviceTransferScalarWhereInput = {
    AND?: DeviceTransferScalarWhereInput | DeviceTransferScalarWhereInput[]
    OR?: DeviceTransferScalarWhereInput[]
    NOT?: DeviceTransferScalarWhereInput | DeviceTransferScalarWhereInput[]
    id?: StringFilter<"DeviceTransfer"> | string
    userId?: StringFilter<"DeviceTransfer"> | string
    fromDeviceId?: StringFilter<"DeviceTransfer"> | string
    toDeviceId?: StringFilter<"DeviceTransfer"> | string
    status?: EnumTransferStatusFilter<"DeviceTransfer"> | $Enums.TransferStatus
    transferData?: JsonNullableFilter<"DeviceTransfer">
    createdAt?: DateTimeFilter<"DeviceTransfer"> | Date | string
    expiresAt?: DateTimeFilter<"DeviceTransfer"> | Date | string
  }

  export type DeviceTransferUpsertWithWhereUniqueWithoutToDeviceInput = {
    where: DeviceTransferWhereUniqueInput
    update: XOR<DeviceTransferUpdateWithoutToDeviceInput, DeviceTransferUncheckedUpdateWithoutToDeviceInput>
    create: XOR<DeviceTransferCreateWithoutToDeviceInput, DeviceTransferUncheckedCreateWithoutToDeviceInput>
  }

  export type DeviceTransferUpdateWithWhereUniqueWithoutToDeviceInput = {
    where: DeviceTransferWhereUniqueInput
    data: XOR<DeviceTransferUpdateWithoutToDeviceInput, DeviceTransferUncheckedUpdateWithoutToDeviceInput>
  }

  export type DeviceTransferUpdateManyWithWhereWithoutToDeviceInput = {
    where: DeviceTransferScalarWhereInput
    data: XOR<DeviceTransferUpdateManyMutationInput, DeviceTransferUncheckedUpdateManyWithoutToDeviceInput>
  }

  export type AdImpressionUpsertWithWhereUniqueWithoutDeviceInput = {
    where: AdImpressionWhereUniqueInput
    update: XOR<AdImpressionUpdateWithoutDeviceInput, AdImpressionUncheckedUpdateWithoutDeviceInput>
    create: XOR<AdImpressionCreateWithoutDeviceInput, AdImpressionUncheckedCreateWithoutDeviceInput>
  }

  export type AdImpressionUpdateWithWhereUniqueWithoutDeviceInput = {
    where: AdImpressionWhereUniqueInput
    data: XOR<AdImpressionUpdateWithoutDeviceInput, AdImpressionUncheckedUpdateWithoutDeviceInput>
  }

  export type AdImpressionUpdateManyWithWhereWithoutDeviceInput = {
    where: AdImpressionScalarWhereInput
    data: XOR<AdImpressionUpdateManyMutationInput, AdImpressionUncheckedUpdateManyWithoutDeviceInput>
  }

  export type UserDeviceCreateWithoutSyncStatesInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
    sessions?: UserSessionCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutActiveDeviceInput
    syncLogs?: SyncLogCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceUncheckedCreateWithoutSyncStatesInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutActiveDeviceInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferUncheckedCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferUncheckedCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceCreateOrConnectWithoutSyncStatesInput = {
    where: UserDeviceWhereUniqueInput
    create: XOR<UserDeviceCreateWithoutSyncStatesInput, UserDeviceUncheckedCreateWithoutSyncStatesInput>
  }

  export type UserDeviceUpsertWithoutSyncStatesInput = {
    update: XOR<UserDeviceUpdateWithoutSyncStatesInput, UserDeviceUncheckedUpdateWithoutSyncStatesInput>
    create: XOR<UserDeviceCreateWithoutSyncStatesInput, UserDeviceUncheckedCreateWithoutSyncStatesInput>
    where?: UserDeviceWhereInput
  }

  export type UserDeviceUpdateToOneWithWhereWithoutSyncStatesInput = {
    where?: UserDeviceWhereInput
    data: XOR<UserDeviceUpdateWithoutSyncStatesInput, UserDeviceUncheckedUpdateWithoutSyncStatesInput>
  }

  export type UserDeviceUpdateWithoutSyncStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
    sessions?: UserSessionUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutActiveDeviceNestedInput
    syncLogs?: SyncLogUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateWithoutSyncStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutActiveDeviceNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUncheckedUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUncheckedUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceCreateWithoutSyncLogsInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
    sessions?: UserSessionCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateCreateNestedManyWithoutDeviceInput
    transfersFrom?: DeviceTransferCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceUncheckedCreateWithoutSyncLogsInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateUncheckedCreateNestedManyWithoutDeviceInput
    transfersFrom?: DeviceTransferUncheckedCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferUncheckedCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceCreateOrConnectWithoutSyncLogsInput = {
    where: UserDeviceWhereUniqueInput
    create: XOR<UserDeviceCreateWithoutSyncLogsInput, UserDeviceUncheckedCreateWithoutSyncLogsInput>
  }

  export type UserDeviceUpsertWithoutSyncLogsInput = {
    update: XOR<UserDeviceUpdateWithoutSyncLogsInput, UserDeviceUncheckedUpdateWithoutSyncLogsInput>
    create: XOR<UserDeviceCreateWithoutSyncLogsInput, UserDeviceUncheckedCreateWithoutSyncLogsInput>
    where?: UserDeviceWhereInput
  }

  export type UserDeviceUpdateToOneWithWhereWithoutSyncLogsInput = {
    where?: UserDeviceWhereInput
    data: XOR<UserDeviceUpdateWithoutSyncLogsInput, UserDeviceUncheckedUpdateWithoutSyncLogsInput>
  }

  export type UserDeviceUpdateWithoutSyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
    sessions?: UserSessionUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUpdateManyWithoutDeviceNestedInput
    transfersFrom?: DeviceTransferUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateWithoutSyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUncheckedUpdateManyWithoutDeviceNestedInput
    transfersFrom?: DeviceTransferUncheckedUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUncheckedUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceCreateWithoutTransfersFromInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
    sessions?: UserSessionCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogCreateNestedManyWithoutSourceDeviceInput
    transfersTo?: DeviceTransferCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceUncheckedCreateWithoutTransfersFromInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateUncheckedCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutSourceDeviceInput
    transfersTo?: DeviceTransferUncheckedCreateNestedManyWithoutToDeviceInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceCreateOrConnectWithoutTransfersFromInput = {
    where: UserDeviceWhereUniqueInput
    create: XOR<UserDeviceCreateWithoutTransfersFromInput, UserDeviceUncheckedCreateWithoutTransfersFromInput>
  }

  export type UserDeviceCreateWithoutTransfersToInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
    sessions?: UserSessionCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferCreateNestedManyWithoutFromDeviceInput
    adImpressions?: AdImpressionCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceUncheckedCreateWithoutTransfersToInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateUncheckedCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferUncheckedCreateNestedManyWithoutFromDeviceInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutDeviceInput
  }

  export type UserDeviceCreateOrConnectWithoutTransfersToInput = {
    where: UserDeviceWhereUniqueInput
    create: XOR<UserDeviceCreateWithoutTransfersToInput, UserDeviceUncheckedCreateWithoutTransfersToInput>
  }

  export type UserDeviceUpsertWithoutTransfersFromInput = {
    update: XOR<UserDeviceUpdateWithoutTransfersFromInput, UserDeviceUncheckedUpdateWithoutTransfersFromInput>
    create: XOR<UserDeviceCreateWithoutTransfersFromInput, UserDeviceUncheckedCreateWithoutTransfersFromInput>
    where?: UserDeviceWhereInput
  }

  export type UserDeviceUpdateToOneWithWhereWithoutTransfersFromInput = {
    where?: UserDeviceWhereInput
    data: XOR<UserDeviceUpdateWithoutTransfersFromInput, UserDeviceUncheckedUpdateWithoutTransfersFromInput>
  }

  export type UserDeviceUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
    sessions?: UserSessionUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUpdateManyWithoutSourceDeviceNestedInput
    transfersTo?: DeviceTransferUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUncheckedUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutSourceDeviceNestedInput
    transfersTo?: DeviceTransferUncheckedUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUpsertWithoutTransfersToInput = {
    update: XOR<UserDeviceUpdateWithoutTransfersToInput, UserDeviceUncheckedUpdateWithoutTransfersToInput>
    create: XOR<UserDeviceCreateWithoutTransfersToInput, UserDeviceUncheckedCreateWithoutTransfersToInput>
    where?: UserDeviceWhereInput
  }

  export type UserDeviceUpdateToOneWithWhereWithoutTransfersToInput = {
    where?: UserDeviceWhereInput
    data: XOR<UserDeviceUpdateWithoutTransfersToInput, UserDeviceUncheckedUpdateWithoutTransfersToInput>
  }

  export type UserDeviceUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
    sessions?: UserSessionUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUpdateManyWithoutFromDeviceNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUncheckedUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUncheckedUpdateManyWithoutFromDeviceNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserSubscriptionCreateWithoutPlanInput = {
    id?: string
    status?: $Enums.SubscriptionStatus
    billingCycle?: $Enums.BillingCycle
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type UserSubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    status?: $Enums.SubscriptionStatus
    billingCycle?: $Enums.BillingCycle
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionCreateOrConnectWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type UserSubscriptionCreateManyPlanInputEnvelope = {
    data: UserSubscriptionCreateManyPlanInput | UserSubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    update: XOR<UserSubscriptionUpdateWithoutPlanInput, UserSubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<UserSubscriptionCreateWithoutPlanInput, UserSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type UserSubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: UserSubscriptionWhereUniqueInput
    data: XOR<UserSubscriptionUpdateWithoutPlanInput, UserSubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type UserSubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: UserSubscriptionScalarWhereInput
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxDevices?: number
    hasAds?: boolean
    canDownload?: boolean
    audioQuality?: $Enums.AudioQuality
    smartShuffle?: boolean
    skipLimit?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceMonthly?: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    currency?: string
    maxDevices?: number
    hasAds?: boolean
    canDownload?: boolean
    audioQuality?: $Enums.AudioQuality
    smartShuffle?: boolean
    skipLimit?: number | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: SubscriptionPlanWhereUniqueInput
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SubscriptionPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<SubscriptionPlanCreateWithoutSubscriptionsInput, SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: SubscriptionPlanWhereInput
  }

  export type SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: SubscriptionPlanWhereInput
    data: XOR<SubscriptionPlanUpdateWithoutSubscriptionsInput, SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxDevices?: IntFieldUpdateOperationsInput | number
    hasAds?: BoolFieldUpdateOperationsInput | boolean
    canDownload?: BoolFieldUpdateOperationsInput | boolean
    audioQuality?: EnumAudioQualityFieldUpdateOperationsInput | $Enums.AudioQuality
    smartShuffle?: BoolFieldUpdateOperationsInput | boolean
    skipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    maxDevices?: IntFieldUpdateOperationsInput | number
    hasAds?: BoolFieldUpdateOperationsInput | boolean
    canDownload?: BoolFieldUpdateOperationsInput | boolean
    audioQuality?: EnumAudioQualityFieldUpdateOperationsInput | $Enums.AudioQuality
    smartShuffle?: BoolFieldUpdateOperationsInput | boolean
    skipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionCreateWithoutAdInput = {
    id?: string
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdImpressionsInput
    device?: UserDeviceCreateNestedOneWithoutAdImpressionsInput
  }

  export type AdImpressionUncheckedCreateWithoutAdInput = {
    id?: string
    userId: string
    deviceId?: string | null
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type AdImpressionCreateOrConnectWithoutAdInput = {
    where: AdImpressionWhereUniqueInput
    create: XOR<AdImpressionCreateWithoutAdInput, AdImpressionUncheckedCreateWithoutAdInput>
  }

  export type AdImpressionCreateManyAdInputEnvelope = {
    data: AdImpressionCreateManyAdInput | AdImpressionCreateManyAdInput[]
    skipDuplicates?: boolean
  }

  export type AdImpressionUpsertWithWhereUniqueWithoutAdInput = {
    where: AdImpressionWhereUniqueInput
    update: XOR<AdImpressionUpdateWithoutAdInput, AdImpressionUncheckedUpdateWithoutAdInput>
    create: XOR<AdImpressionCreateWithoutAdInput, AdImpressionUncheckedCreateWithoutAdInput>
  }

  export type AdImpressionUpdateWithWhereUniqueWithoutAdInput = {
    where: AdImpressionWhereUniqueInput
    data: XOR<AdImpressionUpdateWithoutAdInput, AdImpressionUncheckedUpdateWithoutAdInput>
  }

  export type AdImpressionUpdateManyWithWhereWithoutAdInput = {
    where: AdImpressionScalarWhereInput
    data: XOR<AdImpressionUpdateManyMutationInput, AdImpressionUncheckedUpdateManyWithoutAdInput>
  }

  export type UserCreateWithoutAdImpressionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdImpressionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adSettings?: UserAdSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdImpressionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdImpressionsInput, UserUncheckedCreateWithoutAdImpressionsInput>
  }

  export type AdvertisementCreateWithoutImpressionsInput = {
    id?: string
    name: string
    advertiser: string
    adType: $Enums.AdType
    mediaUrl: string
    clickUrl?: string | null
    durationMs?: number | null
    targetCountries?: AdvertisementCreatetargetCountriesInput | string[]
    targetAgeMin?: number | null
    targetAgeMax?: number | null
    targetGenres?: AdvertisementCreatetargetGenresInput | string[]
    priority?: number
    budget?: Decimal | DecimalJsLike | number | string | null
    costPerImpression?: Decimal | DecimalJsLike | number | string | null
    costPerClick?: Decimal | DecimalJsLike | number | string | null
    totalImpressions?: bigint | number
    totalClicks?: bigint | number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvertisementUncheckedCreateWithoutImpressionsInput = {
    id?: string
    name: string
    advertiser: string
    adType: $Enums.AdType
    mediaUrl: string
    clickUrl?: string | null
    durationMs?: number | null
    targetCountries?: AdvertisementCreatetargetCountriesInput | string[]
    targetAgeMin?: number | null
    targetAgeMax?: number | null
    targetGenres?: AdvertisementCreatetargetGenresInput | string[]
    priority?: number
    budget?: Decimal | DecimalJsLike | number | string | null
    costPerImpression?: Decimal | DecimalJsLike | number | string | null
    costPerClick?: Decimal | DecimalJsLike | number | string | null
    totalImpressions?: bigint | number
    totalClicks?: bigint | number
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvertisementCreateOrConnectWithoutImpressionsInput = {
    where: AdvertisementWhereUniqueInput
    create: XOR<AdvertisementCreateWithoutImpressionsInput, AdvertisementUncheckedCreateWithoutImpressionsInput>
  }

  export type UserDeviceCreateWithoutAdImpressionsInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
    sessions?: UserSessionCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferCreateNestedManyWithoutToDeviceInput
  }

  export type UserDeviceUncheckedCreateWithoutAdImpressionsInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutDeviceInput
    playbackStates?: PlaybackStateUncheckedCreateNestedManyWithoutActiveDeviceInput
    syncStates?: DeviceSyncStateUncheckedCreateNestedManyWithoutDeviceInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutSourceDeviceInput
    transfersFrom?: DeviceTransferUncheckedCreateNestedManyWithoutFromDeviceInput
    transfersTo?: DeviceTransferUncheckedCreateNestedManyWithoutToDeviceInput
  }

  export type UserDeviceCreateOrConnectWithoutAdImpressionsInput = {
    where: UserDeviceWhereUniqueInput
    create: XOR<UserDeviceCreateWithoutAdImpressionsInput, UserDeviceUncheckedCreateWithoutAdImpressionsInput>
  }

  export type UserUpsertWithoutAdImpressionsInput = {
    update: XOR<UserUpdateWithoutAdImpressionsInput, UserUncheckedUpdateWithoutAdImpressionsInput>
    create: XOR<UserCreateWithoutAdImpressionsInput, UserUncheckedCreateWithoutAdImpressionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdImpressionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdImpressionsInput, UserUncheckedUpdateWithoutAdImpressionsInput>
  }

  export type UserUpdateWithoutAdImpressionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdImpressionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adSettings?: UserAdSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdvertisementUpsertWithoutImpressionsInput = {
    update: XOR<AdvertisementUpdateWithoutImpressionsInput, AdvertisementUncheckedUpdateWithoutImpressionsInput>
    create: XOR<AdvertisementCreateWithoutImpressionsInput, AdvertisementUncheckedCreateWithoutImpressionsInput>
    where?: AdvertisementWhereInput
  }

  export type AdvertisementUpdateToOneWithWhereWithoutImpressionsInput = {
    where?: AdvertisementWhereInput
    data: XOR<AdvertisementUpdateWithoutImpressionsInput, AdvertisementUncheckedUpdateWithoutImpressionsInput>
  }

  export type AdvertisementUpdateWithoutImpressionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    advertiser?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    mediaUrl?: StringFieldUpdateOperationsInput | string
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    targetCountries?: AdvertisementUpdatetargetCountriesInput | string[]
    targetAgeMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetAgeMax?: NullableIntFieldUpdateOperationsInput | number | null
    targetGenres?: AdvertisementUpdatetargetGenresInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerImpression?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerClick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalImpressions?: BigIntFieldUpdateOperationsInput | bigint | number
    totalClicks?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisementUncheckedUpdateWithoutImpressionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    advertiser?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    mediaUrl?: StringFieldUpdateOperationsInput | string
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    targetCountries?: AdvertisementUpdatetargetCountriesInput | string[]
    targetAgeMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetAgeMax?: NullableIntFieldUpdateOperationsInput | number | null
    targetGenres?: AdvertisementUpdatetargetGenresInput | string[]
    priority?: IntFieldUpdateOperationsInput | number
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerImpression?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    costPerClick?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalImpressions?: BigIntFieldUpdateOperationsInput | bigint | number
    totalClicks?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceUpsertWithoutAdImpressionsInput = {
    update: XOR<UserDeviceUpdateWithoutAdImpressionsInput, UserDeviceUncheckedUpdateWithoutAdImpressionsInput>
    create: XOR<UserDeviceCreateWithoutAdImpressionsInput, UserDeviceUncheckedCreateWithoutAdImpressionsInput>
    where?: UserDeviceWhereInput
  }

  export type UserDeviceUpdateToOneWithWhereWithoutAdImpressionsInput = {
    where?: UserDeviceWhereInput
    data: XOR<UserDeviceUpdateWithoutAdImpressionsInput, UserDeviceUncheckedUpdateWithoutAdImpressionsInput>
  }

  export type UserDeviceUpdateWithoutAdImpressionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
    sessions?: UserSessionUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUpdateManyWithoutToDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateWithoutAdImpressionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUncheckedUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUncheckedUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUncheckedUpdateManyWithoutToDeviceNestedInput
  }

  export type UserCreateWithoutAdSettingsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    devices?: UserDeviceCreateNestedManyWithoutUserInput
    playlists?: PlaylistCreateNestedManyWithoutUserInput
    follows?: UserFollowCreateNestedManyWithoutFollowerInput
    library?: UserLibraryCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdSettingsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    subscriptionType?: $Enums.SubscriptionType
    isArtist?: boolean
    isActive?: boolean
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    artist?: ArtistUncheckedCreateNestedOneWithoutUserInput
    oauthAccounts?: UserOAuthAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    devices?: UserDeviceUncheckedCreateNestedManyWithoutUserInput
    playlists?: PlaylistUncheckedCreateNestedManyWithoutUserInput
    follows?: UserFollowUncheckedCreateNestedManyWithoutFollowerInput
    library?: UserLibraryUncheckedCreateNestedManyWithoutUserInput
    listeningHistory?: ListeningHistoryUncheckedCreateNestedManyWithoutUserInput
    recentlyPlayed?: RecentlyPlayedUncheckedCreateNestedManyWithoutUserInput
    playbackState?: PlaybackStateUncheckedCreateNestedOneWithoutUserInput
    playbackQueue?: PlaybackQueueUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    adImpressions?: AdImpressionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdSettingsInput, UserUncheckedCreateWithoutAdSettingsInput>
  }

  export type UserUpsertWithoutAdSettingsInput = {
    update: XOR<UserUpdateWithoutAdSettingsInput, UserUncheckedUpdateWithoutAdSettingsInput>
    create: XOR<UserCreateWithoutAdSettingsInput, UserUncheckedCreateWithoutAdSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdSettingsInput, UserUncheckedUpdateWithoutAdSettingsInput>
  }

  export type UserUpdateWithoutAdSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUpdateManyWithoutUserNestedInput
    follows?: UserFollowUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    isArtist?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artist?: ArtistUncheckedUpdateOneWithoutUserNestedInput
    oauthAccounts?: UserOAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: UserDeviceUncheckedUpdateManyWithoutUserNestedInput
    playlists?: PlaylistUncheckedUpdateManyWithoutUserNestedInput
    follows?: UserFollowUncheckedUpdateManyWithoutFollowerNestedInput
    library?: UserLibraryUncheckedUpdateManyWithoutUserNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutUserNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutUserNestedInput
    playbackState?: PlaybackStateUncheckedUpdateOneWithoutUserNestedInput
    playbackQueue?: PlaybackQueueUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserOAuthAccountCreateManyUserInput = {
    id?: string
    provider: string
    providerUserId: string
    email?: string | null
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    deviceId?: string | null
    tokenHash: string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
  }

  export type UserDeviceCreateManyUserInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceName?: string | null
    deviceToken?: string | null
    appVersion?: string | null
    osVersion?: string | null
    isActive?: boolean
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlaylistCreateManyUserInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    isPublic?: boolean
    isCollaborative?: boolean
    totalTracks?: number
    durationMs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFollowCreateManyFollowerInput = {
    id?: string
    followingType: $Enums.FollowType
    followingId: string
    createdAt?: Date | string
  }

  export type UserLibraryCreateManyUserInput = {
    id?: string
    itemType: $Enums.LibraryItemType
    itemId: string
    addedAt?: Date | string
  }

  export type ListeningHistoryCreateManyUserInput = {
    id?: string
    songId: string
    playedAt?: Date | string
    durationMs: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type RecentlyPlayedCreateManyUserInput = {
    id?: string
    songId: string
    playedAt?: Date | string
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type PlaybackQueueCreateManyUserInput = {
    id?: string
    songId: string
    position: number
    addedAt?: Date | string
  }

  export type UserSubscriptionCreateManyUserInput = {
    id?: string
    planId: string
    status?: $Enums.SubscriptionStatus
    billingCycle?: $Enums.BillingCycle
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdImpressionCreateManyUserInput = {
    id?: string
    adId: string
    deviceId?: string | null
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type UserOAuthAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerUserId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOAuthAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerUserId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOAuthAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerUserId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    device?: UserDeviceUpdateOneWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDeviceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutDeviceNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutActiveDeviceNestedInput
    syncStates?: DeviceSyncStateUncheckedUpdateManyWithoutDeviceNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutSourceDeviceNestedInput
    transfersFrom?: DeviceTransferUncheckedUpdateManyWithoutFromDeviceNestedInput
    transfersTo?: DeviceTransferUncheckedUpdateManyWithoutToDeviceNestedInput
    adImpressions?: AdImpressionUncheckedUpdateManyWithoutDeviceNestedInput
  }

  export type UserDeviceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    appVersion?: NullableStringFieldUpdateOperationsInput | string | null
    osVersion?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: PlaylistSongUpdateManyWithoutPlaylistNestedInput
    followers?: UserFollowUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: PlaylistSongUncheckedUpdateManyWithoutPlaylistNestedInput
    followers?: UserFollowUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isCollaborative?: BoolFieldUpdateOperationsInput | boolean
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlist?: PlaylistUpdateOneWithoutFollowersNestedInput
  }

  export type UserFollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLibraryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: EnumLibraryItemTypeFieldUpdateOperationsInput | $Enums.LibraryItemType
    itemId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    song?: SongUpdateOneRequiredWithoutListeningHistoryNestedInput
  }

  export type ListeningHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListeningHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecentlyPlayedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    song?: SongUpdateOneRequiredWithoutRecentlyPlayedNestedInput
  }

  export type RecentlyPlayedUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecentlyPlayedUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaybackQueueUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    song?: SongUpdateOneRequiredWithoutPlaybackQueuesNestedInput
  }

  export type PlaybackQueueUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackQueueUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ad?: AdvertisementUpdateOneRequiredWithoutImpressionsNestedInput
    device?: UserDeviceUpdateOneWithoutAdImpressionsNestedInput
  }

  export type AdImpressionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumCreateManyArtistInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    coverUrl?: string | null
    releaseDate?: Date | string | null
    albumType?: $Enums.AlbumType
    totalTracks?: number
    durationMs?: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SongCreateManyPrimaryArtistInput = {
    id?: string
    albumId?: string | null
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SongArtistCreateManyArtistInput = {
    songId: string
    role?: $Enums.ArtistRole
  }

  export type ArtistGenreCreateManyArtistInput = {
    genreId: string
  }

  export type AlbumUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songs?: SongUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateManyWithoutArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    albumType?: EnumAlbumTypeFieldUpdateOperationsInput | $Enums.AlbumType
    totalTracks?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongUpdateWithoutPrimaryArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneWithoutSongsNestedInput
    songArtists?: SongArtistUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutPrimaryArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songArtists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUncheckedUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateManyWithoutPrimaryArtistInput = {
    id?: StringFieldUpdateOperationsInput | string
    albumId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongArtistUpdateWithoutArtistInput = {
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    song?: SongUpdateOneRequiredWithoutSongArtistsNestedInput
  }

  export type SongArtistUncheckedUpdateWithoutArtistInput = {
    songId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
  }

  export type SongArtistUncheckedUpdateManyWithoutArtistInput = {
    songId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
  }

  export type ArtistGenreUpdateWithoutArtistInput = {
    genre?: GenreUpdateOneRequiredWithoutArtistsNestedInput
  }

  export type ArtistGenreUncheckedUpdateWithoutArtistInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreUncheckedUpdateManyWithoutArtistInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type SongCreateManyAlbumInput = {
    id?: string
    artistId: string
    title: string
    slug: string
    trackNumber?: number | null
    discNumber?: number
    durationMs: number
    audioUrl: string
    previewUrl?: string | null
    lyricsUrl?: string | null
    isExplicit?: boolean
    isPlayable?: boolean
    playCount?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SongUpdateWithoutAlbumInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryArtist?: ArtistUpdateOneRequiredWithoutSongsNestedInput
    songArtists?: SongArtistUpdateManyWithoutSongNestedInput
    genres?: SongGenreUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateWithoutAlbumInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    songArtists?: SongArtistUncheckedUpdateManyWithoutSongNestedInput
    genres?: SongGenreUncheckedUpdateManyWithoutSongNestedInput
    playlistSongs?: PlaylistSongUncheckedUpdateManyWithoutSongNestedInput
    listeningHistory?: ListeningHistoryUncheckedUpdateManyWithoutSongNestedInput
    recentlyPlayed?: RecentlyPlayedUncheckedUpdateManyWithoutSongNestedInput
    playbackStates?: PlaybackStateUncheckedUpdateManyWithoutCurrentSongNestedInput
    playbackQueues?: PlaybackQueueUncheckedUpdateManyWithoutSongNestedInput
  }

  export type SongUncheckedUpdateManyWithoutAlbumInput = {
    id?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    trackNumber?: NullableIntFieldUpdateOperationsInput | number | null
    discNumber?: IntFieldUpdateOperationsInput | number
    durationMs?: IntFieldUpdateOperationsInput | number
    audioUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lyricsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isExplicit?: BoolFieldUpdateOperationsInput | boolean
    isPlayable?: BoolFieldUpdateOperationsInput | boolean
    playCount?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongArtistCreateManySongInput = {
    artistId: string
    role?: $Enums.ArtistRole
  }

  export type SongGenreCreateManySongInput = {
    genreId: string
  }

  export type PlaylistSongCreateManySongInput = {
    id?: string
    playlistId: string
    position: number
    addedBy?: string | null
    addedAt?: Date | string
  }

  export type ListeningHistoryCreateManySongInput = {
    id?: string
    userId: string
    playedAt?: Date | string
    durationMs: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type RecentlyPlayedCreateManySongInput = {
    id?: string
    userId: string
    playedAt?: Date | string
    contextType?: $Enums.ContextType | null
    contextId?: string | null
  }

  export type PlaybackStateCreateManyCurrentSongInput = {
    userId: string
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    activeDeviceId?: string | null
    updatedAt?: Date | string
  }

  export type PlaybackQueueCreateManySongInput = {
    id?: string
    userId: string
    position: number
    addedAt?: Date | string
  }

  export type SongArtistUpdateWithoutSongInput = {
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
    artist?: ArtistUpdateOneRequiredWithoutSongArtistsNestedInput
  }

  export type SongArtistUncheckedUpdateWithoutSongInput = {
    artistId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
  }

  export type SongArtistUncheckedUpdateManyWithoutSongInput = {
    artistId?: StringFieldUpdateOperationsInput | string
    role?: EnumArtistRoleFieldUpdateOperationsInput | $Enums.ArtistRole
  }

  export type SongGenreUpdateWithoutSongInput = {
    genre?: GenreUpdateOneRequiredWithoutSongsNestedInput
  }

  export type SongGenreUncheckedUpdateWithoutSongInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type SongGenreUncheckedUpdateManyWithoutSongInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistSongUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlist?: PlaylistUpdateOneRequiredWithoutSongsNestedInput
  }

  export type PlaylistSongUncheckedUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistSongUncheckedUpdateManyWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningHistoryUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutListeningHistoryNestedInput
  }

  export type ListeningHistoryUncheckedUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ListeningHistoryUncheckedUpdateManyWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecentlyPlayedUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutRecentlyPlayedNestedInput
  }

  export type RecentlyPlayedUncheckedUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecentlyPlayedUncheckedUpdateManyWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    playedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaybackStateUpdateWithoutCurrentSongInput = {
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaybackStateNestedInput
    activeDevice?: UserDeviceUpdateOneWithoutPlaybackStatesNestedInput
  }

  export type PlaybackStateUncheckedUpdateWithoutCurrentSongInput = {
    userId?: StringFieldUpdateOperationsInput | string
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    activeDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackStateUncheckedUpdateManyWithoutCurrentSongInput = {
    userId?: StringFieldUpdateOperationsInput | string
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    activeDeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackQueueUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaybackQueueNestedInput
  }

  export type PlaybackQueueUncheckedUpdateWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackQueueUncheckedUpdateManyWithoutSongInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SongGenreCreateManyGenreInput = {
    songId: string
  }

  export type ArtistGenreCreateManyGenreInput = {
    artistId: string
  }

  export type SongGenreUpdateWithoutGenreInput = {
    song?: SongUpdateOneRequiredWithoutGenresNestedInput
  }

  export type SongGenreUncheckedUpdateWithoutGenreInput = {
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type SongGenreUncheckedUpdateManyWithoutGenreInput = {
    songId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreUpdateWithoutGenreInput = {
    artist?: ArtistUpdateOneRequiredWithoutGenresNestedInput
  }

  export type ArtistGenreUncheckedUpdateWithoutGenreInput = {
    artistId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtistGenreUncheckedUpdateManyWithoutGenreInput = {
    artistId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistSongCreateManyPlaylistInput = {
    id?: string
    songId: string
    position: number
    addedBy?: string | null
    addedAt?: Date | string
  }

  export type UserFollowCreateManyPlaylistInput = {
    id?: string
    followerId: string
    followingType: $Enums.FollowType
    createdAt?: Date | string
  }

  export type PlaylistSongUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    song?: SongUpdateOneRequiredWithoutPlaylistSongsNestedInput
  }

  export type PlaylistSongUncheckedUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistSongUncheckedUpdateManyWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    songId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    addedBy?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowsNestedInput
  }

  export type UserFollowUncheckedUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFollowUncheckedUpdateManyWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingType?: EnumFollowTypeFieldUpdateOperationsInput | $Enums.FollowType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyDeviceInput = {
    id?: string
    userId: string
    tokenHash: string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    lastActivityAt?: Date | string
  }

  export type PlaybackStateCreateManyActiveDeviceInput = {
    userId: string
    currentSongId?: string | null
    progressMs?: number
    isPlaying?: boolean
    shuffleMode?: $Enums.ShuffleMode
    repeatMode?: $Enums.RepeatMode
    volume?: number
    contextType?: $Enums.ContextType | null
    contextId?: string | null
    updatedAt?: Date | string
  }

  export type DeviceSyncStateCreateManyDeviceInput = {
    id?: string
    userId: string
    syncType: $Enums.SyncType
    lastSyncVersion?: bigint | number
    lastSyncAt?: Date | string | null
    pendingChanges?: number
  }

  export type SyncLogCreateManySourceDeviceInput = {
    id?: string
    userId: string
    entityType: string
    entityId: string
    action: $Enums.SyncAction
    version: bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DeviceTransferCreateManyFromDeviceInput = {
    id?: string
    userId: string
    toDeviceId: string
    status?: $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type DeviceTransferCreateManyToDeviceInput = {
    id?: string
    userId: string
    fromDeviceId: string
    status?: $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type AdImpressionCreateManyDeviceInput = {
    id?: string
    userId: string
    adId: string
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type UserSessionUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackStateUpdateWithoutActiveDeviceInput = {
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlaybackStateNestedInput
    currentSong?: SongUpdateOneWithoutPlaybackStatesNestedInput
  }

  export type PlaybackStateUncheckedUpdateWithoutActiveDeviceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    currentSongId?: NullableStringFieldUpdateOperationsInput | string | null
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaybackStateUncheckedUpdateManyWithoutActiveDeviceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    currentSongId?: NullableStringFieldUpdateOperationsInput | string | null
    progressMs?: IntFieldUpdateOperationsInput | number
    isPlaying?: BoolFieldUpdateOperationsInput | boolean
    shuffleMode?: EnumShuffleModeFieldUpdateOperationsInput | $Enums.ShuffleMode
    repeatMode?: EnumRepeatModeFieldUpdateOperationsInput | $Enums.RepeatMode
    volume?: IntFieldUpdateOperationsInput | number
    contextType?: NullableEnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType | null
    contextId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceSyncStateUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    lastSyncVersion?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingChanges?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceSyncStateUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    lastSyncVersion?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingChanges?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceSyncStateUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    lastSyncVersion?: BigIntFieldUpdateOperationsInput | bigint | number
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pendingChanges?: IntFieldUpdateOperationsInput | number
  }

  export type SyncLogUpdateWithoutSourceDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumSyncActionFieldUpdateOperationsInput | $Enums.SyncAction
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogUncheckedUpdateWithoutSourceDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumSyncActionFieldUpdateOperationsInput | $Enums.SyncAction
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogUncheckedUpdateManyWithoutSourceDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumSyncActionFieldUpdateOperationsInput | $Enums.SyncAction
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTransferUpdateWithoutFromDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toDevice?: UserDeviceUpdateOneRequiredWithoutTransfersToNestedInput
  }

  export type DeviceTransferUncheckedUpdateWithoutFromDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    toDeviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTransferUncheckedUpdateManyWithoutFromDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    toDeviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTransferUpdateWithoutToDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromDevice?: UserDeviceUpdateOneRequiredWithoutTransfersFromNestedInput
  }

  export type DeviceTransferUncheckedUpdateWithoutToDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fromDeviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTransferUncheckedUpdateManyWithoutToDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fromDeviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdImpressionsNestedInput
    ad?: AdvertisementUpdateOneRequiredWithoutImpressionsNestedInput
  }

  export type AdImpressionUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionUncheckedUpdateManyWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateManyPlanInput = {
    id?: string
    userId: string
    status?: $Enums.SubscriptionStatus
    billingCycle?: $Enums.BillingCycle
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    cancelledAt?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    billingCycle?: EnumBillingCycleFieldUpdateOperationsInput | $Enums.BillingCycle
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionCreateManyAdInput = {
    id?: string
    userId: string
    deviceId?: string | null
    impressionType: $Enums.ImpressionType
    contextType?: $Enums.AdContextType | null
    revenue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type AdImpressionUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdImpressionsNestedInput
    device?: UserDeviceUpdateOneWithoutAdImpressionsNestedInput
  }

  export type AdImpressionUncheckedUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdImpressionUncheckedUpdateManyWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    impressionType?: EnumImpressionTypeFieldUpdateOperationsInput | $Enums.ImpressionType
    contextType?: NullableEnumAdContextTypeFieldUpdateOperationsInput | $Enums.AdContextType | null
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}